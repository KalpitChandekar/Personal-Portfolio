/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-spring";
exports.ids = ["vendor-chunks/@react-spring"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-spring/animated/dist/react-spring-animated.cjs.dev.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@react-spring/animated/dist/react-spring-animated.cjs.dev.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar shared = __webpack_require__(/*! @react-spring/shared */ \"(ssr)/./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nconst $node = Symbol.for('Animated:node');\nconst isAnimated = value => !!value && value[$node] === value;\nconst getAnimated = owner => owner && owner[$node];\nconst setAnimated = (owner, node) => shared.defineHidden(owner, $node, node);\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  constructor() {\n    this.payload = void 0;\n    setAnimated(this, this);\n  }\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this.done = true;\n    this.elapsedTime = void 0;\n    this.lastPosition = void 0;\n    this.lastVelocity = void 0;\n    this.v0 = void 0;\n    this.durationProgress = 0;\n    this._value = _value;\n\n    if (shared.is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  setValue(value, step) {\n    if (shared.is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (shared.is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = void 0;\n    this._toString = shared.createInterpolator({\n      output: [value, value]\n    });\n  }\n\n  static create(value) {\n    return new AnimatedString(value);\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (shared.is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = shared.createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  dependencies: null\n};\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    const values = {};\n    shared.eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (shared.hasFluidValue(source)) {\n        values[key] = shared.getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      shared.each(this.payload, node => node.reset());\n    }\n  }\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      shared.eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n\n  _addToPayload(source) {\n    if (TreeContext.dependencies && shared.hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      shared.each(payload, node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(source) {\n    const payload = this.getPayload();\n\n    if (source.length == payload.length) {\n      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);\n    }\n\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n\n}\n\nfunction makeAnimated(value) {\n  const nodeType = shared.isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : shared.is.arr(value) ? AnimatedArray : shared.isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nconst withAnimated = (Component, host) => {\n  const hasInstance = !shared.is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return React.forwardRef((givenProps, givenRef) => {\n    const instanceRef = React.useRef(null);\n    const ref = hasInstance && React.useCallback(value => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = shared.useForceUpdate();\n\n    const callback = () => {\n      const instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return;\n      }\n\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = React.useRef();\n    shared.useIsomorphicLayoutEffect(() => {\n      observerRef.current = observer;\n      shared.each(deps, dep => shared.addFluidObserver(dep, observer));\n      return () => {\n        if (observerRef.current) {\n          shared.each(observerRef.current.deps, dep => shared.removeFluidObserver(dep, observerRef.current));\n          shared.raf.cancel(observerRef.current.update);\n        }\n      };\n    });\n    React.useEffect(callback, []);\n    shared.useOnce(() => () => {\n      const observer = observerRef.current;\n      shared.each(observer.deps, dep => shared.removeFluidObserver(dep, observer));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return React__namespace.createElement(Component, _extends({}, usedProps, {\n      ref: ref\n    }));\n  });\n};\n\nclass PropsObserver {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      shared.raf.write(this.update);\n    }\n  }\n\n}\n\nfunction getAnimatedState(props, host) {\n  const dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = _extends({}, props, {\n    style: host.createAnimatedStyle(props.style)\n  });\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (shared.is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst createHost = (components, {\n  applyAnimatedValues: _applyAnimatedValues = () => false,\n  createAnimatedStyle: _createAnimatedStyle = style => new AnimatedObject(style),\n  getComponentProps: _getComponentProps = props => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues: _applyAnimatedValues,\n    createAnimatedStyle: _createAnimatedStyle,\n    getComponentProps: _getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || 'Anonymous';\n\n    if (shared.is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n\n  shared.eachProp(components, (Component, key) => {\n    if (shared.is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => shared.is.str(arg) ? arg : arg && shared.is.str(arg.displayName) ? arg.displayName : shared.is.fun(arg) && arg.name || null;\n\nexports.Animated = Animated;\nexports.AnimatedArray = AnimatedArray;\nexports.AnimatedObject = AnimatedObject;\nexports.AnimatedString = AnimatedString;\nexports.AnimatedValue = AnimatedValue;\nexports.createHost = createHost;\nexports.getAnimated = getAnimated;\nexports.getAnimatedType = getAnimatedType;\nexports.getPayload = getPayload;\nexports.isAnimated = isAnimated;\nexports.setAnimated = setAnimated;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9hbmltYXRlZC9kaXN0L3JlYWN0LXNwcmluZy1hbmltYXRlZC5janMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsYUFBYSxtQkFBTyxDQUFDLHVHQUFzQjtBQUMzQyxZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9hbmltYXRlZC9kaXN0L3JlYWN0LXNwcmluZy1hbmltYXRlZC5janMuZGV2LmpzPzk1MWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgc2hhcmVkID0gcmVxdWlyZSgnQHJlYWN0LXNwcmluZy9zaGFyZWQnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFJlYWN0KTtcblxuY29uc3QgJG5vZGUgPSBTeW1ib2wuZm9yKCdBbmltYXRlZDpub2RlJyk7XG5jb25zdCBpc0FuaW1hdGVkID0gdmFsdWUgPT4gISF2YWx1ZSAmJiB2YWx1ZVskbm9kZV0gPT09IHZhbHVlO1xuY29uc3QgZ2V0QW5pbWF0ZWQgPSBvd25lciA9PiBvd25lciAmJiBvd25lclskbm9kZV07XG5jb25zdCBzZXRBbmltYXRlZCA9IChvd25lciwgbm9kZSkgPT4gc2hhcmVkLmRlZmluZUhpZGRlbihvd25lciwgJG5vZGUsIG5vZGUpO1xuY29uc3QgZ2V0UGF5bG9hZCA9IG93bmVyID0+IG93bmVyICYmIG93bmVyWyRub2RlXSAmJiBvd25lclskbm9kZV0uZ2V0UGF5bG9hZCgpO1xuY2xhc3MgQW5pbWF0ZWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBheWxvYWQgPSB2b2lkIDA7XG4gICAgc2V0QW5pbWF0ZWQodGhpcywgdGhpcyk7XG4gIH1cblxuICBnZXRQYXlsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLnBheWxvYWQgfHwgW107XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlZFZhbHVlIGV4dGVuZHMgQW5pbWF0ZWQge1xuICBjb25zdHJ1Y3RvcihfdmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgdGhpcy5lbGFwc2VkVGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RWZWxvY2l0eSA9IHZvaWQgMDtcbiAgICB0aGlzLnYwID0gdm9pZCAwO1xuICAgIHRoaXMuZHVyYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG5cbiAgICBpZiAoc2hhcmVkLmlzLm51bSh0aGlzLl92YWx1ZSkpIHtcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gdGhpcy5fdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0ZWRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBnZXRQYXlsb2FkKCkge1xuICAgIHJldHVybiBbdGhpc107XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBzZXRWYWx1ZSh2YWx1ZSwgc3RlcCkge1xuICAgIGlmIChzaGFyZWQuaXMubnVtKHZhbHVlKSkge1xuICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSB2YWx1ZTtcblxuICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gc3RlcCkgKiBzdGVwO1xuXG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkb25lXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5kb25lID0gZmFsc2U7XG5cbiAgICBpZiAoc2hhcmVkLmlzLm51bSh0aGlzLl92YWx1ZSkpIHtcbiAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgdGhpcy5kdXJhdGlvblByb2dyZXNzID0gMDtcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gdGhpcy5fdmFsdWU7XG4gICAgICBpZiAoZG9uZSkgdGhpcy5sYXN0VmVsb2NpdHkgPSBudWxsO1xuICAgICAgdGhpcy52MCA9IG51bGw7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgQW5pbWF0ZWRTdHJpbmcgZXh0ZW5kcyBBbmltYXRlZFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcigwKTtcbiAgICB0aGlzLl9zdHJpbmcgPSBudWxsO1xuICAgIHRoaXMuX3RvU3RyaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuX3RvU3RyaW5nID0gc2hhcmVkLmNyZWF0ZUludGVycG9sYXRvcih7XG4gICAgICBvdXRwdXQ6IFt2YWx1ZSwgdmFsdWVdXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZFN0cmluZyh2YWx1ZSk7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLl9zdHJpbmc7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzLl9zdHJpbmcgPSB0aGlzLl90b1N0cmluZyh0aGlzLl92YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHNoYXJlZC5pcy5zdHIodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gdGhpcy5fc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RyaW5nID0gdmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdXBlci5zZXRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX3N0cmluZyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJlc2V0KGdvYWwpIHtcbiAgICBpZiAoZ29hbCkge1xuICAgICAgdGhpcy5fdG9TdHJpbmcgPSBzaGFyZWQuY3JlYXRlSW50ZXJwb2xhdG9yKHtcbiAgICAgICAgb3V0cHV0OiBbdGhpcy5nZXRWYWx1ZSgpLCBnb2FsXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUgPSAwO1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gIH1cblxufVxuXG5jb25zdCBUcmVlQ29udGV4dCA9IHtcbiAgZGVwZW5kZW5jaWVzOiBudWxsXG59O1xuXG5jbGFzcyBBbmltYXRlZE9iamVjdCBleHRlbmRzIEFuaW1hdGVkIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnNldFZhbHVlKHNvdXJjZSk7XG4gIH1cblxuICBnZXRWYWx1ZShhbmltYXRlZCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IHt9O1xuICAgIHNoYXJlZC5lYWNoUHJvcCh0aGlzLnNvdXJjZSwgKHNvdXJjZSwga2V5KSA9PiB7XG4gICAgICBpZiAoaXNBbmltYXRlZChzb3VyY2UpKSB7XG4gICAgICAgIHZhbHVlc1trZXldID0gc291cmNlLmdldFZhbHVlKGFuaW1hdGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hhcmVkLmhhc0ZsdWlkVmFsdWUoc291cmNlKSkge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IHNoYXJlZC5nZXRGbHVpZFZhbHVlKHNvdXJjZSk7XG4gICAgICB9IGVsc2UgaWYgKCFhbmltYXRlZCkge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgc2V0VmFsdWUoc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5wYXlsb2FkID0gdGhpcy5fbWFrZVBheWxvYWQoc291cmNlKTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnBheWxvYWQpIHtcbiAgICAgIHNoYXJlZC5lYWNoKHRoaXMucGF5bG9hZCwgbm9kZSA9PiBub2RlLnJlc2V0KCkpO1xuICAgIH1cbiAgfVxuXG4gIF9tYWtlUGF5bG9hZChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gbmV3IFNldCgpO1xuICAgICAgc2hhcmVkLmVhY2hQcm9wKHNvdXJjZSwgdGhpcy5fYWRkVG9QYXlsb2FkLCBwYXlsb2FkKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHBheWxvYWQpO1xuICAgIH1cbiAgfVxuXG4gIF9hZGRUb1BheWxvYWQoc291cmNlKSB7XG4gICAgaWYgKFRyZWVDb250ZXh0LmRlcGVuZGVuY2llcyAmJiBzaGFyZWQuaGFzRmx1aWRWYWx1ZShzb3VyY2UpKSB7XG4gICAgICBUcmVlQ29udGV4dC5kZXBlbmRlbmNpZXMuYWRkKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IGdldFBheWxvYWQoc291cmNlKTtcblxuICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICBzaGFyZWQuZWFjaChwYXlsb2FkLCBub2RlID0+IHRoaXMuYWRkKG5vZGUpKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlZEFycmF5IGV4dGVuZHMgQW5pbWF0ZWRPYmplY3Qge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGVkQXJyYXkoc291cmNlKTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5tYXAobm9kZSA9PiBub2RlLmdldFZhbHVlKCkpO1xuICB9XG5cbiAgc2V0VmFsdWUoc291cmNlKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZ2V0UGF5bG9hZCgpO1xuXG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT0gcGF5bG9hZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkLm1hcCgobm9kZSwgaSkgPT4gbm9kZS5zZXRWYWx1ZShzb3VyY2VbaV0pKS5zb21lKEJvb2xlYW4pO1xuICAgIH1cblxuICAgIHN1cGVyLnNldFZhbHVlKHNvdXJjZS5tYXAobWFrZUFuaW1hdGVkKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBtYWtlQW5pbWF0ZWQodmFsdWUpIHtcbiAgY29uc3Qgbm9kZVR5cGUgPSBzaGFyZWQuaXNBbmltYXRlZFN0cmluZyh2YWx1ZSkgPyBBbmltYXRlZFN0cmluZyA6IEFuaW1hdGVkVmFsdWU7XG4gIHJldHVybiBub2RlVHlwZS5jcmVhdGUodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRlZFR5cGUodmFsdWUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldEFuaW1hdGVkKHZhbHVlKTtcbiAgcmV0dXJuIHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmNvbnN0cnVjdG9yIDogc2hhcmVkLmlzLmFycih2YWx1ZSkgPyBBbmltYXRlZEFycmF5IDogc2hhcmVkLmlzQW5pbWF0ZWRTdHJpbmcodmFsdWUpID8gQW5pbWF0ZWRTdHJpbmcgOiBBbmltYXRlZFZhbHVlO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmNvbnN0IHdpdGhBbmltYXRlZCA9IChDb21wb25lbnQsIGhvc3QpID0+IHtcbiAgY29uc3QgaGFzSW5zdGFuY2UgPSAhc2hhcmVkLmlzLmZ1bihDb21wb25lbnQpIHx8IENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xuICByZXR1cm4gUmVhY3QuZm9yd2FyZFJlZigoZ2l2ZW5Qcm9wcywgZ2l2ZW5SZWYpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCByZWYgPSBoYXNJbnN0YW5jZSAmJiBSZWFjdC51c2VDYWxsYmFjayh2YWx1ZSA9PiB7XG4gICAgICBpbnN0YW5jZVJlZi5jdXJyZW50ID0gdXBkYXRlUmVmKGdpdmVuUmVmLCB2YWx1ZSk7XG4gICAgfSwgW2dpdmVuUmVmXSk7XG4gICAgY29uc3QgW3Byb3BzLCBkZXBzXSA9IGdldEFuaW1hdGVkU3RhdGUoZ2l2ZW5Qcm9wcywgaG9zdCk7XG4gICAgY29uc3QgZm9yY2VVcGRhdGUgPSBzaGFyZWQudXNlRm9yY2VVcGRhdGUoKTtcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZVJlZi5jdXJyZW50O1xuXG4gICAgICBpZiAoaGFzSW5zdGFuY2UgJiYgIWluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlkVXBkYXRlID0gaW5zdGFuY2UgPyBob3N0LmFwcGx5QW5pbWF0ZWRWYWx1ZXMoaW5zdGFuY2UsIHByb3BzLmdldFZhbHVlKHRydWUpKSA6IGZhbHNlO1xuXG4gICAgICBpZiAoZGlkVXBkYXRlID09PSBmYWxzZSkge1xuICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBQcm9wc09ic2VydmVyKGNhbGxiYWNrLCBkZXBzKTtcbiAgICBjb25zdCBvYnNlcnZlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQgPSBvYnNlcnZlcjtcbiAgICAgIHNoYXJlZC5lYWNoKGRlcHMsIGRlcCA9PiBzaGFyZWQuYWRkRmx1aWRPYnNlcnZlcihkZXAsIG9ic2VydmVyKSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAob2JzZXJ2ZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgIHNoYXJlZC5lYWNoKG9ic2VydmVyUmVmLmN1cnJlbnQuZGVwcywgZGVwID0+IHNoYXJlZC5yZW1vdmVGbHVpZE9ic2VydmVyKGRlcCwgb2JzZXJ2ZXJSZWYuY3VycmVudCkpO1xuICAgICAgICAgIHNoYXJlZC5yYWYuY2FuY2VsKG9ic2VydmVyUmVmLmN1cnJlbnQudXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBSZWFjdC51c2VFZmZlY3QoY2FsbGJhY2ssIFtdKTtcbiAgICBzaGFyZWQudXNlT25jZSgoKSA9PiAoKSA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG9ic2VydmVyUmVmLmN1cnJlbnQ7XG4gICAgICBzaGFyZWQuZWFjaChvYnNlcnZlci5kZXBzLCBkZXAgPT4gc2hhcmVkLnJlbW92ZUZsdWlkT2JzZXJ2ZXIoZGVwLCBvYnNlcnZlcikpO1xuICAgIH0pO1xuICAgIGNvbnN0IHVzZWRQcm9wcyA9IGhvc3QuZ2V0Q29tcG9uZW50UHJvcHMocHJvcHMuZ2V0VmFsdWUoKSk7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCB1c2VkUHJvcHMsIHtcbiAgICAgIHJlZjogcmVmXG4gICAgfSkpO1xuICB9KTtcbn07XG5cbmNsYXNzIFByb3BzT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3Rvcih1cGRhdGUsIGRlcHMpIHtcbiAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICB0aGlzLmRlcHMgPSBkZXBzO1xuICB9XG5cbiAgZXZlbnRPYnNlcnZlZChldmVudCkge1xuICAgIGlmIChldmVudC50eXBlID09ICdjaGFuZ2UnKSB7XG4gICAgICBzaGFyZWQucmFmLndyaXRlKHRoaXMudXBkYXRlKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRlZFN0YXRlKHByb3BzLCBob3N0KSB7XG4gIGNvbnN0IGRlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgVHJlZUNvbnRleHQuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICBpZiAocHJvcHMuc3R5bGUpIHByb3BzID0gX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgc3R5bGU6IGhvc3QuY3JlYXRlQW5pbWF0ZWRTdHlsZShwcm9wcy5zdHlsZSlcbiAgfSk7XG4gIHByb3BzID0gbmV3IEFuaW1hdGVkT2JqZWN0KHByb3BzKTtcbiAgVHJlZUNvbnRleHQuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgcmV0dXJuIFtwcm9wcywgZGVwZW5kZW5jaWVzXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVmKHJlZiwgdmFsdWUpIHtcbiAgaWYgKHJlZikge1xuICAgIGlmIChzaGFyZWQuaXMuZnVuKHJlZikpIHJlZih2YWx1ZSk7ZWxzZSByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5jb25zdCBjYWNoZUtleSA9IFN5bWJvbC5mb3IoJ0FuaW1hdGVkQ29tcG9uZW50Jyk7XG5jb25zdCBjcmVhdGVIb3N0ID0gKGNvbXBvbmVudHMsIHtcbiAgYXBwbHlBbmltYXRlZFZhbHVlczogX2FwcGx5QW5pbWF0ZWRWYWx1ZXMgPSAoKSA9PiBmYWxzZSxcbiAgY3JlYXRlQW5pbWF0ZWRTdHlsZTogX2NyZWF0ZUFuaW1hdGVkU3R5bGUgPSBzdHlsZSA9PiBuZXcgQW5pbWF0ZWRPYmplY3Qoc3R5bGUpLFxuICBnZXRDb21wb25lbnRQcm9wczogX2dldENvbXBvbmVudFByb3BzID0gcHJvcHMgPT4gcHJvcHNcbn0gPSB7fSkgPT4ge1xuICBjb25zdCBob3N0Q29uZmlnID0ge1xuICAgIGFwcGx5QW5pbWF0ZWRWYWx1ZXM6IF9hcHBseUFuaW1hdGVkVmFsdWVzLFxuICAgIGNyZWF0ZUFuaW1hdGVkU3R5bGU6IF9jcmVhdGVBbmltYXRlZFN0eWxlLFxuICAgIGdldENvbXBvbmVudFByb3BzOiBfZ2V0Q29tcG9uZW50UHJvcHNcbiAgfTtcblxuICBjb25zdCBhbmltYXRlZCA9IENvbXBvbmVudCA9PiB7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHx8ICdBbm9ueW1vdXMnO1xuXG4gICAgaWYgKHNoYXJlZC5pcy5zdHIoQ29tcG9uZW50KSkge1xuICAgICAgQ29tcG9uZW50ID0gYW5pbWF0ZWRbQ29tcG9uZW50XSB8fCAoYW5pbWF0ZWRbQ29tcG9uZW50XSA9IHdpdGhBbmltYXRlZChDb21wb25lbnQsIGhvc3RDb25maWcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50W2NhY2hlS2V5XSB8fCAoQ29tcG9uZW50W2NhY2hlS2V5XSA9IHdpdGhBbmltYXRlZChDb21wb25lbnQsIGhvc3RDb25maWcpKTtcbiAgICB9XG5cbiAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBgQW5pbWF0ZWQoJHtkaXNwbGF5TmFtZX0pYDtcbiAgICByZXR1cm4gQ29tcG9uZW50O1xuICB9O1xuXG4gIHNoYXJlZC5lYWNoUHJvcChjb21wb25lbnRzLCAoQ29tcG9uZW50LCBrZXkpID0+IHtcbiAgICBpZiAoc2hhcmVkLmlzLmFycihjb21wb25lbnRzKSkge1xuICAgICAga2V5ID0gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBhbmltYXRlZFtrZXldID0gYW5pbWF0ZWQoQ29tcG9uZW50KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYW5pbWF0ZWRcbiAgfTtcbn07XG5cbmNvbnN0IGdldERpc3BsYXlOYW1lID0gYXJnID0+IHNoYXJlZC5pcy5zdHIoYXJnKSA/IGFyZyA6IGFyZyAmJiBzaGFyZWQuaXMuc3RyKGFyZy5kaXNwbGF5TmFtZSkgPyBhcmcuZGlzcGxheU5hbWUgOiBzaGFyZWQuaXMuZnVuKGFyZykgJiYgYXJnLm5hbWUgfHwgbnVsbDtcblxuZXhwb3J0cy5BbmltYXRlZCA9IEFuaW1hdGVkO1xuZXhwb3J0cy5BbmltYXRlZEFycmF5ID0gQW5pbWF0ZWRBcnJheTtcbmV4cG9ydHMuQW5pbWF0ZWRPYmplY3QgPSBBbmltYXRlZE9iamVjdDtcbmV4cG9ydHMuQW5pbWF0ZWRTdHJpbmcgPSBBbmltYXRlZFN0cmluZztcbmV4cG9ydHMuQW5pbWF0ZWRWYWx1ZSA9IEFuaW1hdGVkVmFsdWU7XG5leHBvcnRzLmNyZWF0ZUhvc3QgPSBjcmVhdGVIb3N0O1xuZXhwb3J0cy5nZXRBbmltYXRlZCA9IGdldEFuaW1hdGVkO1xuZXhwb3J0cy5nZXRBbmltYXRlZFR5cGUgPSBnZXRBbmltYXRlZFR5cGU7XG5leHBvcnRzLmdldFBheWxvYWQgPSBnZXRQYXlsb2FkO1xuZXhwb3J0cy5pc0FuaW1hdGVkID0gaXNBbmltYXRlZDtcbmV4cG9ydHMuc2V0QW5pbWF0ZWQgPSBzZXRBbmltYXRlZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/animated/dist/react-spring-animated.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-spring-animated.cjs.dev.js */ \"(ssr)/./node_modules/@react-spring/animated/dist/react-spring-animated.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9hbmltYXRlZC9kaXN0L3JlYWN0LXNwcmluZy1hbmltYXRlZC5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLG1LQUE4RDtBQUNoRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL2FuaW1hdGVkL2Rpc3QvcmVhY3Qtc3ByaW5nLWFuaW1hdGVkLmNqcy5qcz8wZjQ3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlYWN0LXNwcmluZy1hbmltYXRlZC5janMucHJvZC5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVhY3Qtc3ByaW5nLWFuaW1hdGVkLmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/core/dist/react-spring-core.cjs.dev.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-spring/core/dist/react-spring-core.cjs.dev.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar shared = __webpack_require__(/*! @react-spring/shared */ \"(ssr)/./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar animated$1 = __webpack_require__(/*! @react-spring/animated */ \"(ssr)/./node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js\");\nvar animated = __webpack_require__(/*! @react-spring/types/animated */ \"(ssr)/./node_modules/@react-spring/types/animated.js\");\nvar interpolation = __webpack_require__(/*! @react-spring/types/interpolation */ \"(ssr)/./node_modules/@react-spring/types/interpolation.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction callProp(value, ...args) {\n  return shared.is.fun(value) ? value(...args) : value;\n}\nconst matchProp = (value, key) => value === true || !!(key && value && (shared.is.fun(value) ? value(key) : shared.toArray(value).includes(key)));\nconst resolveProp = (prop, key) => shared.is.obj(prop) ? key && prop[key] : prop;\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : undefined;\n\nconst noopTransform = value => value;\n\nconst getDefaultProps = (props, transform = noopTransform) => {\n  let keys = DEFAULT_PROPS;\n\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n\n  const defaults = {};\n\n  for (const key of keys) {\n    const value = transform(props[key], key);\n\n    if (!shared.is.und(value)) {\n      defaults[key] = value;\n    }\n  }\n\n  return defaults;\n};\nconst DEFAULT_PROPS = ['config', 'onProps', 'onStart', 'onChange', 'onPause', 'onResume', 'onRest'];\nconst RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onPause: 1,\n  onResume: 1,\n  onRest: 1,\n  onResolve: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  onDestroyed: 1,\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  shared.eachProp(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n\nfunction inferTo(props) {\n  const to = getForwardProps(props);\n\n  if (to) {\n    const out = {\n      to\n    };\n    shared.eachProp(props, (val, key) => key in to || (out[key] = val));\n    return out;\n  }\n\n  return _extends({}, props);\n}\nfunction computeGoal(value) {\n  value = shared.getFluidValue(value);\n  return shared.is.arr(value) ? value.map(computeGoal) : shared.isAnimatedString(value) ? shared.Globals.createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\nfunction hasProps(props) {\n  for (const _ in props) return true;\n\n  return false;\n}\nfunction isAsyncTo(to) {\n  return shared.is.fun(to) || shared.is.arr(to) && shared.is.obj(to[0]);\n}\nfunction detachRefs(ctrl, ref) {\n  var _ctrl$ref;\n\n  (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);\n  ref == null ? void 0 : ref.delete(ctrl);\n}\nfunction replaceRef(ctrl, ref) {\n  if (ref && ctrl.ref !== ref) {\n    var _ctrl$ref2;\n\n    (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);\n    ref.add(ctrl);\n    ctrl.ref = ref;\n  }\n}\n\nfunction useChain(refs, timeSteps, timeFrame = 1000) {\n  shared.useIsomorphicLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      shared.each(refs, (ref, i) => {\n        const controllers = ref.current;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i];\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          shared.each(controllers, ctrl => {\n            shared.each(ctrl.queue, props => {\n              const memoizedDelayProp = props.delay;\n\n              props.delay = key => delay + callProp(memoizedDelayProp || 0, key);\n            });\n          });\n          ref.start();\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      shared.each(refs, ref => {\n        const controllers = ref.current;\n\n        if (controllers.length) {\n          const queues = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          });\n          p = p.then(() => {\n            shared.each(controllers, (ctrl, i) => shared.each(queues[i] || [], update => ctrl.queue.push(update)));\n            return Promise.all(ref.start());\n          });\n        }\n      });\n    }\n  });\n}\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nconst defaults = _extends({}, config.default, {\n  mass: 1,\n  damping: 1,\n  easing: shared.easings.linear,\n  clamp: false\n});\n\nclass AnimationConfig {\n  constructor() {\n    this.tension = void 0;\n    this.friction = void 0;\n    this.frequency = void 0;\n    this.damping = void 0;\n    this.mass = void 0;\n    this.velocity = 0;\n    this.restVelocity = void 0;\n    this.precision = void 0;\n    this.progress = void 0;\n    this.duration = void 0;\n    this.easing = void 0;\n    this.clamp = void 0;\n    this.bounce = void 0;\n    this.decay = void 0;\n    this.round = void 0;\n    Object.assign(this, defaults);\n  }\n\n}\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _extends({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _extends({}, defaultConfig, newConfig);\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  let {\n    mass,\n    frequency,\n    damping\n  } = config;\n\n  if (!shared.is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n}\n\nfunction sanitizeConfig(config, props) {\n  if (!shared.is.und(props.decay)) {\n    config.duration = undefined;\n  } else {\n    const isTensionConfig = !shared.is.und(props.tension) || !shared.is.und(props.friction);\n\n    if (isTensionConfig || !shared.is.und(props.frequency) || !shared.is.und(props.damping) || !shared.is.und(props.mass)) {\n      config.duration = undefined;\n      config.decay = undefined;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = undefined;\n    }\n  }\n}\n\nconst emptyArray = [];\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.to = void 0;\n    this.from = void 0;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n  }\n\n}\n\nfunction scheduleProps(callId, {\n  key,\n  props,\n  defaultProps,\n  state,\n  actions\n}) {\n  return new Promise((resolve, reject) => {\n    var _props$cancel;\n\n    let delay;\n    let timeout;\n    let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps == null ? void 0 : defaultProps.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      if (!shared.is.und(props.pause)) {\n        state.paused = matchProp(props.pause, key);\n      }\n\n      let pause = defaultProps == null ? void 0 : defaultProps.pause;\n\n      if (pause !== true) {\n        pause = state.paused || matchProp(pause, key);\n      }\n\n      delay = callProp(props.delay || 0, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      state.timeouts.delete(timeout);\n      timeout.cancel();\n      delay = timeout.time - shared.raf.now();\n    }\n\n    function onResume() {\n      if (delay > 0 && !shared.Globals.skipAnimation) {\n        state.delayed = true;\n        timeout = shared.raf.setTimeout(onStart, delay);\n        state.pauseQueue.add(onPause);\n        state.timeouts.add(timeout);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      if (state.delayed) {\n        state.delayed = false;\n      }\n\n      state.pauseQueue.delete(onPause);\n      state.timeouts.delete(timeout);\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start(_extends({}, props, {\n          callId,\n          cancel\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some(result => result.cancelled) ? getCancelledResult(target.get()) : results.every(result => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every(result => result.finished));\nconst getNoopResult = value => ({\n  value,\n  noop: true,\n  finished: true,\n  cancelled: false\n});\nconst getFinishedResult = (value, finished, cancelled = false) => ({\n  value,\n  finished,\n  cancelled\n});\nconst getCancelledResult = value => ({\n  value,\n  cancelled: true,\n  finished: false\n});\n\nfunction runAsync(to, props, state, target) {\n  const {\n    callId,\n    parentId,\n    onRest\n  } = props;\n  const {\n    asyncTo: prevTo,\n    promise: prevPromise\n  } = state;\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to;\n    const defaultProps = getDefaultProps(props, (value, key) => key === 'onRest' ? undefined : value);\n    let preventBail;\n    let bail;\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));\n\n    const bailIfEnded = bailSignal => {\n      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);\n\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        bail(bailSignal);\n        throw bailSignal;\n      }\n    };\n\n    const animate = (arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      const skipAnimationSignal = new SkipAnimationSignal();\n      return (async () => {\n        if (shared.Globals.skipAnimation) {\n          stopAsync(state);\n          skipAnimationSignal.result = getFinishedResult(target, false);\n          bail(skipAnimationSignal);\n          throw skipAnimationSignal;\n        }\n\n        bailIfEnded(bailSignal);\n        const props = shared.is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {\n          to: arg1\n        });\n        props.parentId = callId;\n        shared.eachProp(defaultProps, (value, key) => {\n          if (shared.is.und(props[key])) {\n            props[key] = value;\n          }\n        });\n        const result = await target.start(props);\n        bailIfEnded(bailSignal);\n\n        if (state.paused) {\n          await new Promise(resume => {\n            state.resumeQueue.add(resume);\n          });\n        }\n\n        return result;\n      })();\n    };\n\n    let result;\n\n    if (shared.Globals.skipAnimation) {\n      stopAsync(state);\n      return getFinishedResult(target, false);\n    }\n\n    try {\n      let animating;\n\n      if (shared.is.arr(to)) {\n        animating = (async queue => {\n          for (const props of queue) {\n            await animate(props);\n          }\n        })(to);\n      } else {\n        animating = Promise.resolve(to(animate, target.stop.bind(target)));\n      }\n\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target.get(), true, false);\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else if (err instanceof SkipAnimationSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      }\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : undefined;\n        state.promise = parentId ? prevPromise : undefined;\n      }\n    }\n\n    if (shared.is.fun(onRest)) {\n      shared.raf.batchedUpdates(() => {\n        onRest(result, target, target.item);\n      });\n    }\n\n    return result;\n  })();\n}\nfunction stopAsync(state, cancelId) {\n  shared.flush(state.timeouts, t => t.cancel());\n  state.pauseQueue.clear();\n  state.resumeQueue.clear();\n  state.asyncId = state.asyncTo = state.promise = undefined;\n  if (cancelId) state.cancelId = cancelId;\n}\nclass BailSignal extends Error {\n  constructor() {\n    super('An async animation has been interrupted. You see this error because you ' + 'forgot to use `await` or `.catch(...)` on its returned promise.');\n    this.result = void 0;\n  }\n\n}\nclass SkipAnimationSignal extends Error {\n  constructor() {\n    super('SkipAnimationSignal');\n    this.result = void 0;\n  }\n\n}\n\nconst isFrameValue = value => value instanceof FrameValue;\nlet nextId$1 = 1;\nclass FrameValue extends shared.FluidValue {\n  constructor(...args) {\n    super(...args);\n    this.id = nextId$1++;\n    this.key = void 0;\n    this._priority = 0;\n  }\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n\n  get() {\n    const node = animated$1.getAnimated(this);\n    return node && node.getValue();\n  }\n\n  to(...args) {\n    return shared.Globals.to(this, args);\n  }\n\n  interpolate(...args) {\n    shared.deprecateInterpolate();\n    return shared.Globals.to(this, args);\n  }\n\n  toJSON() {\n    return this.get();\n  }\n\n  observerAdded(count) {\n    if (count == 1) this._attach();\n  }\n\n  observerRemoved(count) {\n    if (count == 0) this._detach();\n  }\n\n  _attach() {}\n\n  _detach() {}\n\n  _onChange(value, idle = false) {\n    shared.callFluidObservers(this, {\n      type: 'change',\n      parent: this,\n      value,\n      idle\n    });\n  }\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      shared.frameLoop.sort(this);\n    }\n\n    shared.callFluidObservers(this, {\n      type: 'priority',\n      parent: this,\n      priority\n    });\n  }\n\n}\n\nconst $P = Symbol.for('SpringPhase');\nconst HAS_ANIMATED = 1;\nconst IS_ANIMATING = 2;\nconst IS_PAUSED = 4;\nconst hasAnimated = target => (target[$P] & HAS_ANIMATED) > 0;\nconst isAnimating = target => (target[$P] & IS_ANIMATING) > 0;\nconst isPaused = target => (target[$P] & IS_PAUSED) > 0;\nconst setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;\nconst setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;\n\nclass SpringValue extends FrameValue {\n  constructor(arg1, arg2) {\n    super();\n    this.key = void 0;\n    this.animation = new Animation();\n    this.queue = void 0;\n    this.defaultProps = {};\n    this._state = {\n      paused: false,\n      delayed: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._pendingCalls = new Set();\n    this._lastCallId = 0;\n    this._lastToId = 0;\n    this._memoizedDuration = 0;\n\n    if (!shared.is.und(arg1) || !shared.is.und(arg2)) {\n      const props = shared.is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {\n        from: arg1\n      });\n\n      if (shared.is.und(props.default)) {\n        props.default = true;\n      }\n\n      this.start(props);\n    }\n  }\n\n  get idle() {\n    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);\n  }\n\n  get goal() {\n    return shared.getFluidValue(this.animation.to);\n  }\n\n  get velocity() {\n    const node = animated$1.getAnimated(this);\n    return node instanceof animated$1.AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node => node.lastVelocity || 0);\n  }\n\n  get hasAnimated() {\n    return hasAnimated(this);\n  }\n\n  get isAnimating() {\n    return isAnimating(this);\n  }\n\n  get isPaused() {\n    return isPaused(this);\n  }\n\n  get isDelayed() {\n    return this._state.delayed;\n  }\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let {\n      config,\n      toValues\n    } = anim;\n    const payload = animated$1.getPayload(anim.to);\n\n    if (!payload && shared.hasFluidValue(anim.to)) {\n      toValues = shared.toArray(shared.getFluidValue(anim.to));\n    }\n\n    anim.values.forEach((node, i) => {\n      if (node.done) return;\n      const to = node.constructor == animated$1.AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];\n      let finished = anim.immediate;\n      let position = to;\n\n      if (!finished) {\n        position = node.lastPosition;\n\n        if (config.tension <= 0) {\n          node.done = true;\n          return;\n        }\n\n        let elapsed = node.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node.v0 != null ? node.v0 : node.v0 = shared.is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        let velocity;\n        const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n\n        if (!shared.is.und(config.duration)) {\n          let p = 1;\n\n          if (config.duration > 0) {\n            if (this._memoizedDuration !== config.duration) {\n              this._memoizedDuration = config.duration;\n\n              if (node.durationProgress > 0) {\n                node.elapsedTime = config.duration * node.durationProgress;\n                elapsed = node.elapsedTime += dt;\n              }\n            }\n\n            p = (config.progress || 0) + elapsed / this._memoizedDuration;\n            p = p > 1 ? 1 : p < 0 ? 0 : p;\n            node.durationProgress = p;\n          }\n\n          position = from + config.easing(p) * (to - from);\n          velocity = (position - node.lastPosition) / dt;\n          finished = p == 1;\n        } else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e);\n          finished = Math.abs(node.lastPosition - position) <= precision;\n          velocity = v0 * e;\n        } else {\n          velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n          const restVelocity = config.restVelocity || precision / 10;\n          const bounceFactor = config.clamp ? 0 : config.bounce;\n          const canBounce = !shared.is.und(bounceFactor);\n          const isGrowing = from == to ? node.v0 > 0 : from < to;\n          let isMoving;\n          let isBouncing = false;\n          const step = 1;\n          const numSteps = Math.ceil(dt / step);\n\n          for (let n = 0; n < numSteps; ++n) {\n            isMoving = Math.abs(velocity) > restVelocity;\n\n            if (!isMoving) {\n              finished = Math.abs(to - position) <= precision;\n\n              if (finished) {\n                break;\n              }\n            }\n\n            if (canBounce) {\n              isBouncing = position == to || position > to == isGrowing;\n\n              if (isBouncing) {\n                velocity = -velocity * bounceFactor;\n                position = to;\n              }\n            }\n\n            const springForce = -config.tension * 0.000001 * (position - to);\n            const dampingForce = -config.friction * 0.001 * velocity;\n            const acceleration = (springForce + dampingForce) / config.mass;\n            velocity = velocity + acceleration * step;\n            position = position + velocity * step;\n          }\n        }\n\n        node.lastVelocity = velocity;\n\n        if (Number.isNaN(position)) {\n          console.warn(`Got NaN while animating:`, this);\n          finished = true;\n        }\n      }\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n\n      if (finished) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n    const node = animated$1.getAnimated(this);\n    const currVal = node.getValue();\n\n    if (idle) {\n      const finalVal = shared.getFluidValue(anim.to);\n\n      if ((currVal !== finalVal || changed) && !config.decay) {\n        node.setValue(finalVal);\n\n        this._onChange(finalVal);\n      } else if (changed && config.decay) {\n        this._onChange(currVal);\n      }\n\n      this._stop();\n    } else if (changed) {\n      this._onChange(currVal);\n    }\n  }\n\n  set(value) {\n    shared.raf.batchedUpdates(() => {\n      this._stop();\n\n      this._focus(value);\n\n      this._set(value);\n    });\n    return this;\n  }\n\n  pause() {\n    this._update({\n      pause: true\n    });\n  }\n\n  resume() {\n    this._update({\n      pause: false\n    });\n  }\n\n  finish() {\n    if (isAnimating(this)) {\n      const {\n        to,\n        config\n      } = this.animation;\n      shared.raf.batchedUpdates(() => {\n        this._onStart();\n\n        if (!config.decay) {\n          this._set(to, false);\n        }\n\n        this._stop();\n      });\n    }\n\n    return this;\n  }\n\n  update(props) {\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n\n  start(to, arg2) {\n    let queue;\n\n    if (!shared.is.und(to)) {\n      queue = [shared.is.obj(to) ? to : _extends({}, arg2, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    return Promise.all(queue.map(props => {\n      const up = this._update(props);\n\n      return up;\n    })).then(results => getCombinedResult(this, results));\n  }\n\n  stop(cancel) {\n    const {\n      to\n    } = this.animation;\n\n    this._focus(this.get());\n\n    stopAsync(this._state, cancel && this._lastCallId);\n    shared.raf.batchedUpdates(() => this._stop(to, cancel));\n    return this;\n  }\n\n  reset() {\n    this._update({\n      reset: true\n    });\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      this._start();\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n\n  _prepareNode(props) {\n    const key = this.key || '';\n    let {\n      to,\n      from\n    } = props;\n    to = shared.is.obj(to) ? to[key] : to;\n\n    if (to == null || isAsyncTo(to)) {\n      to = undefined;\n    }\n\n    from = shared.is.obj(from) ? from[key] : from;\n\n    if (from == null) {\n      from = undefined;\n    }\n\n    const range = {\n      to,\n      from\n    };\n\n    if (!hasAnimated(this)) {\n      if (props.reverse) [to, from] = [from, to];\n      from = shared.getFluidValue(from);\n\n      if (!shared.is.und(from)) {\n        this._set(from);\n      } else if (!animated$1.getAnimated(this)) {\n        this._set(to);\n      }\n    }\n\n    return range;\n  }\n\n  _update(_ref, isLoop) {\n    let props = _extends({}, _ref);\n\n    const {\n      key,\n      defaultProps\n    } = this;\n    if (props.default) Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));\n    mergeActiveFn(this, props, 'onProps');\n    sendEvent(this, 'onProps', props, this);\n\n    const range = this._prepareNode(props);\n\n    if (Object.isFrozen(this)) {\n      throw Error('Cannot animate a `SpringValue` object that is frozen. ' + 'Did you forget to pass your component to `animated(...)` before animating its props?');\n    }\n\n    const state = this._state;\n    return scheduleProps(++this._lastCallId, {\n      key,\n      props,\n      defaultProps,\n      state,\n      actions: {\n        pause: () => {\n          if (!isPaused(this)) {\n            setPausedBit(this, true);\n            shared.flushCalls(state.pauseQueue);\n            sendEvent(this, 'onPause', getFinishedResult(this, checkFinished(this, this.animation.to)), this);\n          }\n        },\n        resume: () => {\n          if (isPaused(this)) {\n            setPausedBit(this, false);\n\n            if (isAnimating(this)) {\n              this._resume();\n            }\n\n            shared.flushCalls(state.resumeQueue);\n            sendEvent(this, 'onResume', getFinishedResult(this, checkFinished(this, this.animation.to)), this);\n          }\n        },\n        start: this._merge.bind(this, range)\n      }\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n\n      return result;\n    });\n  }\n\n  _merge(range, props, resolve) {\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n\n    const hasToProp = !shared.is.und(range.to);\n    const hasFromProp = !shared.is.und(range.from);\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n\n    const {\n      key,\n      defaultProps,\n      animation: anim\n    } = this;\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim;\n    let {\n      to = prevTo,\n      from = prevFrom\n    } = range;\n\n    if (hasFromProp && !hasToProp && (!props.default || shared.is.und(to))) {\n      to = from;\n    }\n\n    if (props.reverse) [to, from] = [from, to];\n    const hasFromChanged = !shared.isEqual(from, prevFrom);\n\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n\n    from = shared.getFluidValue(from);\n    const hasToChanged = !shared.isEqual(to, prevTo);\n\n    if (hasToChanged) {\n      this._focus(to);\n    }\n\n    const hasAsyncTo = isAsyncTo(props.to);\n    const {\n      config\n    } = anim;\n    const {\n      decay,\n      velocity\n    } = config;\n\n    if (hasToProp || hasFromProp) {\n      config.velocity = 0;\n    }\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    }\n\n    let node = animated$1.getAnimated(this);\n\n    if (!node || shared.is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n\n    const reset = shared.is.und(props.reset) ? hasFromProp && !props.default : !shared.is.und(from) && matchProp(props.reset, key);\n    const value = reset ? from : this.get();\n    const goal = computeGoal(to);\n    const isAnimatable = shared.is.num(goal) || shared.is.arr(goal) || shared.isAnimatedString(goal);\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n    if (hasToChanged) {\n      const nodeType = animated$1.getAnimatedType(to);\n\n      if (nodeType !== node.constructor) {\n        if (immediate) {\n          node = this._set(goal);\n        } else throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the \"to\" prop suggests`);\n      }\n    }\n\n    const goalType = node.constructor;\n    let started = shared.hasFluidValue(to);\n    let finished = false;\n\n    if (!started) {\n      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;\n\n      if (hasToChanged || hasValueChanged) {\n        finished = shared.isEqual(computeGoal(value), goal);\n        started = !finished;\n      }\n\n      if (!shared.isEqual(anim.immediate, immediate) && !immediate || !shared.isEqual(config.decay, decay) || !shared.isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    }\n\n    if (finished && isAnimating(this)) {\n      if (anim.changed && !reset) {\n        started = true;\n      } else if (!started) {\n        this._stop(prevTo);\n      }\n    }\n\n    if (!hasAsyncTo) {\n      if (started || shared.hasFluidValue(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = shared.hasFluidValue(to) ? null : goalType == animated$1.AnimatedString ? [1] : shared.toArray(goal);\n      }\n\n      if (anim.immediate != immediate) {\n        anim.immediate = immediate;\n\n        if (!immediate && !reset) {\n          this._set(prevTo);\n        }\n      }\n\n      if (started) {\n        const {\n          onRest\n        } = anim;\n        shared.each(ACTIVE_EVENTS, type => mergeActiveFn(this, props, type));\n        const result = getFinishedResult(this, checkFinished(this, prevTo));\n        shared.flushCalls(this._pendingCalls, result);\n\n        this._pendingCalls.add(resolve);\n\n        if (anim.changed) shared.raf.batchedUpdates(() => {\n          anim.changed = !reset;\n          onRest == null ? void 0 : onRest(result, this);\n\n          if (reset) {\n            callProp(defaultProps.onRest, result);\n          } else {\n            anim.onStart == null ? void 0 : anim.onStart(result, this);\n          }\n        });\n      }\n    }\n\n    if (reset) {\n      this._set(value);\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } else if (started) {\n      this._start();\n    } else if (isAnimating(this) && !hasToChanged) {\n      this._pendingCalls.add(resolve);\n    } else {\n      resolve(getNoopResult(value));\n    }\n  }\n\n  _focus(value) {\n    const anim = this.animation;\n\n    if (value !== anim.to) {\n      if (shared.getFluidObservers(this)) {\n        this._detach();\n      }\n\n      anim.to = value;\n\n      if (shared.getFluidObservers(this)) {\n        this._attach();\n      }\n    }\n  }\n\n  _attach() {\n    let priority = 0;\n    const {\n      to\n    } = this.animation;\n\n    if (shared.hasFluidValue(to)) {\n      shared.addFluidObserver(to, this);\n\n      if (isFrameValue(to)) {\n        priority = to.priority + 1;\n      }\n    }\n\n    this.priority = priority;\n  }\n\n  _detach() {\n    const {\n      to\n    } = this.animation;\n\n    if (shared.hasFluidValue(to)) {\n      shared.removeFluidObserver(to, this);\n    }\n  }\n\n  _set(arg, idle = true) {\n    const value = shared.getFluidValue(arg);\n\n    if (!shared.is.und(value)) {\n      const oldNode = animated$1.getAnimated(this);\n\n      if (!oldNode || !shared.isEqual(value, oldNode.getValue())) {\n        const nodeType = animated$1.getAnimatedType(value);\n\n        if (!oldNode || oldNode.constructor != nodeType) {\n          animated$1.setAnimated(this, nodeType.create(value));\n        } else {\n          oldNode.setValue(value);\n        }\n\n        if (oldNode) {\n          shared.raf.batchedUpdates(() => {\n            this._onChange(value, idle);\n          });\n        }\n      }\n    }\n\n    return animated$1.getAnimated(this);\n  }\n\n  _onStart() {\n    const anim = this.animation;\n\n    if (!anim.changed) {\n      anim.changed = true;\n      sendEvent(this, 'onStart', getFinishedResult(this, checkFinished(this, anim.to)), this);\n    }\n  }\n\n  _onChange(value, idle) {\n    if (!idle) {\n      this._onStart();\n\n      callProp(this.animation.onChange, value, this);\n    }\n\n    callProp(this.defaultProps.onChange, value, this);\n\n    super._onChange(value, idle);\n  }\n\n  _start() {\n    const anim = this.animation;\n    animated$1.getAnimated(this).reset(shared.getFluidValue(anim.to));\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n\n    if (!isAnimating(this)) {\n      setActiveBit(this, true);\n\n      if (!isPaused(this)) {\n        this._resume();\n      }\n    }\n  }\n\n  _resume() {\n    if (shared.Globals.skipAnimation) {\n      this.finish();\n    } else {\n      shared.frameLoop.start(this);\n    }\n  }\n\n  _stop(goal, cancel) {\n    if (isAnimating(this)) {\n      setActiveBit(this, false);\n      const anim = this.animation;\n      shared.each(anim.values, node => {\n        node.done = true;\n      });\n\n      if (anim.toValues) {\n        anim.onChange = anim.onPause = anim.onResume = undefined;\n      }\n\n      shared.callFluidObservers(this, {\n        type: 'idle',\n        parent: this\n      });\n      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));\n      shared.flushCalls(this._pendingCalls, result);\n\n      if (anim.changed) {\n        anim.changed = false;\n        sendEvent(this, 'onRest', result, this);\n      }\n    }\n  }\n\n}\n\nfunction checkFinished(target, to) {\n  const goal = computeGoal(to);\n  const value = computeGoal(target.get());\n  return shared.isEqual(value, goal);\n}\n\nfunction createLoopUpdate(props, loop = props.loop, to = props.to) {\n  let loopRet = callProp(loop);\n\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate(_extends({}, props, {\n      loop,\n      default: false,\n      pause: undefined,\n      to: !reverse || isAsyncTo(to) ? to : undefined,\n      from: reset ? props.from : undefined,\n      reset\n    }, overrides));\n  }\n}\nfunction createUpdate(props) {\n  const {\n    to,\n    from\n  } = props = inferTo(props);\n  const keys = new Set();\n  if (shared.is.obj(to)) findDefined(to, keys);\n  if (shared.is.obj(from)) findDefined(from, keys);\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\nfunction declareUpdate(props) {\n  const update = createUpdate(props);\n\n  if (shared.is.und(update.default)) {\n    update.default = getDefaultProps(update);\n  }\n\n  return update;\n}\n\nfunction findDefined(values, keys) {\n  shared.eachProp(values, (value, key) => value != null && keys.add(key));\n}\n\nconst ACTIVE_EVENTS = ['onStart', 'onRest', 'onChange', 'onPause', 'onResume'];\n\nfunction mergeActiveFn(target, props, type) {\n  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : undefined;\n}\n\nfunction sendEvent(target, type, ...args) {\n  var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;\n\n  (_target$animation$typ = (_target$animation = target.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);\n  (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);\n}\n\nconst BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'];\nlet nextId = 1;\nclass Controller {\n  constructor(props, flush) {\n    this.id = nextId++;\n    this.springs = {};\n    this.queue = [];\n    this.ref = void 0;\n    this._flush = void 0;\n    this._initialProps = void 0;\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._changed = new Set();\n    this._started = false;\n    this._item = void 0;\n    this._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._events = {\n      onStart: new Map(),\n      onChange: new Map(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush) {\n      this._flush = flush;\n    }\n\n    if (props) {\n      this.start(_extends({\n        default: true\n      }, props));\n    }\n  }\n\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every(spring => {\n      return spring.idle && !spring.isDelayed && !spring.isPaused;\n    });\n  }\n\n  get item() {\n    return this._item;\n  }\n\n  set item(item) {\n    this._item = item;\n  }\n\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n\n  set(values) {\n    for (const key in values) {\n      const value = values[key];\n\n      if (!shared.is.und(value)) {\n        this.springs[key].set(value);\n      }\n    }\n  }\n\n  update(props) {\n    if (props) {\n      this.queue.push(createUpdate(props));\n    }\n\n    return this;\n  }\n\n  start(props) {\n    let {\n      queue\n    } = this;\n\n    if (props) {\n      queue = shared.toArray(props).map(createUpdate);\n    } else {\n      this.queue = [];\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n\n  stop(arg, keys) {\n    if (arg !== !!arg) {\n      keys = arg;\n    }\n\n    if (keys) {\n      const springs = this.springs;\n      shared.each(shared.toArray(keys), key => springs[key].stop(!!arg));\n    } else {\n      stopAsync(this._state, this._lastAsyncId);\n      this.each(spring => spring.stop(!!arg));\n    }\n\n    return this;\n  }\n\n  pause(keys) {\n    if (shared.is.und(keys)) {\n      this.start({\n        pause: true\n      });\n    } else {\n      const springs = this.springs;\n      shared.each(shared.toArray(keys), key => springs[key].pause());\n    }\n\n    return this;\n  }\n\n  resume(keys) {\n    if (shared.is.und(keys)) {\n      this.start({\n        pause: false\n      });\n    } else {\n      const springs = this.springs;\n      shared.each(shared.toArray(keys), key => springs[key].resume());\n    }\n\n    return this;\n  }\n\n  each(iterator) {\n    shared.eachProp(this.springs, iterator);\n  }\n\n  _onFrame() {\n    const {\n      onStart,\n      onChange,\n      onRest\n    } = this._events;\n    const active = this._active.size > 0;\n    const changed = this._changed.size > 0;\n\n    if (active && !this._started || changed && !this._started) {\n      this._started = true;\n      shared.flush(onStart, ([onStart, result]) => {\n        result.value = this.get();\n        onStart(result, this, this._item);\n      });\n    }\n\n    const idle = !active && this._started;\n    const values = changed || idle && onRest.size ? this.get() : null;\n\n    if (changed && onChange.size) {\n      shared.flush(onChange, ([onChange, result]) => {\n        result.value = values;\n        onChange(result, this, this._item);\n      });\n    }\n\n    if (idle) {\n      this._started = false;\n      shared.flush(onRest, ([onRest, result]) => {\n        result.value = values;\n        onRest(result, this, this._item);\n      });\n    }\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      this._changed.add(event.parent);\n\n      if (!event.idle) {\n        this._active.add(event.parent);\n      }\n    } else if (event.type == 'idle') {\n      this._active.delete(event.parent);\n    } else return;\n\n    shared.raf.onFrame(this._onFrame);\n  }\n\n}\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(props => flushUpdate(ctrl, props))).then(results => getCombinedResult(ctrl, results));\n}\nasync function flushUpdate(ctrl, props, isLoop) {\n  const {\n    keys,\n    to,\n    from,\n    loop,\n    onRest,\n    onResolve\n  } = props;\n  const defaults = shared.is.obj(props.default) && props.default;\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  if (to === false) props.to = null;\n  if (from === false) props.from = null;\n  const asyncTo = shared.is.arr(to) || shared.is.fun(to) ? to : undefined;\n\n  if (asyncTo) {\n    props.to = undefined;\n    props.onRest = undefined;\n\n    if (defaults) {\n      defaults.onRest = undefined;\n    }\n  } else {\n    shared.each(BATCHED_EVENTS, key => {\n      const handler = props[key];\n\n      if (shared.is.fun(handler)) {\n        const queue = ctrl['_events'][key];\n\n        props[key] = ({\n          finished,\n          cancelled\n        }) => {\n          const result = queue.get(handler);\n\n          if (result) {\n            if (!finished) result.finished = false;\n            if (cancelled) result.cancelled = true;\n          } else {\n            queue.set(handler, {\n              value: null,\n              finished: finished || false,\n              cancelled: cancelled || false\n            });\n          }\n        };\n\n        if (defaults) {\n          defaults[key] = props[key];\n        }\n      }\n    });\n  }\n\n  const state = ctrl['_state'];\n\n  if (props.pause === !state.paused) {\n    state.paused = props.pause;\n    shared.flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);\n  } else if (state.paused) {\n    props.pause = true;\n  }\n\n  const promises = (keys || Object.keys(ctrl.springs)).map(key => ctrl.springs[key].start(props));\n  const cancel = props.cancel === true || getDefaultProp(props, 'cancel') === true;\n\n  if (asyncTo || cancel && state.asyncId) {\n    promises.push(scheduleProps(++ctrl['_lastAsyncId'], {\n      props,\n      state,\n      actions: {\n        pause: shared.noop,\n        resume: shared.noop,\n\n        start(props, resolve) {\n          if (cancel) {\n            stopAsync(state, ctrl['_lastAsyncId']);\n            resolve(getCancelledResult(ctrl));\n          } else {\n            props.onRest = onRest;\n            resolve(runAsync(asyncTo, props, state, ctrl));\n          }\n        }\n\n      }\n    }));\n  }\n\n  if (state.paused) {\n    await new Promise(resume => {\n      state.resumeQueue.add(resume);\n    });\n  }\n\n  const result = getCombinedResult(ctrl, await Promise.all(promises));\n\n  if (loop && result.finished && !(isLoop && result.noop)) {\n    const nextProps = createLoopUpdate(props, loop, to);\n\n    if (nextProps) {\n      prepareKeys(ctrl, [nextProps]);\n      return flushUpdate(ctrl, nextProps, true);\n    }\n  }\n\n  if (onResolve) {\n    shared.raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));\n  }\n\n  return result;\n}\nfunction getSprings(ctrl, props) {\n  const springs = _extends({}, ctrl.springs);\n\n  if (props) {\n    shared.each(shared.toArray(props), props => {\n      if (shared.is.und(props.keys)) {\n        props = createUpdate(props);\n      }\n\n      if (!shared.is.obj(props.to)) {\n        props = _extends({}, props, {\n          to: undefined\n        });\n      }\n\n      prepareSprings(springs, props, key => {\n        return createSpring(key);\n      });\n    });\n  }\n\n  setSprings(ctrl, springs);\n  return springs;\n}\nfunction setSprings(ctrl, springs) {\n  shared.eachProp(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      shared.addFluidObserver(spring, ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    shared.addFluidObserver(spring, observer);\n  }\n\n  return spring;\n}\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    shared.each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring['_prepareNode'](props);\n    });\n  }\n}\n\nfunction prepareKeys(ctrl, queue) {\n  shared.each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nconst _excluded$6 = [\"children\"];\nconst SpringContext = _ref => {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded$6);\n\n  const inherited = React.useContext(ctx);\n  const pause = props.pause || !!inherited.pause,\n        immediate = props.immediate || !!inherited.immediate;\n  props = shared.useMemoOne(() => ({\n    pause,\n    immediate\n  }), [pause, immediate]);\n  const {\n    Provider\n  } = ctx;\n  return React__namespace.createElement(Provider, {\n    value: props\n  }, children);\n};\nconst ctx = makeContext(SpringContext, {});\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n\nfunction makeContext(target, init) {\n  Object.assign(target, React__namespace.createContext(init));\n  target.Provider._context = target;\n  target.Consumer._context = target;\n  return target;\n}\n\nconst SpringRef = () => {\n  const current = [];\n\n  const SpringRef = function SpringRef(props) {\n    shared.deprecateDirectCall();\n    const results = [];\n    shared.each(current, (ctrl, i) => {\n      if (shared.is.und(props)) {\n        results.push(ctrl.start());\n      } else {\n        const update = _getProps(props, ctrl, i);\n\n        if (update) {\n          results.push(ctrl.start(update));\n        }\n      }\n    });\n    return results;\n  };\n\n  SpringRef.current = current;\n\n  SpringRef.add = function (ctrl) {\n    if (!current.includes(ctrl)) {\n      current.push(ctrl);\n    }\n  };\n\n  SpringRef.delete = function (ctrl) {\n    const i = current.indexOf(ctrl);\n    if (~i) current.splice(i, 1);\n  };\n\n  SpringRef.pause = function () {\n    shared.each(current, ctrl => ctrl.pause(...arguments));\n    return this;\n  };\n\n  SpringRef.resume = function () {\n    shared.each(current, ctrl => ctrl.resume(...arguments));\n    return this;\n  };\n\n  SpringRef.set = function (values) {\n    shared.each(current, ctrl => ctrl.set(values));\n  };\n\n  SpringRef.start = function (props) {\n    const results = [];\n    shared.each(current, (ctrl, i) => {\n      if (shared.is.und(props)) {\n        results.push(ctrl.start());\n      } else {\n        const update = this._getProps(props, ctrl, i);\n\n        if (update) {\n          results.push(ctrl.start(update));\n        }\n      }\n    });\n    return results;\n  };\n\n  SpringRef.stop = function () {\n    shared.each(current, ctrl => ctrl.stop(...arguments));\n    return this;\n  };\n\n  SpringRef.update = function (props) {\n    shared.each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));\n    return this;\n  };\n\n  const _getProps = function _getProps(arg, ctrl, index) {\n    return shared.is.fun(arg) ? arg(index, ctrl) : arg;\n  };\n\n  SpringRef._getProps = _getProps;\n  return SpringRef;\n};\n\nfunction useSprings(length, props, deps) {\n  const propsFn = shared.is.fun(props) && props;\n  if (propsFn && !deps) deps = [];\n  const ref = React.useMemo(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);\n  const layoutId = React.useRef(0);\n  const forceUpdate = shared.useForceUpdate();\n  const state = React.useMemo(() => ({\n    ctrls: [],\n    queue: [],\n\n    flush(ctrl, updates) {\n      const springs = getSprings(ctrl, updates);\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs).some(key => !ctrl.springs[key]);\n      return canFlushSync ? flushUpdateQueue(ctrl, updates) : new Promise(resolve => {\n        setSprings(ctrl, springs);\n        state.queue.push(() => {\n          resolve(flushUpdateQueue(ctrl, updates));\n        });\n        forceUpdate();\n      });\n    }\n\n  }), []);\n  const ctrls = React.useRef([...state.ctrls]);\n  const updates = [];\n  const prevLength = shared.usePrev(length) || 0;\n  React.useMemo(() => {\n    shared.each(ctrls.current.slice(length, prevLength), ctrl => {\n      detachRefs(ctrl, ref);\n      ctrl.stop(true);\n    });\n    ctrls.current.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]);\n  React.useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        updates[i] = declareUpdate(update);\n      }\n    }\n  }\n\n  const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = React.useContext(SpringContext);\n  const prevContext = shared.usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  shared.useIsomorphicLayoutEffect(() => {\n    layoutId.current++;\n    state.ctrls = ctrls.current;\n    const {\n      queue\n    } = state;\n\n    if (queue.length) {\n      state.queue = [];\n      shared.each(queue, cb => cb());\n    }\n\n    shared.each(ctrls.current, (ctrl, i) => {\n      ref == null ? void 0 : ref.add(ctrl);\n\n      if (hasContext) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      const update = updates[i];\n\n      if (update) {\n        replaceRef(ctrl, update.ref);\n\n        if (ctrl.ref) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  });\n  shared.useOnce(() => () => {\n    shared.each(state.ctrls, ctrl => ctrl.stop(true));\n  });\n  const values = springs.map(x => _extends({}, x));\n  return ref ? [values, ref] : values;\n}\n\nfunction useSpring(props, deps) {\n  const isFn = shared.is.fun(props);\n  const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\n  return isFn || arguments.length == 2 ? [values, ref] : values;\n}\n\nconst initSpringRef = () => SpringRef();\n\nconst useSpringRef = () => React.useState(initSpringRef)[0];\n\nconst useSpringValue = (initial, props) => {\n  const springValue = shared.useConstant(() => new SpringValue(initial, props));\n  shared.useOnce(() => () => {\n    springValue.stop();\n  });\n  return springValue;\n};\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = shared.is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  let reverse = true;\n  let passedRef = undefined;\n  const result = useSprings(length, (i, ctrl) => {\n    const props = propsFn ? propsFn(i, ctrl) : propsArg;\n    passedRef = props.ref;\n    reverse = reverse && props.reverse;\n    return props;\n  }, deps || [{}]);\n  shared.useIsomorphicLayoutEffect(() => {\n    shared.each(result[1].current, (ctrl, i) => {\n      const parent = result[1].current[i + (reverse ? 1 : -1)];\n      replaceRef(ctrl, passedRef);\n\n      if (ctrl.ref) {\n        if (parent) {\n          ctrl.update({\n            to: parent.springs\n          });\n        }\n\n        return;\n      }\n\n      if (parent) {\n        ctrl.start({\n          to: parent.springs\n        });\n      } else {\n        ctrl.start();\n      }\n    });\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    var _passedRef;\n\n    const ref = (_passedRef = passedRef) != null ? _passedRef : result[1];\n\n    ref['_getProps'] = (propsArg, ctrl, i) => {\n      const props = shared.is.fun(propsArg) ? propsArg(i, ctrl) : propsArg;\n\n      if (props) {\n        const parent = ref.current[i + (props.reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      }\n    };\n\n    return result;\n  }\n\n  return result[0];\n}\n\nlet TransitionPhase;\n\n(function (TransitionPhase) {\n  TransitionPhase[\"MOUNT\"] = \"mount\";\n  TransitionPhase[\"ENTER\"] = \"enter\";\n  TransitionPhase[\"UPDATE\"] = \"update\";\n  TransitionPhase[\"LEAVE\"] = \"leave\";\n})(TransitionPhase || (TransitionPhase = {}));\n\nfunction useTransition(data, props, deps) {\n  const propsFn = shared.is.fun(props) && props;\n  const {\n    reset,\n    sort,\n    trail = 0,\n    expires = true,\n    exitBeforeEnter = false,\n    onDestroyed,\n    ref: propsRef,\n    config: propsConfig\n  } = propsFn ? propsFn() : props;\n  const ref = React.useMemo(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);\n  const items = shared.toArray(data);\n  const transitions = [];\n  const usedTransitions = React.useRef(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  shared.useIsomorphicLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  });\n  shared.useOnce(() => {\n    shared.each(transitions, t => {\n      ref == null ? void 0 : ref.add(t.ctrl);\n      t.ctrl.ref = ref;\n    });\n    return () => {\n      shared.each(usedTransitions.current, t => {\n        if (t.expired) {\n          clearTimeout(t.expirationId);\n        }\n\n        detachRefs(t.ctrl, ref);\n        t.ctrl.stop(true);\n      });\n    };\n  });\n  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);\n  const expired = reset && usedTransitions.current || [];\n  shared.useIsomorphicLayoutEffect(() => shared.each(expired, ({\n    ctrl,\n    item,\n    key\n  }) => {\n    detachRefs(ctrl, ref);\n    callProp(onDestroyed, item, key);\n  }));\n  const reused = [];\n  if (prevTransitions) shared.each(prevTransitions, (t, i) => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n      expired.push(t);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  });\n  shared.each(items, (item, i) => {\n    if (!transitions[i]) {\n      transitions[i] = {\n        key: keys[i],\n        item,\n        phase: TransitionPhase.MOUNT,\n        ctrl: new Controller()\n      };\n      transitions[i].ctrl.item = item;\n    }\n  });\n\n  if (reused.length) {\n    let i = -1;\n    const {\n      leave\n    } = propsFn ? propsFn() : props;\n    shared.each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends({}, t, {\n          item: items[keyIndex]\n        });\n      } else if (leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (shared.is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  }\n\n  let delay = -trail;\n  const forceUpdate = shared.useForceUpdate();\n  const defaultProps = getDefaultProps(props);\n  const changes = new Map();\n  const exitingTransitions = React.useRef(new Map());\n  const forceChange = React.useRef(false);\n  shared.each(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    const p = propsFn ? propsFn() : props;\n    let to;\n    let phase;\n    let propsDelay = callProp(p.delay || 0, key);\n\n    if (prevPhase == TransitionPhase.MOUNT) {\n      to = p.enter;\n      phase = TransitionPhase.ENTER;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != TransitionPhase.LEAVE) {\n        if (isLeave) {\n          to = p.leave;\n          phase = TransitionPhase.LEAVE;\n        } else if (to = p.update) {\n          phase = TransitionPhase.UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = p.enter;\n        phase = TransitionPhase.ENTER;\n      } else return;\n    }\n\n    to = callProp(to, t.item, i);\n    to = shared.is.obj(to) ? inferTo(to) : {\n      to\n    };\n\n    if (!to.config) {\n      const config = propsConfig || defaultProps.config;\n      to.config = callProp(config, t.item, i, phase);\n    }\n\n    delay += trail;\n\n    const payload = _extends({}, defaultProps, {\n      delay: propsDelay + delay,\n      ref: propsRef,\n      immediate: p.immediate,\n      reset: false\n    }, to);\n\n    if (phase == TransitionPhase.ENTER && shared.is.und(payload.from)) {\n      const _p = propsFn ? propsFn() : props;\n\n      const from = shared.is.und(_p.initial) || prevTransitions ? _p.from : _p.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    const {\n      onResolve\n    } = payload;\n\n    payload.onResolve = result => {\n      callProp(onResolve, result);\n      const transitions = usedTransitions.current;\n      const t = transitions.find(t => t.key === key);\n      if (!t) return;\n\n      if (result.cancelled && t.phase != TransitionPhase.UPDATE) {\n        return;\n      }\n\n      if (t.ctrl.idle) {\n        const idle = transitions.every(t => t.ctrl.idle);\n\n        if (t.phase == TransitionPhase.LEAVE) {\n          const expiry = callProp(expires, t.item);\n\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t.expired = true;\n\n            if (!idle && expiryMs > 0) {\n              if (expiryMs <= 0x7fffffff) t.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        }\n\n        if (idle && transitions.some(t => t.expired)) {\n          exitingTransitions.current.delete(t);\n\n          if (exitBeforeEnter) {\n            forceChange.current = true;\n          }\n\n          forceUpdate();\n        }\n      }\n    };\n\n    const springs = getSprings(t.ctrl, payload);\n\n    if (phase === TransitionPhase.LEAVE && exitBeforeEnter) {\n      exitingTransitions.current.set(t, {\n        phase,\n        springs,\n        payload\n      });\n    } else {\n      changes.set(t, {\n        phase,\n        springs,\n        payload\n      });\n    }\n  });\n  const context = React.useContext(SpringContext);\n  const prevContext = shared.usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  shared.useIsomorphicLayoutEffect(() => {\n    if (hasContext) {\n      shared.each(transitions, t => {\n        t.ctrl.start({\n          default: context\n        });\n      });\n    }\n  }, [context]);\n  shared.each(changes, (_, t) => {\n    if (exitingTransitions.current.size) {\n      const ind = transitions.findIndex(state => state.key === t.key);\n      transitions.splice(ind, 1);\n    }\n  });\n  shared.useIsomorphicLayoutEffect(() => {\n    shared.each(exitingTransitions.current.size ? exitingTransitions.current : changes, ({\n      phase,\n      payload\n    }, t) => {\n      const {\n        ctrl\n      } = t;\n      t.phase = phase;\n      ref == null ? void 0 : ref.add(ctrl);\n\n      if (hasContext && phase == TransitionPhase.ENTER) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      if (payload) {\n        replaceRef(ctrl, payload.ref);\n\n        if ((ctrl.ref || ref) && !forceChange.current) {\n          ctrl.update(payload);\n        } else {\n          ctrl.start(payload);\n\n          if (forceChange.current) {\n            forceChange.current = false;\n          }\n        }\n      }\n    });\n  }, reset ? void 0 : deps);\n\n  const renderTransitions = render => React__namespace.createElement(React__namespace.Fragment, null, transitions.map((t, i) => {\n    const {\n      springs\n    } = changes.get(t) || t.ctrl;\n    const elem = render(_extends({}, springs), t.item, t, i);\n    return elem && elem.type ? React__namespace.createElement(elem.type, _extends({}, elem.props, {\n      key: shared.is.str(t.key) || shared.is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  }));\n\n  return ref ? [renderTransitions, ref] : renderTransitions;\n}\nlet nextKey = 1;\n\nfunction getKeys(items, {\n  key,\n  keys = key\n}, prevTransitions) {\n  if (keys === null) {\n    const reused = new Set();\n    return items.map(item => {\n      const t = prevTransitions && prevTransitions.find(t => t.item === item && t.phase !== TransitionPhase.LEAVE && !reused.has(t));\n\n      if (t) {\n        reused.add(t);\n        return t.key;\n      }\n\n      return nextKey++;\n    });\n  }\n\n  return shared.is.und(keys) ? items : shared.is.fun(keys) ? items.map(keys) : shared.toArray(keys);\n}\n\nconst _excluded$5 = [\"container\"];\nconst useScroll = (_ref = {}) => {\n  let {\n    container\n  } = _ref,\n      springOptions = _objectWithoutPropertiesLoose(_ref, _excluded$5);\n\n  const [scrollValues, api] = useSpring(() => _extends({\n    scrollX: 0,\n    scrollY: 0,\n    scrollXProgress: 0,\n    scrollYProgress: 0\n  }, springOptions), []);\n  shared.useIsomorphicLayoutEffect(() => {\n    const cleanupScroll = shared.onScroll(({\n      x,\n      y\n    }) => {\n      api.start({\n        scrollX: x.current,\n        scrollXProgress: x.progress,\n        scrollY: y.current,\n        scrollYProgress: y.progress\n      });\n    }, {\n      container: (container == null ? void 0 : container.current) || undefined\n    });\n    return () => {\n      shared.each(Object.values(scrollValues), value => value.stop());\n      cleanupScroll();\n    };\n  }, []);\n  return scrollValues;\n};\n\nconst _excluded$4 = [\"container\"];\nconst useResize = _ref => {\n  let {\n    container\n  } = _ref,\n      springOptions = _objectWithoutPropertiesLoose(_ref, _excluded$4);\n\n  const [sizeValues, api] = useSpring(() => _extends({\n    width: 0,\n    height: 0\n  }, springOptions), []);\n  shared.useIsomorphicLayoutEffect(() => {\n    const cleanupScroll = shared.onResize(({\n      width,\n      height\n    }) => {\n      api.start({\n        width,\n        height,\n        immediate: sizeValues.width.get() === 0 || sizeValues.height.get() === 0\n      });\n    }, {\n      container: (container == null ? void 0 : container.current) || undefined\n    });\n    return () => {\n      shared.each(Object.values(sizeValues), value => value.stop());\n      cleanupScroll();\n    };\n  }, []);\n  return sizeValues;\n};\n\nconst _excluded$3 = [\"to\", \"from\"],\n      _excluded2 = [\"root\", \"once\", \"amount\"];\nconst defaultThresholdOptions = {\n  any: 0,\n  all: 1\n};\nfunction useInView(props, args) {\n  const [isInView, setIsInView] = React.useState(false);\n  const ref = React.useRef();\n  const propsFn = shared.is.fun(props) && props;\n  const springsProps = propsFn ? propsFn() : {};\n\n  const {\n    to = {},\n    from = {}\n  } = springsProps,\n        restSpringProps = _objectWithoutPropertiesLoose(springsProps, _excluded$3);\n\n  const intersectionArguments = propsFn ? args : props;\n  const [springs, api] = useSpring(() => _extends({\n    from\n  }, restSpringProps), []);\n  shared.useIsomorphicLayoutEffect(() => {\n    const element = ref.current;\n\n    const _ref = intersectionArguments != null ? intersectionArguments : {},\n          {\n      root,\n      once,\n      amount = 'any'\n    } = _ref,\n          restArgs = _objectWithoutPropertiesLoose(_ref, _excluded2);\n\n    if (!element || once && isInView || typeof IntersectionObserver === 'undefined') return;\n    const activeIntersections = new WeakMap();\n\n    const onEnter = () => {\n      if (to) {\n        api.start(to);\n      }\n\n      setIsInView(true);\n\n      const cleanup = () => {\n        if (from) {\n          api.start(from);\n        }\n\n        setIsInView(false);\n      };\n\n      return once ? undefined : cleanup;\n    };\n\n    const handleIntersection = entries => {\n      entries.forEach(entry => {\n        const onLeave = activeIntersections.get(entry.target);\n\n        if (entry.isIntersecting === Boolean(onLeave)) {\n          return;\n        }\n\n        if (entry.isIntersecting) {\n          const newOnLeave = onEnter();\n\n          if (shared.is.fun(newOnLeave)) {\n            activeIntersections.set(entry.target, newOnLeave);\n          } else {\n            observer.unobserve(entry.target);\n          }\n        } else if (onLeave) {\n          onLeave();\n          activeIntersections.delete(entry.target);\n        }\n      });\n    };\n\n    const observer = new IntersectionObserver(handleIntersection, _extends({\n      root: root && root.current || undefined,\n      threshold: typeof amount === 'number' || Array.isArray(amount) ? amount : defaultThresholdOptions[amount]\n    }, restArgs));\n    observer.observe(element);\n    return () => observer.unobserve(element);\n  }, [intersectionArguments]);\n\n  if (propsFn) {\n    return [ref, springs];\n  }\n\n  return [ref, isInView];\n}\n\nconst _excluded$2 = [\"children\"];\nfunction Spring(_ref) {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded$2);\n\n  return children(useSpring(props));\n}\n\nconst _excluded$1 = [\"items\", \"children\"];\nfunction Trail(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return shared.is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nconst _excluded = [\"items\", \"children\"];\nfunction Transition(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  return useTransition(items, props)(children);\n}\n\nclass Interpolation extends FrameValue {\n  constructor(source, args) {\n    super();\n    this.key = void 0;\n    this.idle = true;\n    this.calc = void 0;\n    this._active = new Set();\n    this.source = source;\n    this.calc = shared.createInterpolator(...args);\n\n    const value = this._get();\n\n    const nodeType = animated$1.getAnimatedType(value);\n    animated$1.setAnimated(this, nodeType.create(value));\n  }\n\n  advance(_dt) {\n    const value = this._get();\n\n    const oldValue = this.get();\n\n    if (!shared.isEqual(value, oldValue)) {\n      animated$1.getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n\n    if (!this.idle && checkIdle(this._active)) {\n      becomeIdle(this);\n    }\n  }\n\n  _get() {\n    const inputs = shared.is.arr(this.source) ? this.source.map(shared.getFluidValue) : shared.toArray(shared.getFluidValue(this.source));\n    return this.calc(...inputs);\n  }\n\n  _start() {\n    if (this.idle && !checkIdle(this._active)) {\n      this.idle = false;\n      shared.each(animated$1.getPayload(this), node => {\n        node.done = false;\n      });\n\n      if (shared.Globals.skipAnimation) {\n        shared.raf.batchedUpdates(() => this.advance());\n        becomeIdle(this);\n      } else {\n        shared.frameLoop.start(this);\n      }\n    }\n  }\n\n  _attach() {\n    let priority = 1;\n    shared.each(shared.toArray(this.source), source => {\n      if (shared.hasFluidValue(source)) {\n        shared.addFluidObserver(source, this);\n      }\n\n      if (isFrameValue(source)) {\n        if (!source.idle) {\n          this._active.add(source);\n        }\n\n        priority = Math.max(priority, source.priority + 1);\n      }\n    });\n    this.priority = priority;\n\n    this._start();\n  }\n\n  _detach() {\n    shared.each(shared.toArray(this.source), source => {\n      if (shared.hasFluidValue(source)) {\n        shared.removeFluidObserver(source, this);\n      }\n    });\n\n    this._active.clear();\n\n    becomeIdle(this);\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      if (event.idle) {\n        this.advance();\n      } else {\n        this._active.add(event.parent);\n\n        this._start();\n      }\n    } else if (event.type == 'idle') {\n      this._active.delete(event.parent);\n    } else if (event.type == 'priority') {\n      this.priority = shared.toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);\n    }\n  }\n\n}\n\nfunction isIdle(source) {\n  return source.idle !== false;\n}\n\nfunction checkIdle(active) {\n  return !active.size || Array.from(active).every(isIdle);\n}\n\nfunction becomeIdle(self) {\n  if (!self.idle) {\n    self.idle = true;\n    shared.each(animated$1.getPayload(self), node => {\n      node.done = true;\n    });\n    shared.callFluidObservers(self, {\n      type: 'idle',\n      parent: self\n    });\n  }\n}\n\nconst to = (source, ...args) => new Interpolation(source, args);\nconst interpolate = (source, ...args) => (shared.deprecateInterpolate(), new Interpolation(source, args));\n\nshared.Globals.assign({\n  createStringInterpolator: shared.createStringInterpolator,\n  to: (source, args) => new Interpolation(source, args)\n});\nconst update = shared.frameLoop.advance;\n\nObject.defineProperty(exports, \"Globals\", ({\n  enumerable: true,\n  get: function () { return shared.Globals; }\n}));\nObject.defineProperty(exports, \"createInterpolator\", ({\n  enumerable: true,\n  get: function () { return shared.createInterpolator; }\n}));\nObject.defineProperty(exports, \"easings\", ({\n  enumerable: true,\n  get: function () { return shared.easings; }\n}));\nObject.defineProperty(exports, \"useIsomorphicLayoutEffect\", ({\n  enumerable: true,\n  get: function () { return shared.useIsomorphicLayoutEffect; }\n}));\nObject.defineProperty(exports, \"useReducedMotion\", ({\n  enumerable: true,\n  get: function () { return shared.useReducedMotion; }\n}));\nexports.BailSignal = BailSignal;\nexports.Controller = Controller;\nexports.FrameValue = FrameValue;\nexports.Interpolation = Interpolation;\nexports.Spring = Spring;\nexports.SpringContext = SpringContext;\nexports.SpringRef = SpringRef;\nexports.SpringValue = SpringValue;\nexports.Trail = Trail;\nexports.Transition = Transition;\nexports.config = config;\nexports.inferTo = inferTo;\nexports.interpolate = interpolate;\nexports.to = to;\nexports.update = update;\nexports.useChain = useChain;\nexports.useInView = useInView;\nexports.useResize = useResize;\nexports.useScroll = useScroll;\nexports.useSpring = useSpring;\nexports.useSpringRef = useSpringRef;\nexports.useSpringValue = useSpringValue;\nexports.useSprings = useSprings;\nexports.useTrail = useTrail;\nexports.useTransition = useTransition;\nObject.keys(animated).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return animated[k]; }\n  });\n});\nObject.keys(interpolation).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return interpolation[k]; }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9jb3JlL2Rpc3QvcmVhY3Qtc3ByaW5nLWNvcmUuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGFBQWEsbUJBQU8sQ0FBQyx1R0FBc0I7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDZHQUF3QjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsMEZBQThCO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLG9HQUFtQzs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQscUJBQXFCO0FBQzVFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQscUJBQXFCO0FBQzFFO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsY0FBYztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkNBQTJDLHVCQUF1QixNQUFNLGNBQWM7QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsYUFBYTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1DQUFtQztBQUNuQyxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSwyQ0FBMEM7QUFDMUM7QUFDQSxxQkFBcUI7QUFDckIsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUMsRUFBQztBQUNGLDJDQUEwQztBQUMxQztBQUNBLHFCQUFxQjtBQUNyQixDQUFDLEVBQUM7QUFDRiw2REFBNEQ7QUFDNUQ7QUFDQSxxQkFBcUI7QUFDckIsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUMsRUFBQztBQUNGLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsZUFBZTtBQUNmLG1CQUFtQjtBQUNuQixVQUFVO0FBQ1YsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9jb3JlL2Rpc3QvcmVhY3Qtc3ByaW5nLWNvcmUuY2pzLmRldi5qcz82NzdjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHNoYXJlZCA9IHJlcXVpcmUoJ0ByZWFjdC1zcHJpbmcvc2hhcmVkJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGFuaW1hdGVkJDEgPSByZXF1aXJlKCdAcmVhY3Qtc3ByaW5nL2FuaW1hdGVkJyk7XG52YXIgYW5pbWF0ZWQgPSByZXF1aXJlKCdAcmVhY3Qtc3ByaW5nL3R5cGVzL2FuaW1hdGVkJyk7XG52YXIgaW50ZXJwb2xhdGlvbiA9IHJlcXVpcmUoJ0ByZWFjdC1zcHJpbmcvdHlwZXMvaW50ZXJwb2xhdGlvbicpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY2FsbFByb3AodmFsdWUsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHNoYXJlZC5pcy5mdW4odmFsdWUpID8gdmFsdWUoLi4uYXJncykgOiB2YWx1ZTtcbn1cbmNvbnN0IG1hdGNoUHJvcCA9ICh2YWx1ZSwga2V5KSA9PiB2YWx1ZSA9PT0gdHJ1ZSB8fCAhIShrZXkgJiYgdmFsdWUgJiYgKHNoYXJlZC5pcy5mdW4odmFsdWUpID8gdmFsdWUoa2V5KSA6IHNoYXJlZC50b0FycmF5KHZhbHVlKS5pbmNsdWRlcyhrZXkpKSk7XG5jb25zdCByZXNvbHZlUHJvcCA9IChwcm9wLCBrZXkpID0+IHNoYXJlZC5pcy5vYmoocHJvcCkgPyBrZXkgJiYgcHJvcFtrZXldIDogcHJvcDtcbmNvbnN0IGdldERlZmF1bHRQcm9wID0gKHByb3BzLCBrZXkpID0+IHByb3BzLmRlZmF1bHQgPT09IHRydWUgPyBwcm9wc1trZXldIDogcHJvcHMuZGVmYXVsdCA/IHByb3BzLmRlZmF1bHRba2V5XSA6IHVuZGVmaW5lZDtcblxuY29uc3Qgbm9vcFRyYW5zZm9ybSA9IHZhbHVlID0+IHZhbHVlO1xuXG5jb25zdCBnZXREZWZhdWx0UHJvcHMgPSAocHJvcHMsIHRyYW5zZm9ybSA9IG5vb3BUcmFuc2Zvcm0pID0+IHtcbiAgbGV0IGtleXMgPSBERUZBVUxUX1BST1BTO1xuXG4gIGlmIChwcm9wcy5kZWZhdWx0ICYmIHByb3BzLmRlZmF1bHQgIT09IHRydWUpIHtcbiAgICBwcm9wcyA9IHByb3BzLmRlZmF1bHQ7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRzID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gdHJhbnNmb3JtKHByb3BzW2tleV0sIGtleSk7XG5cbiAgICBpZiAoIXNoYXJlZC5pcy51bmQodmFsdWUpKSB7XG4gICAgICBkZWZhdWx0c1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRzO1xufTtcbmNvbnN0IERFRkFVTFRfUFJPUFMgPSBbJ2NvbmZpZycsICdvblByb3BzJywgJ29uU3RhcnQnLCAnb25DaGFuZ2UnLCAnb25QYXVzZScsICdvblJlc3VtZScsICdvblJlc3QnXTtcbmNvbnN0IFJFU0VSVkVEX1BST1BTID0ge1xuICBjb25maWc6IDEsXG4gIGZyb206IDEsXG4gIHRvOiAxLFxuICByZWY6IDEsXG4gIGxvb3A6IDEsXG4gIHJlc2V0OiAxLFxuICBwYXVzZTogMSxcbiAgY2FuY2VsOiAxLFxuICByZXZlcnNlOiAxLFxuICBpbW1lZGlhdGU6IDEsXG4gIGRlZmF1bHQ6IDEsXG4gIGRlbGF5OiAxLFxuICBvblByb3BzOiAxLFxuICBvblN0YXJ0OiAxLFxuICBvbkNoYW5nZTogMSxcbiAgb25QYXVzZTogMSxcbiAgb25SZXN1bWU6IDEsXG4gIG9uUmVzdDogMSxcbiAgb25SZXNvbHZlOiAxLFxuICBpdGVtczogMSxcbiAgdHJhaWw6IDEsXG4gIHNvcnQ6IDEsXG4gIGV4cGlyZXM6IDEsXG4gIGluaXRpYWw6IDEsXG4gIGVudGVyOiAxLFxuICB1cGRhdGU6IDEsXG4gIGxlYXZlOiAxLFxuICBjaGlsZHJlbjogMSxcbiAgb25EZXN0cm95ZWQ6IDEsXG4gIGtleXM6IDEsXG4gIGNhbGxJZDogMSxcbiAgcGFyZW50SWQ6IDFcbn07XG5cbmZ1bmN0aW9uIGdldEZvcndhcmRQcm9wcyhwcm9wcykge1xuICBjb25zdCBmb3J3YXJkID0ge307XG4gIGxldCBjb3VudCA9IDA7XG4gIHNoYXJlZC5lYWNoUHJvcChwcm9wcywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgaWYgKCFSRVNFUlZFRF9QUk9QU1twcm9wXSkge1xuICAgICAgZm9yd2FyZFtwcm9wXSA9IHZhbHVlO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChjb3VudCkge1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZmVyVG8ocHJvcHMpIHtcbiAgY29uc3QgdG8gPSBnZXRGb3J3YXJkUHJvcHMocHJvcHMpO1xuXG4gIGlmICh0bykge1xuICAgIGNvbnN0IG91dCA9IHtcbiAgICAgIHRvXG4gICAgfTtcbiAgICBzaGFyZWQuZWFjaFByb3AocHJvcHMsICh2YWwsIGtleSkgPT4ga2V5IGluIHRvIHx8IChvdXRba2V5XSA9IHZhbCkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVHb2FsKHZhbHVlKSB7XG4gIHZhbHVlID0gc2hhcmVkLmdldEZsdWlkVmFsdWUodmFsdWUpO1xuICByZXR1cm4gc2hhcmVkLmlzLmFycih2YWx1ZSkgPyB2YWx1ZS5tYXAoY29tcHV0ZUdvYWwpIDogc2hhcmVkLmlzQW5pbWF0ZWRTdHJpbmcodmFsdWUpID8gc2hhcmVkLkdsb2JhbHMuY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yKHtcbiAgICByYW5nZTogWzAsIDFdLFxuICAgIG91dHB1dDogW3ZhbHVlLCB2YWx1ZV1cbiAgfSkoMSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3BzKHByb3BzKSB7XG4gIGZvciAoY29uc3QgXyBpbiBwcm9wcykgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNBc3luY1RvKHRvKSB7XG4gIHJldHVybiBzaGFyZWQuaXMuZnVuKHRvKSB8fCBzaGFyZWQuaXMuYXJyKHRvKSAmJiBzaGFyZWQuaXMub2JqKHRvWzBdKTtcbn1cbmZ1bmN0aW9uIGRldGFjaFJlZnMoY3RybCwgcmVmKSB7XG4gIHZhciBfY3RybCRyZWY7XG5cbiAgKF9jdHJsJHJlZiA9IGN0cmwucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2N0cmwkcmVmLmRlbGV0ZShjdHJsKTtcbiAgcmVmID09IG51bGwgPyB2b2lkIDAgOiByZWYuZGVsZXRlKGN0cmwpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVJlZihjdHJsLCByZWYpIHtcbiAgaWYgKHJlZiAmJiBjdHJsLnJlZiAhPT0gcmVmKSB7XG4gICAgdmFyIF9jdHJsJHJlZjI7XG5cbiAgICAoX2N0cmwkcmVmMiA9IGN0cmwucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2N0cmwkcmVmMi5kZWxldGUoY3RybCk7XG4gICAgcmVmLmFkZChjdHJsKTtcbiAgICBjdHJsLnJlZiA9IHJlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDaGFpbihyZWZzLCB0aW1lU3RlcHMsIHRpbWVGcmFtZSA9IDEwMDApIHtcbiAgc2hhcmVkLnVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0aW1lU3RlcHMpIHtcbiAgICAgIGxldCBwcmV2RGVsYXkgPSAwO1xuICAgICAgc2hhcmVkLmVhY2gocmVmcywgKHJlZiwgaSkgPT4ge1xuICAgICAgICBjb25zdCBjb250cm9sbGVycyA9IHJlZi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChjb250cm9sbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgZGVsYXkgPSB0aW1lRnJhbWUgKiB0aW1lU3RlcHNbaV07XG4gICAgICAgICAgaWYgKGlzTmFOKGRlbGF5KSkgZGVsYXkgPSBwcmV2RGVsYXk7ZWxzZSBwcmV2RGVsYXkgPSBkZWxheTtcbiAgICAgICAgICBzaGFyZWQuZWFjaChjb250cm9sbGVycywgY3RybCA9PiB7XG4gICAgICAgICAgICBzaGFyZWQuZWFjaChjdHJsLnF1ZXVlLCBwcm9wcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1lbW9pemVkRGVsYXlQcm9wID0gcHJvcHMuZGVsYXk7XG5cbiAgICAgICAgICAgICAgcHJvcHMuZGVsYXkgPSBrZXkgPT4gZGVsYXkgKyBjYWxsUHJvcChtZW1vaXplZERlbGF5UHJvcCB8fCAwLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVmLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgc2hhcmVkLmVhY2gocmVmcywgcmVmID0+IHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlcnMgPSByZWYuY3VycmVudDtcblxuICAgICAgICBpZiAoY29udHJvbGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgcXVldWVzID0gY29udHJvbGxlcnMubWFwKGN0cmwgPT4ge1xuICAgICAgICAgICAgY29uc3QgcSA9IGN0cmwucXVldWU7XG4gICAgICAgICAgICBjdHJsLnF1ZXVlID0gW107XG4gICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwID0gcC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHNoYXJlZC5lYWNoKGNvbnRyb2xsZXJzLCAoY3RybCwgaSkgPT4gc2hhcmVkLmVhY2gocXVldWVzW2ldIHx8IFtdLCB1cGRhdGUgPT4gY3RybC5xdWV1ZS5wdXNoKHVwZGF0ZSkpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZWYuc3RhcnQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgZGVmYXVsdDoge1xuICAgIHRlbnNpb246IDE3MCxcbiAgICBmcmljdGlvbjogMjZcbiAgfSxcbiAgZ2VudGxlOiB7XG4gICAgdGVuc2lvbjogMTIwLFxuICAgIGZyaWN0aW9uOiAxNFxuICB9LFxuICB3b2JibHk6IHtcbiAgICB0ZW5zaW9uOiAxODAsXG4gICAgZnJpY3Rpb246IDEyXG4gIH0sXG4gIHN0aWZmOiB7XG4gICAgdGVuc2lvbjogMjEwLFxuICAgIGZyaWN0aW9uOiAyMFxuICB9LFxuICBzbG93OiB7XG4gICAgdGVuc2lvbjogMjgwLFxuICAgIGZyaWN0aW9uOiA2MFxuICB9LFxuICBtb2xhc3Nlczoge1xuICAgIHRlbnNpb246IDI4MCxcbiAgICBmcmljdGlvbjogMTIwXG4gIH1cbn07XG5cbmNvbnN0IGRlZmF1bHRzID0gX2V4dGVuZHMoe30sIGNvbmZpZy5kZWZhdWx0LCB7XG4gIG1hc3M6IDEsXG4gIGRhbXBpbmc6IDEsXG4gIGVhc2luZzogc2hhcmVkLmVhc2luZ3MubGluZWFyLFxuICBjbGFtcDogZmFsc2Vcbn0pO1xuXG5jbGFzcyBBbmltYXRpb25Db25maWcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRlbnNpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5mcmljdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmZyZXF1ZW5jeSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhbXBpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXNzID0gdm9pZCAwO1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIHRoaXMucmVzdFZlbG9jaXR5ID0gdm9pZCAwO1xuICAgIHRoaXMucHJlY2lzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMucHJvZ3Jlc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmVhc2luZyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYW1wID0gdm9pZCAwO1xuICAgIHRoaXMuYm91bmNlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjYXkgPSB2b2lkIDA7XG4gICAgdGhpcy5yb3VuZCA9IHZvaWQgMDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRlZmF1bHRzKTtcbiAgfVxuXG59XG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcsIG5ld0NvbmZpZywgZGVmYXVsdENvbmZpZykge1xuICBpZiAoZGVmYXVsdENvbmZpZykge1xuICAgIGRlZmF1bHRDb25maWcgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdENvbmZpZyk7XG4gICAgc2FuaXRpemVDb25maWcoZGVmYXVsdENvbmZpZywgbmV3Q29uZmlnKTtcbiAgICBuZXdDb25maWcgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdENvbmZpZywgbmV3Q29uZmlnKTtcbiAgfVxuXG4gIHNhbml0aXplQ29uZmlnKGNvbmZpZywgbmV3Q29uZmlnKTtcbiAgT2JqZWN0LmFzc2lnbihjb25maWcsIG5ld0NvbmZpZyk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoY29uZmlnW2tleV0gPT0gbnVsbCkge1xuICAgICAgY29uZmlnW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIH1cbiAgfVxuXG4gIGxldCB7XG4gICAgbWFzcyxcbiAgICBmcmVxdWVuY3ksXG4gICAgZGFtcGluZ1xuICB9ID0gY29uZmlnO1xuXG4gIGlmICghc2hhcmVkLmlzLnVuZChmcmVxdWVuY3kpKSB7XG4gICAgaWYgKGZyZXF1ZW5jeSA8IDAuMDEpIGZyZXF1ZW5jeSA9IDAuMDE7XG4gICAgaWYgKGRhbXBpbmcgPCAwKSBkYW1waW5nID0gMDtcbiAgICBjb25maWcudGVuc2lvbiA9IE1hdGgucG93KDIgKiBNYXRoLlBJIC8gZnJlcXVlbmN5LCAyKSAqIG1hc3M7XG4gICAgY29uZmlnLmZyaWN0aW9uID0gNCAqIE1hdGguUEkgKiBkYW1waW5nICogbWFzcyAvIGZyZXF1ZW5jeTtcbiAgfVxuXG4gIHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplQ29uZmlnKGNvbmZpZywgcHJvcHMpIHtcbiAgaWYgKCFzaGFyZWQuaXMudW5kKHByb3BzLmRlY2F5KSkge1xuICAgIGNvbmZpZy5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc1RlbnNpb25Db25maWcgPSAhc2hhcmVkLmlzLnVuZChwcm9wcy50ZW5zaW9uKSB8fCAhc2hhcmVkLmlzLnVuZChwcm9wcy5mcmljdGlvbik7XG5cbiAgICBpZiAoaXNUZW5zaW9uQ29uZmlnIHx8ICFzaGFyZWQuaXMudW5kKHByb3BzLmZyZXF1ZW5jeSkgfHwgIXNoYXJlZC5pcy51bmQocHJvcHMuZGFtcGluZykgfHwgIXNoYXJlZC5pcy51bmQocHJvcHMubWFzcykpIHtcbiAgICAgIGNvbmZpZy5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbmZpZy5kZWNheSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoaXNUZW5zaW9uQ29uZmlnKSB7XG4gICAgICBjb25maWcuZnJlcXVlbmN5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBlbXB0eUFycmF5ID0gW107XG5jbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZhbHVlcyA9IGVtcHR5QXJyYXk7XG4gICAgdGhpcy50b1ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5mcm9tVmFsdWVzID0gZW1wdHlBcnJheTtcbiAgICB0aGlzLnRvID0gdm9pZCAwO1xuICAgIHRoaXMuZnJvbSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBBbmltYXRpb25Db25maWcoKTtcbiAgICB0aGlzLmltbWVkaWF0ZSA9IGZhbHNlO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVQcm9wcyhjYWxsSWQsIHtcbiAga2V5LFxuICBwcm9wcyxcbiAgZGVmYXVsdFByb3BzLFxuICBzdGF0ZSxcbiAgYWN0aW9uc1xufSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBfcHJvcHMkY2FuY2VsO1xuXG4gICAgbGV0IGRlbGF5O1xuICAgIGxldCB0aW1lb3V0O1xuICAgIGxldCBjYW5jZWwgPSBtYXRjaFByb3AoKF9wcm9wcyRjYW5jZWwgPSBwcm9wcy5jYW5jZWwpICE9IG51bGwgPyBfcHJvcHMkY2FuY2VsIDogZGVmYXVsdFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBkZWZhdWx0UHJvcHMuY2FuY2VsLCBrZXkpO1xuXG4gICAgaWYgKGNhbmNlbCkge1xuICAgICAgb25TdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXNoYXJlZC5pcy51bmQocHJvcHMucGF1c2UpKSB7XG4gICAgICAgIHN0YXRlLnBhdXNlZCA9IG1hdGNoUHJvcChwcm9wcy5wYXVzZSwga2V5KTtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdXNlID0gZGVmYXVsdFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBkZWZhdWx0UHJvcHMucGF1c2U7XG5cbiAgICAgIGlmIChwYXVzZSAhPT0gdHJ1ZSkge1xuICAgICAgICBwYXVzZSA9IHN0YXRlLnBhdXNlZCB8fCBtYXRjaFByb3AocGF1c2UsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGF5ID0gY2FsbFByb3AocHJvcHMuZGVsYXkgfHwgMCwga2V5KTtcblxuICAgICAgaWYgKHBhdXNlKSB7XG4gICAgICAgIHN0YXRlLnJlc3VtZVF1ZXVlLmFkZChvblJlc3VtZSk7XG4gICAgICAgIGFjdGlvbnMucGF1c2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbnMucmVzdW1lKCk7XG4gICAgICAgIG9uUmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25QYXVzZSgpIHtcbiAgICAgIHN0YXRlLnJlc3VtZVF1ZXVlLmFkZChvblJlc3VtZSk7XG4gICAgICBzdGF0ZS50aW1lb3V0cy5kZWxldGUodGltZW91dCk7XG4gICAgICB0aW1lb3V0LmNhbmNlbCgpO1xuICAgICAgZGVsYXkgPSB0aW1lb3V0LnRpbWUgLSBzaGFyZWQucmFmLm5vdygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVzdW1lKCkge1xuICAgICAgaWYgKGRlbGF5ID4gMCAmJiAhc2hhcmVkLkdsb2JhbHMuc2tpcEFuaW1hdGlvbikge1xuICAgICAgICBzdGF0ZS5kZWxheWVkID0gdHJ1ZTtcbiAgICAgICAgdGltZW91dCA9IHNoYXJlZC5yYWYuc2V0VGltZW91dChvblN0YXJ0LCBkZWxheSk7XG4gICAgICAgIHN0YXRlLnBhdXNlUXVldWUuYWRkKG9uUGF1c2UpO1xuICAgICAgICBzdGF0ZS50aW1lb3V0cy5hZGQodGltZW91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgIGlmIChzdGF0ZS5kZWxheWVkKSB7XG4gICAgICAgIHN0YXRlLmRlbGF5ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucGF1c2VRdWV1ZS5kZWxldGUob25QYXVzZSk7XG4gICAgICBzdGF0ZS50aW1lb3V0cy5kZWxldGUodGltZW91dCk7XG5cbiAgICAgIGlmIChjYWxsSWQgPD0gKHN0YXRlLmNhbmNlbElkIHx8IDApKSB7XG4gICAgICAgIGNhbmNlbCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGlvbnMuc3RhcnQoX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgICAgY2FsbElkLFxuICAgICAgICAgIGNhbmNlbFxuICAgICAgICB9KSwgcmVzb2x2ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgZ2V0Q29tYmluZWRSZXN1bHQgPSAodGFyZ2V0LCByZXN1bHRzKSA9PiByZXN1bHRzLmxlbmd0aCA9PSAxID8gcmVzdWx0c1swXSA6IHJlc3VsdHMuc29tZShyZXN1bHQgPT4gcmVzdWx0LmNhbmNlbGxlZCkgPyBnZXRDYW5jZWxsZWRSZXN1bHQodGFyZ2V0LmdldCgpKSA6IHJlc3VsdHMuZXZlcnkocmVzdWx0ID0+IHJlc3VsdC5ub29wKSA/IGdldE5vb3BSZXN1bHQodGFyZ2V0LmdldCgpKSA6IGdldEZpbmlzaGVkUmVzdWx0KHRhcmdldC5nZXQoKSwgcmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gcmVzdWx0LmZpbmlzaGVkKSk7XG5jb25zdCBnZXROb29wUmVzdWx0ID0gdmFsdWUgPT4gKHtcbiAgdmFsdWUsXG4gIG5vb3A6IHRydWUsXG4gIGZpbmlzaGVkOiB0cnVlLFxuICBjYW5jZWxsZWQ6IGZhbHNlXG59KTtcbmNvbnN0IGdldEZpbmlzaGVkUmVzdWx0ID0gKHZhbHVlLCBmaW5pc2hlZCwgY2FuY2VsbGVkID0gZmFsc2UpID0+ICh7XG4gIHZhbHVlLFxuICBmaW5pc2hlZCxcbiAgY2FuY2VsbGVkXG59KTtcbmNvbnN0IGdldENhbmNlbGxlZFJlc3VsdCA9IHZhbHVlID0+ICh7XG4gIHZhbHVlLFxuICBjYW5jZWxsZWQ6IHRydWUsXG4gIGZpbmlzaGVkOiBmYWxzZVxufSk7XG5cbmZ1bmN0aW9uIHJ1bkFzeW5jKHRvLCBwcm9wcywgc3RhdGUsIHRhcmdldCkge1xuICBjb25zdCB7XG4gICAgY2FsbElkLFxuICAgIHBhcmVudElkLFxuICAgIG9uUmVzdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBhc3luY1RvOiBwcmV2VG8sXG4gICAgcHJvbWlzZTogcHJldlByb21pc2VcbiAgfSA9IHN0YXRlO1xuXG4gIGlmICghcGFyZW50SWQgJiYgdG8gPT09IHByZXZUbyAmJiAhcHJvcHMucmVzZXQpIHtcbiAgICByZXR1cm4gcHJldlByb21pc2U7XG4gIH1cblxuICByZXR1cm4gc3RhdGUucHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgc3RhdGUuYXN5bmNJZCA9IGNhbGxJZDtcbiAgICBzdGF0ZS5hc3luY1RvID0gdG87XG4gICAgY29uc3QgZGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzKHByb3BzLCAodmFsdWUsIGtleSkgPT4ga2V5ID09PSAnb25SZXN0JyA/IHVuZGVmaW5lZCA6IHZhbHVlKTtcbiAgICBsZXQgcHJldmVudEJhaWw7XG4gICAgbGV0IGJhaWw7XG4gICAgY29uc3QgYmFpbFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiAocHJldmVudEJhaWwgPSByZXNvbHZlLCBiYWlsID0gcmVqZWN0KSk7XG5cbiAgICBjb25zdCBiYWlsSWZFbmRlZCA9IGJhaWxTaWduYWwgPT4ge1xuICAgICAgY29uc3QgYmFpbFJlc3VsdCA9IGNhbGxJZCA8PSAoc3RhdGUuY2FuY2VsSWQgfHwgMCkgJiYgZ2V0Q2FuY2VsbGVkUmVzdWx0KHRhcmdldCkgfHwgY2FsbElkICE9PSBzdGF0ZS5hc3luY0lkICYmIGdldEZpbmlzaGVkUmVzdWx0KHRhcmdldCwgZmFsc2UpO1xuXG4gICAgICBpZiAoYmFpbFJlc3VsdCkge1xuICAgICAgICBiYWlsU2lnbmFsLnJlc3VsdCA9IGJhaWxSZXN1bHQ7XG4gICAgICAgIGJhaWwoYmFpbFNpZ25hbCk7XG4gICAgICAgIHRocm93IGJhaWxTaWduYWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGFuaW1hdGUgPSAoYXJnMSwgYXJnMikgPT4ge1xuICAgICAgY29uc3QgYmFpbFNpZ25hbCA9IG5ldyBCYWlsU2lnbmFsKCk7XG4gICAgICBjb25zdCBza2lwQW5pbWF0aW9uU2lnbmFsID0gbmV3IFNraXBBbmltYXRpb25TaWduYWwoKTtcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkLkdsb2JhbHMuc2tpcEFuaW1hdGlvbikge1xuICAgICAgICAgIHN0b3BBc3luYyhzdGF0ZSk7XG4gICAgICAgICAgc2tpcEFuaW1hdGlvblNpZ25hbC5yZXN1bHQgPSBnZXRGaW5pc2hlZFJlc3VsdCh0YXJnZXQsIGZhbHNlKTtcbiAgICAgICAgICBiYWlsKHNraXBBbmltYXRpb25TaWduYWwpO1xuICAgICAgICAgIHRocm93IHNraXBBbmltYXRpb25TaWduYWw7XG4gICAgICAgIH1cblxuICAgICAgICBiYWlsSWZFbmRlZChiYWlsU2lnbmFsKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBzaGFyZWQuaXMub2JqKGFyZzEpID8gX2V4dGVuZHMoe30sIGFyZzEpIDogX2V4dGVuZHMoe30sIGFyZzIsIHtcbiAgICAgICAgICB0bzogYXJnMVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMucGFyZW50SWQgPSBjYWxsSWQ7XG4gICAgICAgIHNoYXJlZC5lYWNoUHJvcChkZWZhdWx0UHJvcHMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKHNoYXJlZC5pcy51bmQocHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0YXJnZXQuc3RhcnQocHJvcHMpO1xuICAgICAgICBiYWlsSWZFbmRlZChiYWlsU2lnbmFsKTtcblxuICAgICAgICBpZiAoc3RhdGUucGF1c2VkKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzdW1lID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnJlc3VtZVF1ZXVlLmFkZChyZXN1bWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pKCk7XG4gICAgfTtcblxuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZiAoc2hhcmVkLkdsb2JhbHMuc2tpcEFuaW1hdGlvbikge1xuICAgICAgc3RvcEFzeW5jKHN0YXRlKTtcbiAgICAgIHJldHVybiBnZXRGaW5pc2hlZFJlc3VsdCh0YXJnZXQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IGFuaW1hdGluZztcblxuICAgICAgaWYgKHNoYXJlZC5pcy5hcnIodG8pKSB7XG4gICAgICAgIGFuaW1hdGluZyA9IChhc3luYyBxdWV1ZSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wcyBvZiBxdWV1ZSkge1xuICAgICAgICAgICAgYXdhaXQgYW5pbWF0ZShwcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSh0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpbmcgPSBQcm9taXNlLnJlc29sdmUodG8oYW5pbWF0ZSwgdGFyZ2V0LnN0b3AuYmluZCh0YXJnZXQpKSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFthbmltYXRpbmcudGhlbihwcmV2ZW50QmFpbCksIGJhaWxQcm9taXNlXSk7XG4gICAgICByZXN1bHQgPSBnZXRGaW5pc2hlZFJlc3VsdCh0YXJnZXQuZ2V0KCksIHRydWUsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBCYWlsU2lnbmFsKSB7XG4gICAgICAgIHJlc3VsdCA9IGVyci5yZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIFNraXBBbmltYXRpb25TaWduYWwpIHtcbiAgICAgICAgcmVzdWx0ID0gZXJyLnJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGNhbGxJZCA9PSBzdGF0ZS5hc3luY0lkKSB7XG4gICAgICAgIHN0YXRlLmFzeW5jSWQgPSBwYXJlbnRJZDtcbiAgICAgICAgc3RhdGUuYXN5bmNUbyA9IHBhcmVudElkID8gcHJldlRvIDogdW5kZWZpbmVkO1xuICAgICAgICBzdGF0ZS5wcm9taXNlID0gcGFyZW50SWQgPyBwcmV2UHJvbWlzZSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hhcmVkLmlzLmZ1bihvblJlc3QpKSB7XG4gICAgICBzaGFyZWQucmFmLmJhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgb25SZXN0KHJlc3VsdCwgdGFyZ2V0LCB0YXJnZXQuaXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gc3RvcEFzeW5jKHN0YXRlLCBjYW5jZWxJZCkge1xuICBzaGFyZWQuZmx1c2goc3RhdGUudGltZW91dHMsIHQgPT4gdC5jYW5jZWwoKSk7XG4gIHN0YXRlLnBhdXNlUXVldWUuY2xlYXIoKTtcbiAgc3RhdGUucmVzdW1lUXVldWUuY2xlYXIoKTtcbiAgc3RhdGUuYXN5bmNJZCA9IHN0YXRlLmFzeW5jVG8gPSBzdGF0ZS5wcm9taXNlID0gdW5kZWZpbmVkO1xuICBpZiAoY2FuY2VsSWQpIHN0YXRlLmNhbmNlbElkID0gY2FuY2VsSWQ7XG59XG5jbGFzcyBCYWlsU2lnbmFsIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignQW4gYXN5bmMgYW5pbWF0aW9uIGhhcyBiZWVuIGludGVycnVwdGVkLiBZb3Ugc2VlIHRoaXMgZXJyb3IgYmVjYXVzZSB5b3UgJyArICdmb3Jnb3QgdG8gdXNlIGBhd2FpdGAgb3IgYC5jYXRjaCguLi4pYCBvbiBpdHMgcmV0dXJuZWQgcHJvbWlzZS4nKTtcbiAgICB0aGlzLnJlc3VsdCA9IHZvaWQgMDtcbiAgfVxuXG59XG5jbGFzcyBTa2lwQW5pbWF0aW9uU2lnbmFsIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignU2tpcEFuaW1hdGlvblNpZ25hbCcpO1xuICAgIHRoaXMucmVzdWx0ID0gdm9pZCAwO1xuICB9XG5cbn1cblxuY29uc3QgaXNGcmFtZVZhbHVlID0gdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBGcmFtZVZhbHVlO1xubGV0IG5leHRJZCQxID0gMTtcbmNsYXNzIEZyYW1lVmFsdWUgZXh0ZW5kcyBzaGFyZWQuRmx1aWRWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmlkID0gbmV4dElkJDErKztcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLl9wcmlvcml0eSA9IDA7XG4gIH1cblxuICBnZXQgcHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaW9yaXR5O1xuICB9XG5cbiAgc2V0IHByaW9yaXR5KHByaW9yaXR5KSB7XG4gICAgaWYgKHRoaXMuX3ByaW9yaXR5ICE9IHByaW9yaXR5KSB7XG4gICAgICB0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5O1xuXG4gICAgICB0aGlzLl9vblByaW9yaXR5Q2hhbmdlKHByaW9yaXR5KTtcbiAgICB9XG4gIH1cblxuICBnZXQoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcyk7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgdG8oLi4uYXJncykge1xuICAgIHJldHVybiBzaGFyZWQuR2xvYmFscy50byh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIGludGVycG9sYXRlKC4uLmFyZ3MpIHtcbiAgICBzaGFyZWQuZGVwcmVjYXRlSW50ZXJwb2xhdGUoKTtcbiAgICByZXR1cm4gc2hhcmVkLkdsb2JhbHMudG8odGhpcywgYXJncyk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XG4gIH1cblxuICBvYnNlcnZlckFkZGVkKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IDEpIHRoaXMuX2F0dGFjaCgpO1xuICB9XG5cbiAgb2JzZXJ2ZXJSZW1vdmVkKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IDApIHRoaXMuX2RldGFjaCgpO1xuICB9XG5cbiAgX2F0dGFjaCgpIHt9XG5cbiAgX2RldGFjaCgpIHt9XG5cbiAgX29uQ2hhbmdlKHZhbHVlLCBpZGxlID0gZmFsc2UpIHtcbiAgICBzaGFyZWQuY2FsbEZsdWlkT2JzZXJ2ZXJzKHRoaXMsIHtcbiAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgdmFsdWUsXG4gICAgICBpZGxlXG4gICAgfSk7XG4gIH1cblxuICBfb25Qcmlvcml0eUNoYW5nZShwcmlvcml0eSkge1xuICAgIGlmICghdGhpcy5pZGxlKSB7XG4gICAgICBzaGFyZWQuZnJhbWVMb29wLnNvcnQodGhpcyk7XG4gICAgfVxuXG4gICAgc2hhcmVkLmNhbGxGbHVpZE9ic2VydmVycyh0aGlzLCB7XG4gICAgICB0eXBlOiAncHJpb3JpdHknLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgcHJpb3JpdHlcbiAgICB9KTtcbiAgfVxuXG59XG5cbmNvbnN0ICRQID0gU3ltYm9sLmZvcignU3ByaW5nUGhhc2UnKTtcbmNvbnN0IEhBU19BTklNQVRFRCA9IDE7XG5jb25zdCBJU19BTklNQVRJTkcgPSAyO1xuY29uc3QgSVNfUEFVU0VEID0gNDtcbmNvbnN0IGhhc0FuaW1hdGVkID0gdGFyZ2V0ID0+ICh0YXJnZXRbJFBdICYgSEFTX0FOSU1BVEVEKSA+IDA7XG5jb25zdCBpc0FuaW1hdGluZyA9IHRhcmdldCA9PiAodGFyZ2V0WyRQXSAmIElTX0FOSU1BVElORykgPiAwO1xuY29uc3QgaXNQYXVzZWQgPSB0YXJnZXQgPT4gKHRhcmdldFskUF0gJiBJU19QQVVTRUQpID4gMDtcbmNvbnN0IHNldEFjdGl2ZUJpdCA9ICh0YXJnZXQsIGFjdGl2ZSkgPT4gYWN0aXZlID8gdGFyZ2V0WyRQXSB8PSBJU19BTklNQVRJTkcgfCBIQVNfQU5JTUFURUQgOiB0YXJnZXRbJFBdICY9IH5JU19BTklNQVRJTkc7XG5jb25zdCBzZXRQYXVzZWRCaXQgPSAodGFyZ2V0LCBwYXVzZWQpID0+IHBhdXNlZCA/IHRhcmdldFskUF0gfD0gSVNfUEFVU0VEIDogdGFyZ2V0WyRQXSAmPSB+SVNfUEFVU0VEO1xuXG5jbGFzcyBTcHJpbmdWYWx1ZSBleHRlbmRzIEZyYW1lVmFsdWUge1xuICBjb25zdHJ1Y3RvcihhcmcxLCBhcmcyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAgICB0aGlzLnF1ZXVlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdFByb3BzID0ge307XG4gICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgZGVsYXllZDogZmFsc2UsXG4gICAgICBwYXVzZVF1ZXVlOiBuZXcgU2V0KCksXG4gICAgICByZXN1bWVRdWV1ZTogbmV3IFNldCgpLFxuICAgICAgdGltZW91dHM6IG5ldyBTZXQoKVxuICAgIH07XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2xhc3RDYWxsSWQgPSAwO1xuICAgIHRoaXMuX2xhc3RUb0lkID0gMDtcbiAgICB0aGlzLl9tZW1vaXplZER1cmF0aW9uID0gMDtcblxuICAgIGlmICghc2hhcmVkLmlzLnVuZChhcmcxKSB8fCAhc2hhcmVkLmlzLnVuZChhcmcyKSkge1xuICAgICAgY29uc3QgcHJvcHMgPSBzaGFyZWQuaXMub2JqKGFyZzEpID8gX2V4dGVuZHMoe30sIGFyZzEpIDogX2V4dGVuZHMoe30sIGFyZzIsIHtcbiAgICAgICAgZnJvbTogYXJnMVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzaGFyZWQuaXMudW5kKHByb3BzLmRlZmF1bHQpKSB7XG4gICAgICAgIHByb3BzLmRlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXJ0KHByb3BzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaWRsZSgpIHtcbiAgICByZXR1cm4gIShpc0FuaW1hdGluZyh0aGlzKSB8fCB0aGlzLl9zdGF0ZS5hc3luY1RvKSB8fCBpc1BhdXNlZCh0aGlzKTtcbiAgfVxuXG4gIGdldCBnb2FsKCkge1xuICAgIHJldHVybiBzaGFyZWQuZ2V0Rmx1aWRWYWx1ZSh0aGlzLmFuaW1hdGlvbi50byk7XG4gIH1cblxuICBnZXQgdmVsb2NpdHkoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcyk7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBhbmltYXRlZCQxLkFuaW1hdGVkVmFsdWUgPyBub2RlLmxhc3RWZWxvY2l0eSB8fCAwIDogbm9kZS5nZXRQYXlsb2FkKCkubWFwKG5vZGUgPT4gbm9kZS5sYXN0VmVsb2NpdHkgfHwgMCk7XG4gIH1cblxuICBnZXQgaGFzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIGhhc0FuaW1hdGVkKHRoaXMpO1xuICB9XG5cbiAgZ2V0IGlzQW5pbWF0aW5nKCkge1xuICAgIHJldHVybiBpc0FuaW1hdGluZyh0aGlzKTtcbiAgfVxuXG4gIGdldCBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gaXNQYXVzZWQodGhpcyk7XG4gIH1cblxuICBnZXQgaXNEZWxheWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5kZWxheWVkO1xuICB9XG5cbiAgYWR2YW5jZShkdCkge1xuICAgIGxldCBpZGxlID0gdHJ1ZTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFuaW0gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICBsZXQge1xuICAgICAgY29uZmlnLFxuICAgICAgdG9WYWx1ZXNcbiAgICB9ID0gYW5pbTtcbiAgICBjb25zdCBwYXlsb2FkID0gYW5pbWF0ZWQkMS5nZXRQYXlsb2FkKGFuaW0udG8pO1xuXG4gICAgaWYgKCFwYXlsb2FkICYmIHNoYXJlZC5oYXNGbHVpZFZhbHVlKGFuaW0udG8pKSB7XG4gICAgICB0b1ZhbHVlcyA9IHNoYXJlZC50b0FycmF5KHNoYXJlZC5nZXRGbHVpZFZhbHVlKGFuaW0udG8pKTtcbiAgICB9XG5cbiAgICBhbmltLnZhbHVlcy5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgICBpZiAobm9kZS5kb25lKSByZXR1cm47XG4gICAgICBjb25zdCB0byA9IG5vZGUuY29uc3RydWN0b3IgPT0gYW5pbWF0ZWQkMS5BbmltYXRlZFN0cmluZyA/IDEgOiBwYXlsb2FkID8gcGF5bG9hZFtpXS5sYXN0UG9zaXRpb24gOiB0b1ZhbHVlc1tpXTtcbiAgICAgIGxldCBmaW5pc2hlZCA9IGFuaW0uaW1tZWRpYXRlO1xuICAgICAgbGV0IHBvc2l0aW9uID0gdG87XG5cbiAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgcG9zaXRpb24gPSBub2RlLmxhc3RQb3NpdGlvbjtcblxuICAgICAgICBpZiAoY29uZmlnLnRlbnNpb24gPD0gMCkge1xuICAgICAgICAgIG5vZGUuZG9uZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVsYXBzZWQgPSBub2RlLmVsYXBzZWRUaW1lICs9IGR0O1xuICAgICAgICBjb25zdCBmcm9tID0gYW5pbS5mcm9tVmFsdWVzW2ldO1xuICAgICAgICBjb25zdCB2MCA9IG5vZGUudjAgIT0gbnVsbCA/IG5vZGUudjAgOiBub2RlLnYwID0gc2hhcmVkLmlzLmFycihjb25maWcudmVsb2NpdHkpID8gY29uZmlnLnZlbG9jaXR5W2ldIDogY29uZmlnLnZlbG9jaXR5O1xuICAgICAgICBsZXQgdmVsb2NpdHk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IGNvbmZpZy5wcmVjaXNpb24gfHwgKGZyb20gPT0gdG8gPyAwLjAwNSA6IE1hdGgubWluKDEsIE1hdGguYWJzKHRvIC0gZnJvbSkgKiAwLjAwMSkpO1xuXG4gICAgICAgIGlmICghc2hhcmVkLmlzLnVuZChjb25maWcuZHVyYXRpb24pKSB7XG4gICAgICAgICAgbGV0IHAgPSAxO1xuXG4gICAgICAgICAgaWYgKGNvbmZpZy5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZW1vaXplZER1cmF0aW9uICE9PSBjb25maWcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWVtb2l6ZWREdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbjtcblxuICAgICAgICAgICAgICBpZiAobm9kZS5kdXJhdGlvblByb2dyZXNzID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUuZWxhcHNlZFRpbWUgPSBjb25maWcuZHVyYXRpb24gKiBub2RlLmR1cmF0aW9uUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgZWxhcHNlZCA9IG5vZGUuZWxhcHNlZFRpbWUgKz0gZHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IChjb25maWcucHJvZ3Jlc3MgfHwgMCkgKyBlbGFwc2VkIC8gdGhpcy5fbWVtb2l6ZWREdXJhdGlvbjtcbiAgICAgICAgICAgIHAgPSBwID4gMSA/IDEgOiBwIDwgMCA/IDAgOiBwO1xuICAgICAgICAgICAgbm9kZS5kdXJhdGlvblByb2dyZXNzID0gcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3NpdGlvbiA9IGZyb20gKyBjb25maWcuZWFzaW5nKHApICogKHRvIC0gZnJvbSk7XG4gICAgICAgICAgdmVsb2NpdHkgPSAocG9zaXRpb24gLSBub2RlLmxhc3RQb3NpdGlvbikgLyBkdDtcbiAgICAgICAgICBmaW5pc2hlZCA9IHAgPT0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuZGVjYXkpIHtcbiAgICAgICAgICBjb25zdCBkZWNheSA9IGNvbmZpZy5kZWNheSA9PT0gdHJ1ZSA/IDAuOTk4IDogY29uZmlnLmRlY2F5O1xuICAgICAgICAgIGNvbnN0IGUgPSBNYXRoLmV4cCgtKDEgLSBkZWNheSkgKiBlbGFwc2VkKTtcbiAgICAgICAgICBwb3NpdGlvbiA9IGZyb20gKyB2MCAvICgxIC0gZGVjYXkpICogKDEgLSBlKTtcbiAgICAgICAgICBmaW5pc2hlZCA9IE1hdGguYWJzKG5vZGUubGFzdFBvc2l0aW9uIC0gcG9zaXRpb24pIDw9IHByZWNpc2lvbjtcbiAgICAgICAgICB2ZWxvY2l0eSA9IHYwICogZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZWxvY2l0eSA9IG5vZGUubGFzdFZlbG9jaXR5ID09IG51bGwgPyB2MCA6IG5vZGUubGFzdFZlbG9jaXR5O1xuICAgICAgICAgIGNvbnN0IHJlc3RWZWxvY2l0eSA9IGNvbmZpZy5yZXN0VmVsb2NpdHkgfHwgcHJlY2lzaW9uIC8gMTA7XG4gICAgICAgICAgY29uc3QgYm91bmNlRmFjdG9yID0gY29uZmlnLmNsYW1wID8gMCA6IGNvbmZpZy5ib3VuY2U7XG4gICAgICAgICAgY29uc3QgY2FuQm91bmNlID0gIXNoYXJlZC5pcy51bmQoYm91bmNlRmFjdG9yKTtcbiAgICAgICAgICBjb25zdCBpc0dyb3dpbmcgPSBmcm9tID09IHRvID8gbm9kZS52MCA+IDAgOiBmcm9tIDwgdG87XG4gICAgICAgICAgbGV0IGlzTW92aW5nO1xuICAgICAgICAgIGxldCBpc0JvdW5jaW5nID0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qgc3RlcCA9IDE7XG4gICAgICAgICAgY29uc3QgbnVtU3RlcHMgPSBNYXRoLmNlaWwoZHQgLyBzdGVwKTtcblxuICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbnVtU3RlcHM7ICsrbikge1xuICAgICAgICAgICAgaXNNb3ZpbmcgPSBNYXRoLmFicyh2ZWxvY2l0eSkgPiByZXN0VmVsb2NpdHk7XG5cbiAgICAgICAgICAgIGlmICghaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgZmluaXNoZWQgPSBNYXRoLmFicyh0byAtIHBvc2l0aW9uKSA8PSBwcmVjaXNpb247XG5cbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbkJvdW5jZSkge1xuICAgICAgICAgICAgICBpc0JvdW5jaW5nID0gcG9zaXRpb24gPT0gdG8gfHwgcG9zaXRpb24gPiB0byA9PSBpc0dyb3dpbmc7XG5cbiAgICAgICAgICAgICAgaWYgKGlzQm91bmNpbmcpIHtcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IC12ZWxvY2l0eSAqIGJvdW5jZUZhY3RvcjtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRvO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNwcmluZ0ZvcmNlID0gLWNvbmZpZy50ZW5zaW9uICogMC4wMDAwMDEgKiAocG9zaXRpb24gLSB0byk7XG4gICAgICAgICAgICBjb25zdCBkYW1waW5nRm9yY2UgPSAtY29uZmlnLmZyaWN0aW9uICogMC4wMDEgKiB2ZWxvY2l0eTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2VsZXJhdGlvbiA9IChzcHJpbmdGb3JjZSArIGRhbXBpbmdGb3JjZSkgLyBjb25maWcubWFzcztcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHkgKyBhY2NlbGVyYXRpb24gKiBzdGVwO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiArIHZlbG9jaXR5ICogc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLmxhc3RWZWxvY2l0eSA9IHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4ocG9zaXRpb24pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBHb3QgTmFOIHdoaWxlIGFuaW1hdGluZzpgLCB0aGlzKTtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBheWxvYWQgJiYgIXBheWxvYWRbaV0uZG9uZSkge1xuICAgICAgICBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgbm9kZS5kb25lID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkbGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuc2V0VmFsdWUocG9zaXRpb24sIGNvbmZpZy5yb3VuZCkpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgbm9kZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcyk7XG4gICAgY29uc3QgY3VyclZhbCA9IG5vZGUuZ2V0VmFsdWUoKTtcblxuICAgIGlmIChpZGxlKSB7XG4gICAgICBjb25zdCBmaW5hbFZhbCA9IHNoYXJlZC5nZXRGbHVpZFZhbHVlKGFuaW0udG8pO1xuXG4gICAgICBpZiAoKGN1cnJWYWwgIT09IGZpbmFsVmFsIHx8IGNoYW5nZWQpICYmICFjb25maWcuZGVjYXkpIHtcbiAgICAgICAgbm9kZS5zZXRWYWx1ZShmaW5hbFZhbCk7XG5cbiAgICAgICAgdGhpcy5fb25DaGFuZ2UoZmluYWxWYWwpO1xuICAgICAgfSBlbHNlIGlmIChjaGFuZ2VkICYmIGNvbmZpZy5kZWNheSkge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZShjdXJyVmFsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fb25DaGFuZ2UoY3VyclZhbCk7XG4gICAgfVxuICB9XG5cbiAgc2V0KHZhbHVlKSB7XG4gICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICB0aGlzLl9zdG9wKCk7XG5cbiAgICAgIHRoaXMuX2ZvY3VzKHZhbHVlKTtcblxuICAgICAgdGhpcy5fc2V0KHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHRoaXMuX3VwZGF0ZSh7XG4gICAgICBwYXVzZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIHRoaXMuX3VwZGF0ZSh7XG4gICAgICBwYXVzZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIGZpbmlzaCgpIHtcbiAgICBpZiAoaXNBbmltYXRpbmcodGhpcykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG8sXG4gICAgICAgIGNvbmZpZ1xuICAgICAgfSA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uU3RhcnQoKTtcblxuICAgICAgICBpZiAoIWNvbmZpZy5kZWNheSkge1xuICAgICAgICAgIHRoaXMuX3NldCh0bywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGUocHJvcHMpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWUgfHwgKHRoaXMucXVldWUgPSBbXSk7XG4gICAgcXVldWUucHVzaChwcm9wcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGFydCh0bywgYXJnMikge1xuICAgIGxldCBxdWV1ZTtcblxuICAgIGlmICghc2hhcmVkLmlzLnVuZCh0bykpIHtcbiAgICAgIHF1ZXVlID0gW3NoYXJlZC5pcy5vYmoodG8pID8gdG8gOiBfZXh0ZW5kcyh7fSwgYXJnMiwge1xuICAgICAgICB0b1xuICAgICAgfSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZSA9IHRoaXMucXVldWUgfHwgW107XG4gICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXVlLm1hcChwcm9wcyA9PiB7XG4gICAgICBjb25zdCB1cCA9IHRoaXMuX3VwZGF0ZShwcm9wcyk7XG5cbiAgICAgIHJldHVybiB1cDtcbiAgICB9KSkudGhlbihyZXN1bHRzID0+IGdldENvbWJpbmVkUmVzdWx0KHRoaXMsIHJlc3VsdHMpKTtcbiAgfVxuXG4gIHN0b3AoY2FuY2VsKSB7XG4gICAgY29uc3Qge1xuICAgICAgdG9cbiAgICB9ID0gdGhpcy5hbmltYXRpb247XG5cbiAgICB0aGlzLl9mb2N1cyh0aGlzLmdldCgpKTtcblxuICAgIHN0b3BBc3luYyh0aGlzLl9zdGF0ZSwgY2FuY2VsICYmIHRoaXMuX2xhc3RDYWxsSWQpO1xuICAgIHNoYXJlZC5yYWYuYmF0Y2hlZFVwZGF0ZXMoKCkgPT4gdGhpcy5fc3RvcCh0bywgY2FuY2VsKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoe1xuICAgICAgcmVzZXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGV2ZW50T2JzZXJ2ZWQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PSAnY2hhbmdlJykge1xuICAgICAgdGhpcy5fc3RhcnQoKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT0gJ3ByaW9yaXR5Jykge1xuICAgICAgdGhpcy5wcmlvcml0eSA9IGV2ZW50LnByaW9yaXR5ICsgMTtcbiAgICB9XG4gIH1cblxuICBfcHJlcGFyZU5vZGUocHJvcHMpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleSB8fCAnJztcbiAgICBsZXQge1xuICAgICAgdG8sXG4gICAgICBmcm9tXG4gICAgfSA9IHByb3BzO1xuICAgIHRvID0gc2hhcmVkLmlzLm9iaih0bykgPyB0b1trZXldIDogdG87XG5cbiAgICBpZiAodG8gPT0gbnVsbCB8fCBpc0FzeW5jVG8odG8pKSB7XG4gICAgICB0byA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmcm9tID0gc2hhcmVkLmlzLm9iaihmcm9tKSA/IGZyb21ba2V5XSA6IGZyb207XG5cbiAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICBmcm9tID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgdG8sXG4gICAgICBmcm9tXG4gICAgfTtcblxuICAgIGlmICghaGFzQW5pbWF0ZWQodGhpcykpIHtcbiAgICAgIGlmIChwcm9wcy5yZXZlcnNlKSBbdG8sIGZyb21dID0gW2Zyb20sIHRvXTtcbiAgICAgIGZyb20gPSBzaGFyZWQuZ2V0Rmx1aWRWYWx1ZShmcm9tKTtcblxuICAgICAgaWYgKCFzaGFyZWQuaXMudW5kKGZyb20pKSB7XG4gICAgICAgIHRoaXMuX3NldChmcm9tKTtcbiAgICAgIH0gZWxzZSBpZiAoIWFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcykpIHtcbiAgICAgICAgdGhpcy5fc2V0KHRvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBfdXBkYXRlKF9yZWYsIGlzTG9vcCkge1xuICAgIGxldCBwcm9wcyA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGtleSxcbiAgICAgIGRlZmF1bHRQcm9wc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChwcm9wcy5kZWZhdWx0KSBPYmplY3QuYXNzaWduKGRlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKHByb3BzLCAodmFsdWUsIHByb3ApID0+IC9eb24vLnRlc3QocHJvcCkgPyByZXNvbHZlUHJvcCh2YWx1ZSwga2V5KSA6IHZhbHVlKSk7XG4gICAgbWVyZ2VBY3RpdmVGbih0aGlzLCBwcm9wcywgJ29uUHJvcHMnKTtcbiAgICBzZW5kRXZlbnQodGhpcywgJ29uUHJvcHMnLCBwcm9wcywgdGhpcyk7XG5cbiAgICBjb25zdCByYW5nZSA9IHRoaXMuX3ByZXBhcmVOb2RlKHByb3BzKTtcblxuICAgIGlmIChPYmplY3QuaXNGcm96ZW4odGhpcykpIHtcbiAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgYW5pbWF0ZSBhIGBTcHJpbmdWYWx1ZWAgb2JqZWN0IHRoYXQgaXMgZnJvemVuLiAnICsgJ0RpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgeW91ciBjb21wb25lbnQgdG8gYGFuaW1hdGVkKC4uLilgIGJlZm9yZSBhbmltYXRpbmcgaXRzIHByb3BzPycpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgcmV0dXJuIHNjaGVkdWxlUHJvcHMoKyt0aGlzLl9sYXN0Q2FsbElkLCB7XG4gICAgICBrZXksXG4gICAgICBwcm9wcyxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHN0YXRlLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBwYXVzZTogKCkgPT4ge1xuICAgICAgICAgIGlmICghaXNQYXVzZWQodGhpcykpIHtcbiAgICAgICAgICAgIHNldFBhdXNlZEJpdCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHNoYXJlZC5mbHVzaENhbGxzKHN0YXRlLnBhdXNlUXVldWUpO1xuICAgICAgICAgICAgc2VuZEV2ZW50KHRoaXMsICdvblBhdXNlJywgZ2V0RmluaXNoZWRSZXN1bHQodGhpcywgY2hlY2tGaW5pc2hlZCh0aGlzLCB0aGlzLmFuaW1hdGlvbi50bykpLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VtZTogKCkgPT4ge1xuICAgICAgICAgIGlmIChpc1BhdXNlZCh0aGlzKSkge1xuICAgICAgICAgICAgc2V0UGF1c2VkQml0KHRoaXMsIGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKGlzQW5pbWF0aW5nKHRoaXMpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3VtZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaGFyZWQuZmx1c2hDYWxscyhzdGF0ZS5yZXN1bWVRdWV1ZSk7XG4gICAgICAgICAgICBzZW5kRXZlbnQodGhpcywgJ29uUmVzdW1lJywgZ2V0RmluaXNoZWRSZXN1bHQodGhpcywgY2hlY2tGaW5pc2hlZCh0aGlzLCB0aGlzLmFuaW1hdGlvbi50bykpLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiB0aGlzLl9tZXJnZS5iaW5kKHRoaXMsIHJhbmdlKVxuICAgICAgfVxuICAgIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIGlmIChwcm9wcy5sb29wICYmIHJlc3VsdC5maW5pc2hlZCAmJiAhKGlzTG9vcCAmJiByZXN1bHQubm9vcCkpIHtcbiAgICAgICAgY29uc3QgbmV4dFByb3BzID0gY3JlYXRlTG9vcFVwZGF0ZShwcm9wcyk7XG5cbiAgICAgICAgaWYgKG5leHRQcm9wcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUobmV4dFByb3BzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgX21lcmdlKHJhbmdlLCBwcm9wcywgcmVzb2x2ZSkge1xuICAgIGlmIChwcm9wcy5jYW5jZWwpIHtcbiAgICAgIHRoaXMuc3RvcCh0cnVlKTtcbiAgICAgIHJldHVybiByZXNvbHZlKGdldENhbmNlbGxlZFJlc3VsdCh0aGlzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzVG9Qcm9wID0gIXNoYXJlZC5pcy51bmQocmFuZ2UudG8pO1xuICAgIGNvbnN0IGhhc0Zyb21Qcm9wID0gIXNoYXJlZC5pcy51bmQocmFuZ2UuZnJvbSk7XG5cbiAgICBpZiAoaGFzVG9Qcm9wIHx8IGhhc0Zyb21Qcm9wKSB7XG4gICAgICBpZiAocHJvcHMuY2FsbElkID4gdGhpcy5fbGFzdFRvSWQpIHtcbiAgICAgICAgdGhpcy5fbGFzdFRvSWQgPSBwcm9wcy5jYWxsSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXRDYW5jZWxsZWRSZXN1bHQodGhpcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGtleSxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIGFuaW1hdGlvbjogYW5pbVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvOiBwcmV2VG8sXG4gICAgICBmcm9tOiBwcmV2RnJvbVxuICAgIH0gPSBhbmltO1xuICAgIGxldCB7XG4gICAgICB0byA9IHByZXZUbyxcbiAgICAgIGZyb20gPSBwcmV2RnJvbVxuICAgIH0gPSByYW5nZTtcblxuICAgIGlmIChoYXNGcm9tUHJvcCAmJiAhaGFzVG9Qcm9wICYmICghcHJvcHMuZGVmYXVsdCB8fCBzaGFyZWQuaXMudW5kKHRvKSkpIHtcbiAgICAgIHRvID0gZnJvbTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMucmV2ZXJzZSkgW3RvLCBmcm9tXSA9IFtmcm9tLCB0b107XG4gICAgY29uc3QgaGFzRnJvbUNoYW5nZWQgPSAhc2hhcmVkLmlzRXF1YWwoZnJvbSwgcHJldkZyb20pO1xuXG4gICAgaWYgKGhhc0Zyb21DaGFuZ2VkKSB7XG4gICAgICBhbmltLmZyb20gPSBmcm9tO1xuICAgIH1cblxuICAgIGZyb20gPSBzaGFyZWQuZ2V0Rmx1aWRWYWx1ZShmcm9tKTtcbiAgICBjb25zdCBoYXNUb0NoYW5nZWQgPSAhc2hhcmVkLmlzRXF1YWwodG8sIHByZXZUbyk7XG5cbiAgICBpZiAoaGFzVG9DaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9mb2N1cyh0byk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzQXN5bmNUbyA9IGlzQXN5bmNUbyhwcm9wcy50byk7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IGFuaW07XG4gICAgY29uc3Qge1xuICAgICAgZGVjYXksXG4gICAgICB2ZWxvY2l0eVxuICAgIH0gPSBjb25maWc7XG5cbiAgICBpZiAoaGFzVG9Qcm9wIHx8IGhhc0Zyb21Qcm9wKSB7XG4gICAgICBjb25maWcudmVsb2NpdHkgPSAwO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5jb25maWcgJiYgIWhhc0FzeW5jVG8pIHtcbiAgICAgIG1lcmdlQ29uZmlnKGNvbmZpZywgY2FsbFByb3AocHJvcHMuY29uZmlnLCBrZXkpLCBwcm9wcy5jb25maWcgIT09IGRlZmF1bHRQcm9wcy5jb25maWcgPyBjYWxsUHJvcChkZWZhdWx0UHJvcHMuY29uZmlnLCBrZXkpIDogdm9pZCAwKTtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcyk7XG5cbiAgICBpZiAoIW5vZGUgfHwgc2hhcmVkLmlzLnVuZCh0bykpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGdldEZpbmlzaGVkUmVzdWx0KHRoaXMsIHRydWUpKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNldCA9IHNoYXJlZC5pcy51bmQocHJvcHMucmVzZXQpID8gaGFzRnJvbVByb3AgJiYgIXByb3BzLmRlZmF1bHQgOiAhc2hhcmVkLmlzLnVuZChmcm9tKSAmJiBtYXRjaFByb3AocHJvcHMucmVzZXQsIGtleSk7XG4gICAgY29uc3QgdmFsdWUgPSByZXNldCA/IGZyb20gOiB0aGlzLmdldCgpO1xuICAgIGNvbnN0IGdvYWwgPSBjb21wdXRlR29hbCh0byk7XG4gICAgY29uc3QgaXNBbmltYXRhYmxlID0gc2hhcmVkLmlzLm51bShnb2FsKSB8fCBzaGFyZWQuaXMuYXJyKGdvYWwpIHx8IHNoYXJlZC5pc0FuaW1hdGVkU3RyaW5nKGdvYWwpO1xuICAgIGNvbnN0IGltbWVkaWF0ZSA9ICFoYXNBc3luY1RvICYmICghaXNBbmltYXRhYmxlIHx8IG1hdGNoUHJvcChkZWZhdWx0UHJvcHMuaW1tZWRpYXRlIHx8IHByb3BzLmltbWVkaWF0ZSwga2V5KSk7XG5cbiAgICBpZiAoaGFzVG9DaGFuZ2VkKSB7XG4gICAgICBjb25zdCBub2RlVHlwZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWRUeXBlKHRvKTtcblxuICAgICAgaWYgKG5vZGVUeXBlICE9PSBub2RlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5fc2V0KGdvYWwpO1xuICAgICAgICB9IGVsc2UgdGhyb3cgRXJyb3IoYENhbm5vdCBhbmltYXRlIGJldHdlZW4gJHtub2RlLmNvbnN0cnVjdG9yLm5hbWV9IGFuZCAke25vZGVUeXBlLm5hbWV9LCBhcyB0aGUgXCJ0b1wiIHByb3Agc3VnZ2VzdHNgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBnb2FsVHlwZSA9IG5vZGUuY29uc3RydWN0b3I7XG4gICAgbGV0IHN0YXJ0ZWQgPSBzaGFyZWQuaGFzRmx1aWRWYWx1ZSh0byk7XG4gICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGNvbnN0IGhhc1ZhbHVlQ2hhbmdlZCA9IHJlc2V0IHx8ICFoYXNBbmltYXRlZCh0aGlzKSAmJiBoYXNGcm9tQ2hhbmdlZDtcblxuICAgICAgaWYgKGhhc1RvQ2hhbmdlZCB8fCBoYXNWYWx1ZUNoYW5nZWQpIHtcbiAgICAgICAgZmluaXNoZWQgPSBzaGFyZWQuaXNFcXVhbChjb21wdXRlR29hbCh2YWx1ZSksIGdvYWwpO1xuICAgICAgICBzdGFydGVkID0gIWZpbmlzaGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNoYXJlZC5pc0VxdWFsKGFuaW0uaW1tZWRpYXRlLCBpbW1lZGlhdGUpICYmICFpbW1lZGlhdGUgfHwgIXNoYXJlZC5pc0VxdWFsKGNvbmZpZy5kZWNheSwgZGVjYXkpIHx8ICFzaGFyZWQuaXNFcXVhbChjb25maWcudmVsb2NpdHksIHZlbG9jaXR5KSkge1xuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmluaXNoZWQgJiYgaXNBbmltYXRpbmcodGhpcykpIHtcbiAgICAgIGlmIChhbmltLmNoYW5nZWQgJiYgIXJlc2V0KSB7XG4gICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghc3RhcnRlZCkge1xuICAgICAgICB0aGlzLl9zdG9wKHByZXZUbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNBc3luY1RvKSB7XG4gICAgICBpZiAoc3RhcnRlZCB8fCBzaGFyZWQuaGFzRmx1aWRWYWx1ZShwcmV2VG8pKSB7XG4gICAgICAgIGFuaW0udmFsdWVzID0gbm9kZS5nZXRQYXlsb2FkKCk7XG4gICAgICAgIGFuaW0udG9WYWx1ZXMgPSBzaGFyZWQuaGFzRmx1aWRWYWx1ZSh0bykgPyBudWxsIDogZ29hbFR5cGUgPT0gYW5pbWF0ZWQkMS5BbmltYXRlZFN0cmluZyA/IFsxXSA6IHNoYXJlZC50b0FycmF5KGdvYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbS5pbW1lZGlhdGUgIT0gaW1tZWRpYXRlKSB7XG4gICAgICAgIGFuaW0uaW1tZWRpYXRlID0gaW1tZWRpYXRlO1xuXG4gICAgICAgIGlmICghaW1tZWRpYXRlICYmICFyZXNldCkge1xuICAgICAgICAgIHRoaXMuX3NldChwcmV2VG8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvblJlc3RcbiAgICAgICAgfSA9IGFuaW07XG4gICAgICAgIHNoYXJlZC5lYWNoKEFDVElWRV9FVkVOVFMsIHR5cGUgPT4gbWVyZ2VBY3RpdmVGbih0aGlzLCBwcm9wcywgdHlwZSkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRGaW5pc2hlZFJlc3VsdCh0aGlzLCBjaGVja0ZpbmlzaGVkKHRoaXMsIHByZXZUbykpO1xuICAgICAgICBzaGFyZWQuZmx1c2hDYWxscyh0aGlzLl9wZW5kaW5nQ2FsbHMsIHJlc3VsdCk7XG5cbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhbGxzLmFkZChyZXNvbHZlKTtcblxuICAgICAgICBpZiAoYW5pbS5jaGFuZ2VkKSBzaGFyZWQucmFmLmJhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBhbmltLmNoYW5nZWQgPSAhcmVzZXQ7XG4gICAgICAgICAgb25SZXN0ID09IG51bGwgPyB2b2lkIDAgOiBvblJlc3QocmVzdWx0LCB0aGlzKTtcblxuICAgICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgICAgY2FsbFByb3AoZGVmYXVsdFByb3BzLm9uUmVzdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5pbS5vblN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBhbmltLm9uU3RhcnQocmVzdWx0LCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXNldCkge1xuICAgICAgdGhpcy5fc2V0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzQXN5bmNUbykge1xuICAgICAgcmVzb2x2ZShydW5Bc3luYyhwcm9wcy50bywgcHJvcHMsIHRoaXMuX3N0YXRlLCB0aGlzKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydGVkKSB7XG4gICAgICB0aGlzLl9zdGFydCgpO1xuICAgIH0gZWxzZSBpZiAoaXNBbmltYXRpbmcodGhpcykgJiYgIWhhc1RvQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fcGVuZGluZ0NhbGxzLmFkZChyZXNvbHZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShnZXROb29wUmVzdWx0KHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgX2ZvY3VzKHZhbHVlKSB7XG4gICAgY29uc3QgYW5pbSA9IHRoaXMuYW5pbWF0aW9uO1xuXG4gICAgaWYgKHZhbHVlICE9PSBhbmltLnRvKSB7XG4gICAgICBpZiAoc2hhcmVkLmdldEZsdWlkT2JzZXJ2ZXJzKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuX2RldGFjaCgpO1xuICAgICAgfVxuXG4gICAgICBhbmltLnRvID0gdmFsdWU7XG5cbiAgICAgIGlmIChzaGFyZWQuZ2V0Rmx1aWRPYnNlcnZlcnModGhpcykpIHtcbiAgICAgICAgdGhpcy5fYXR0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2F0dGFjaCgpIHtcbiAgICBsZXQgcHJpb3JpdHkgPSAwO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvXG4gICAgfSA9IHRoaXMuYW5pbWF0aW9uO1xuXG4gICAgaWYgKHNoYXJlZC5oYXNGbHVpZFZhbHVlKHRvKSkge1xuICAgICAgc2hhcmVkLmFkZEZsdWlkT2JzZXJ2ZXIodG8sIHRoaXMpO1xuXG4gICAgICBpZiAoaXNGcmFtZVZhbHVlKHRvKSkge1xuICAgICAgICBwcmlvcml0eSA9IHRvLnByaW9yaXR5ICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gIH1cblxuICBfZGV0YWNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvXG4gICAgfSA9IHRoaXMuYW5pbWF0aW9uO1xuXG4gICAgaWYgKHNoYXJlZC5oYXNGbHVpZFZhbHVlKHRvKSkge1xuICAgICAgc2hhcmVkLnJlbW92ZUZsdWlkT2JzZXJ2ZXIodG8sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9zZXQoYXJnLCBpZGxlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gc2hhcmVkLmdldEZsdWlkVmFsdWUoYXJnKTtcblxuICAgIGlmICghc2hhcmVkLmlzLnVuZCh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IG9sZE5vZGUgPSBhbmltYXRlZCQxLmdldEFuaW1hdGVkKHRoaXMpO1xuXG4gICAgICBpZiAoIW9sZE5vZGUgfHwgIXNoYXJlZC5pc0VxdWFsKHZhbHVlLCBvbGROb2RlLmdldFZhbHVlKCkpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gYW5pbWF0ZWQkMS5nZXRBbmltYXRlZFR5cGUodmFsdWUpO1xuXG4gICAgICAgIGlmICghb2xkTm9kZSB8fCBvbGROb2RlLmNvbnN0cnVjdG9yICE9IG5vZGVUeXBlKSB7XG4gICAgICAgICAgYW5pbWF0ZWQkMS5zZXRBbmltYXRlZCh0aGlzLCBub2RlVHlwZS5jcmVhdGUodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGROb2RlLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGROb2RlKSB7XG4gICAgICAgICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZSwgaWRsZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0ZWQkMS5nZXRBbmltYXRlZCh0aGlzKTtcbiAgfVxuXG4gIF9vblN0YXJ0KCkge1xuICAgIGNvbnN0IGFuaW0gPSB0aGlzLmFuaW1hdGlvbjtcblxuICAgIGlmICghYW5pbS5jaGFuZ2VkKSB7XG4gICAgICBhbmltLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgc2VuZEV2ZW50KHRoaXMsICdvblN0YXJ0JywgZ2V0RmluaXNoZWRSZXN1bHQodGhpcywgY2hlY2tGaW5pc2hlZCh0aGlzLCBhbmltLnRvKSksIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkNoYW5nZSh2YWx1ZSwgaWRsZSkge1xuICAgIGlmICghaWRsZSkge1xuICAgICAgdGhpcy5fb25TdGFydCgpO1xuXG4gICAgICBjYWxsUHJvcCh0aGlzLmFuaW1hdGlvbi5vbkNoYW5nZSwgdmFsdWUsIHRoaXMpO1xuICAgIH1cblxuICAgIGNhbGxQcm9wKHRoaXMuZGVmYXVsdFByb3BzLm9uQ2hhbmdlLCB2YWx1ZSwgdGhpcyk7XG5cbiAgICBzdXBlci5fb25DaGFuZ2UodmFsdWUsIGlkbGUpO1xuICB9XG5cbiAgX3N0YXJ0KCkge1xuICAgIGNvbnN0IGFuaW0gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICBhbmltYXRlZCQxLmdldEFuaW1hdGVkKHRoaXMpLnJlc2V0KHNoYXJlZC5nZXRGbHVpZFZhbHVlKGFuaW0udG8pKTtcblxuICAgIGlmICghYW5pbS5pbW1lZGlhdGUpIHtcbiAgICAgIGFuaW0uZnJvbVZhbHVlcyA9IGFuaW0udmFsdWVzLm1hcChub2RlID0+IG5vZGUubGFzdFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQW5pbWF0aW5nKHRoaXMpKSB7XG4gICAgICBzZXRBY3RpdmVCaXQodGhpcywgdHJ1ZSk7XG5cbiAgICAgIGlmICghaXNQYXVzZWQodGhpcykpIHtcbiAgICAgICAgdGhpcy5fcmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3Jlc3VtZSgpIHtcbiAgICBpZiAoc2hhcmVkLkdsb2JhbHMuc2tpcEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5maW5pc2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcmVkLmZyYW1lTG9vcC5zdGFydCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBfc3RvcChnb2FsLCBjYW5jZWwpIHtcbiAgICBpZiAoaXNBbmltYXRpbmcodGhpcykpIHtcbiAgICAgIHNldEFjdGl2ZUJpdCh0aGlzLCBmYWxzZSk7XG4gICAgICBjb25zdCBhbmltID0gdGhpcy5hbmltYXRpb247XG4gICAgICBzaGFyZWQuZWFjaChhbmltLnZhbHVlcywgbm9kZSA9PiB7XG4gICAgICAgIG5vZGUuZG9uZSA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGFuaW0udG9WYWx1ZXMpIHtcbiAgICAgICAgYW5pbS5vbkNoYW5nZSA9IGFuaW0ub25QYXVzZSA9IGFuaW0ub25SZXN1bWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHNoYXJlZC5jYWxsRmx1aWRPYnNlcnZlcnModGhpcywge1xuICAgICAgICB0eXBlOiAnaWRsZScsXG4gICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBjYW5jZWwgPyBnZXRDYW5jZWxsZWRSZXN1bHQodGhpcy5nZXQoKSkgOiBnZXRGaW5pc2hlZFJlc3VsdCh0aGlzLmdldCgpLCBjaGVja0ZpbmlzaGVkKHRoaXMsIGdvYWwgIT0gbnVsbCA/IGdvYWwgOiBhbmltLnRvKSk7XG4gICAgICBzaGFyZWQuZmx1c2hDYWxscyh0aGlzLl9wZW5kaW5nQ2FsbHMsIHJlc3VsdCk7XG5cbiAgICAgIGlmIChhbmltLmNoYW5nZWQpIHtcbiAgICAgICAgYW5pbS5jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHNlbmRFdmVudCh0aGlzLCAnb25SZXN0JywgcmVzdWx0LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjaGVja0ZpbmlzaGVkKHRhcmdldCwgdG8pIHtcbiAgY29uc3QgZ29hbCA9IGNvbXB1dGVHb2FsKHRvKTtcbiAgY29uc3QgdmFsdWUgPSBjb21wdXRlR29hbCh0YXJnZXQuZ2V0KCkpO1xuICByZXR1cm4gc2hhcmVkLmlzRXF1YWwodmFsdWUsIGdvYWwpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb29wVXBkYXRlKHByb3BzLCBsb29wID0gcHJvcHMubG9vcCwgdG8gPSBwcm9wcy50bykge1xuICBsZXQgbG9vcFJldCA9IGNhbGxQcm9wKGxvb3ApO1xuXG4gIGlmIChsb29wUmV0KSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gbG9vcFJldCAhPT0gdHJ1ZSAmJiBpbmZlclRvKGxvb3BSZXQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSAob3ZlcnJpZGVzIHx8IHByb3BzKS5yZXZlcnNlO1xuICAgIGNvbnN0IHJlc2V0ID0gIW92ZXJyaWRlcyB8fCBvdmVycmlkZXMucmVzZXQ7XG4gICAgcmV0dXJuIGNyZWF0ZVVwZGF0ZShfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGxvb3AsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHBhdXNlOiB1bmRlZmluZWQsXG4gICAgICB0bzogIXJldmVyc2UgfHwgaXNBc3luY1RvKHRvKSA/IHRvIDogdW5kZWZpbmVkLFxuICAgICAgZnJvbTogcmVzZXQgPyBwcm9wcy5mcm9tIDogdW5kZWZpbmVkLFxuICAgICAgcmVzZXRcbiAgICB9LCBvdmVycmlkZXMpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICB0byxcbiAgICBmcm9tXG4gIH0gPSBwcm9wcyA9IGluZmVyVG8ocHJvcHMpO1xuICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICBpZiAoc2hhcmVkLmlzLm9iaih0bykpIGZpbmREZWZpbmVkKHRvLCBrZXlzKTtcbiAgaWYgKHNoYXJlZC5pcy5vYmooZnJvbSkpIGZpbmREZWZpbmVkKGZyb20sIGtleXMpO1xuICBwcm9wcy5rZXlzID0ga2V5cy5zaXplID8gQXJyYXkuZnJvbShrZXlzKSA6IG51bGw7XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGRlY2xhcmVVcGRhdGUocHJvcHMpIHtcbiAgY29uc3QgdXBkYXRlID0gY3JlYXRlVXBkYXRlKHByb3BzKTtcblxuICBpZiAoc2hhcmVkLmlzLnVuZCh1cGRhdGUuZGVmYXVsdCkpIHtcbiAgICB1cGRhdGUuZGVmYXVsdCA9IGdldERlZmF1bHRQcm9wcyh1cGRhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZmluZERlZmluZWQodmFsdWVzLCBrZXlzKSB7XG4gIHNoYXJlZC5lYWNoUHJvcCh2YWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB2YWx1ZSAhPSBudWxsICYmIGtleXMuYWRkKGtleSkpO1xufVxuXG5jb25zdCBBQ1RJVkVfRVZFTlRTID0gWydvblN0YXJ0JywgJ29uUmVzdCcsICdvbkNoYW5nZScsICdvblBhdXNlJywgJ29uUmVzdW1lJ107XG5cbmZ1bmN0aW9uIG1lcmdlQWN0aXZlRm4odGFyZ2V0LCBwcm9wcywgdHlwZSkge1xuICB0YXJnZXQuYW5pbWF0aW9uW3R5cGVdID0gcHJvcHNbdHlwZV0gIT09IGdldERlZmF1bHRQcm9wKHByb3BzLCB0eXBlKSA/IHJlc29sdmVQcm9wKHByb3BzW3R5cGVdLCB0YXJnZXQua2V5KSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2VuZEV2ZW50KHRhcmdldCwgdHlwZSwgLi4uYXJncykge1xuICB2YXIgX3RhcmdldCRhbmltYXRpb24kdHlwLCBfdGFyZ2V0JGFuaW1hdGlvbiwgX3RhcmdldCRkZWZhdWx0UHJvcHMkLCBfdGFyZ2V0JGRlZmF1bHRQcm9wcztcblxuICAoX3RhcmdldCRhbmltYXRpb24kdHlwID0gKF90YXJnZXQkYW5pbWF0aW9uID0gdGFyZ2V0LmFuaW1hdGlvbilbdHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0JGFuaW1hdGlvbiR0eXAuY2FsbChfdGFyZ2V0JGFuaW1hdGlvbiwgLi4uYXJncyk7XG4gIChfdGFyZ2V0JGRlZmF1bHRQcm9wcyQgPSAoX3RhcmdldCRkZWZhdWx0UHJvcHMgPSB0YXJnZXQuZGVmYXVsdFByb3BzKVt0eXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkZGVmYXVsdFByb3BzJC5jYWxsKF90YXJnZXQkZGVmYXVsdFByb3BzLCAuLi5hcmdzKTtcbn1cblxuY29uc3QgQkFUQ0hFRF9FVkVOVFMgPSBbJ29uU3RhcnQnLCAnb25DaGFuZ2UnLCAnb25SZXN0J107XG5sZXQgbmV4dElkID0gMTtcbmNsYXNzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcywgZmx1c2gpIHtcbiAgICB0aGlzLmlkID0gbmV4dElkKys7XG4gICAgdGhpcy5zcHJpbmdzID0ge307XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMucmVmID0gdm9pZCAwO1xuICAgIHRoaXMuX2ZsdXNoID0gdm9pZCAwO1xuICAgIHRoaXMuX2luaXRpYWxQcm9wcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9sYXN0QXN5bmNJZCA9IDA7XG4gICAgdGhpcy5fYWN0aXZlID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2l0ZW0gPSB2b2lkIDA7XG4gICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgcGF1c2VRdWV1ZTogbmV3IFNldCgpLFxuICAgICAgcmVzdW1lUXVldWU6IG5ldyBTZXQoKSxcbiAgICAgIHRpbWVvdXRzOiBuZXcgU2V0KClcbiAgICB9O1xuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIG9uU3RhcnQ6IG5ldyBNYXAoKSxcbiAgICAgIG9uQ2hhbmdlOiBuZXcgTWFwKCksXG4gICAgICBvblJlc3Q6IG5ldyBNYXAoKVxuICAgIH07XG4gICAgdGhpcy5fb25GcmFtZSA9IHRoaXMuX29uRnJhbWUuYmluZCh0aGlzKTtcblxuICAgIGlmIChmbHVzaCkge1xuICAgICAgdGhpcy5fZmx1c2ggPSBmbHVzaDtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIHRoaXMuc3RhcnQoX2V4dGVuZHMoe1xuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9LCBwcm9wcykpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpZGxlKCkge1xuICAgIHJldHVybiAhdGhpcy5fc3RhdGUuYXN5bmNUbyAmJiBPYmplY3QudmFsdWVzKHRoaXMuc3ByaW5ncykuZXZlcnkoc3ByaW5nID0+IHtcbiAgICAgIHJldHVybiBzcHJpbmcuaWRsZSAmJiAhc3ByaW5nLmlzRGVsYXllZCAmJiAhc3ByaW5nLmlzUGF1c2VkO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGl0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW07XG4gIH1cblxuICBzZXQgaXRlbShpdGVtKSB7XG4gICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gIH1cblxuICBnZXQoKSB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgdGhpcy5lYWNoKChzcHJpbmcsIGtleSkgPT4gdmFsdWVzW2tleV0gPSBzcHJpbmcuZ2V0KCkpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICBzZXQodmFsdWVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuXG4gICAgICBpZiAoIXNoYXJlZC5pcy51bmQodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc3ByaW5nc1trZXldLnNldCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goY3JlYXRlVXBkYXRlKHByb3BzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGFydChwcm9wcykge1xuICAgIGxldCB7XG4gICAgICBxdWV1ZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBxdWV1ZSA9IHNoYXJlZC50b0FycmF5KHByb3BzKS5tYXAoY3JlYXRlVXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mbHVzaCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZsdXNoKHRoaXMsIHF1ZXVlKTtcbiAgICB9XG5cbiAgICBwcmVwYXJlS2V5cyh0aGlzLCBxdWV1ZSk7XG4gICAgcmV0dXJuIGZsdXNoVXBkYXRlUXVldWUodGhpcywgcXVldWUpO1xuICB9XG5cbiAgc3RvcChhcmcsIGtleXMpIHtcbiAgICBpZiAoYXJnICE9PSAhIWFyZykge1xuICAgICAga2V5cyA9IGFyZztcbiAgICB9XG5cbiAgICBpZiAoa2V5cykge1xuICAgICAgY29uc3Qgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncztcbiAgICAgIHNoYXJlZC5lYWNoKHNoYXJlZC50b0FycmF5KGtleXMpLCBrZXkgPT4gc3ByaW5nc1trZXldLnN0b3AoISFhcmcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcEFzeW5jKHRoaXMuX3N0YXRlLCB0aGlzLl9sYXN0QXN5bmNJZCk7XG4gICAgICB0aGlzLmVhY2goc3ByaW5nID0+IHNwcmluZy5zdG9wKCEhYXJnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwYXVzZShrZXlzKSB7XG4gICAgaWYgKHNoYXJlZC5pcy51bmQoa2V5cykpIHtcbiAgICAgIHRoaXMuc3RhcnQoe1xuICAgICAgICBwYXVzZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNwcmluZ3MgPSB0aGlzLnNwcmluZ3M7XG4gICAgICBzaGFyZWQuZWFjaChzaGFyZWQudG9BcnJheShrZXlzKSwga2V5ID0+IHNwcmluZ3Nba2V5XS5wYXVzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlc3VtZShrZXlzKSB7XG4gICAgaWYgKHNoYXJlZC5pcy51bmQoa2V5cykpIHtcbiAgICAgIHRoaXMuc3RhcnQoe1xuICAgICAgICBwYXVzZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzcHJpbmdzID0gdGhpcy5zcHJpbmdzO1xuICAgICAgc2hhcmVkLmVhY2goc2hhcmVkLnRvQXJyYXkoa2V5cyksIGtleSA9PiBzcHJpbmdzW2tleV0ucmVzdW1lKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZWFjaChpdGVyYXRvcikge1xuICAgIHNoYXJlZC5lYWNoUHJvcCh0aGlzLnNwcmluZ3MsIGl0ZXJhdG9yKTtcbiAgfVxuXG4gIF9vbkZyYW1lKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uU3RhcnQsXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIG9uUmVzdFxuICAgIH0gPSB0aGlzLl9ldmVudHM7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlLnNpemUgPiAwO1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9jaGFuZ2VkLnNpemUgPiAwO1xuXG4gICAgaWYgKGFjdGl2ZSAmJiAhdGhpcy5fc3RhcnRlZCB8fCBjaGFuZ2VkICYmICF0aGlzLl9zdGFydGVkKSB7XG4gICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHNoYXJlZC5mbHVzaChvblN0YXJ0LCAoW29uU3RhcnQsIHJlc3VsdF0pID0+IHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgb25TdGFydChyZXN1bHQsIHRoaXMsIHRoaXMuX2l0ZW0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaWRsZSA9ICFhY3RpdmUgJiYgdGhpcy5fc3RhcnRlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBjaGFuZ2VkIHx8IGlkbGUgJiYgb25SZXN0LnNpemUgPyB0aGlzLmdldCgpIDogbnVsbDtcblxuICAgIGlmIChjaGFuZ2VkICYmIG9uQ2hhbmdlLnNpemUpIHtcbiAgICAgIHNoYXJlZC5mbHVzaChvbkNoYW5nZSwgKFtvbkNoYW5nZSwgcmVzdWx0XSkgPT4ge1xuICAgICAgICByZXN1bHQudmFsdWUgPSB2YWx1ZXM7XG4gICAgICAgIG9uQ2hhbmdlKHJlc3VsdCwgdGhpcywgdGhpcy5faXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaWRsZSkge1xuICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgc2hhcmVkLmZsdXNoKG9uUmVzdCwgKFtvblJlc3QsIHJlc3VsdF0pID0+IHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gdmFsdWVzO1xuICAgICAgICBvblJlc3QocmVzdWx0LCB0aGlzLCB0aGlzLl9pdGVtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2ZW50T2JzZXJ2ZWQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PSAnY2hhbmdlJykge1xuICAgICAgdGhpcy5fY2hhbmdlZC5hZGQoZXZlbnQucGFyZW50KTtcblxuICAgICAgaWYgKCFldmVudC5pZGxlKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZS5hZGQoZXZlbnQucGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT0gJ2lkbGUnKSB7XG4gICAgICB0aGlzLl9hY3RpdmUuZGVsZXRlKGV2ZW50LnBhcmVudCk7XG4gICAgfSBlbHNlIHJldHVybjtcblxuICAgIHNoYXJlZC5yYWYub25GcmFtZSh0aGlzLl9vbkZyYW1lKTtcbiAgfVxuXG59XG5mdW5jdGlvbiBmbHVzaFVwZGF0ZVF1ZXVlKGN0cmwsIHF1ZXVlKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChxdWV1ZS5tYXAocHJvcHMgPT4gZmx1c2hVcGRhdGUoY3RybCwgcHJvcHMpKSkudGhlbihyZXN1bHRzID0+IGdldENvbWJpbmVkUmVzdWx0KGN0cmwsIHJlc3VsdHMpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZsdXNoVXBkYXRlKGN0cmwsIHByb3BzLCBpc0xvb3ApIHtcbiAgY29uc3Qge1xuICAgIGtleXMsXG4gICAgdG8sXG4gICAgZnJvbSxcbiAgICBsb29wLFxuICAgIG9uUmVzdCxcbiAgICBvblJlc29sdmVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBkZWZhdWx0cyA9IHNoYXJlZC5pcy5vYmoocHJvcHMuZGVmYXVsdCkgJiYgcHJvcHMuZGVmYXVsdDtcblxuICBpZiAobG9vcCkge1xuICAgIHByb3BzLmxvb3AgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0byA9PT0gZmFsc2UpIHByb3BzLnRvID0gbnVsbDtcbiAgaWYgKGZyb20gPT09IGZhbHNlKSBwcm9wcy5mcm9tID0gbnVsbDtcbiAgY29uc3QgYXN5bmNUbyA9IHNoYXJlZC5pcy5hcnIodG8pIHx8IHNoYXJlZC5pcy5mdW4odG8pID8gdG8gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGFzeW5jVG8pIHtcbiAgICBwcm9wcy50byA9IHVuZGVmaW5lZDtcbiAgICBwcm9wcy5vblJlc3QgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZGVmYXVsdHMpIHtcbiAgICAgIGRlZmF1bHRzLm9uUmVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkLmVhY2goQkFUQ0hFRF9FVkVOVFMsIGtleSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcHJvcHNba2V5XTtcblxuICAgICAgaWYgKHNoYXJlZC5pcy5mdW4oaGFuZGxlcikpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBjdHJsWydfZXZlbnRzJ11ba2V5XTtcblxuICAgICAgICBwcm9wc1trZXldID0gKHtcbiAgICAgICAgICBmaW5pc2hlZCxcbiAgICAgICAgICBjYW5jZWxsZWRcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHF1ZXVlLmdldChoYW5kbGVyKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghZmluaXNoZWQpIHJlc3VsdC5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmVzdWx0LmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChoYW5kbGVyLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICBmaW5pc2hlZDogZmluaXNoZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIGNhbmNlbGxlZDogY2FuY2VsbGVkIHx8IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICAgICAgZGVmYXVsdHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gY3RybFsnX3N0YXRlJ107XG5cbiAgaWYgKHByb3BzLnBhdXNlID09PSAhc3RhdGUucGF1c2VkKSB7XG4gICAgc3RhdGUucGF1c2VkID0gcHJvcHMucGF1c2U7XG4gICAgc2hhcmVkLmZsdXNoQ2FsbHMocHJvcHMucGF1c2UgPyBzdGF0ZS5wYXVzZVF1ZXVlIDogc3RhdGUucmVzdW1lUXVldWUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnBhdXNlZCkge1xuICAgIHByb3BzLnBhdXNlID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHByb21pc2VzID0gKGtleXMgfHwgT2JqZWN0LmtleXMoY3RybC5zcHJpbmdzKSkubWFwKGtleSA9PiBjdHJsLnNwcmluZ3Nba2V5XS5zdGFydChwcm9wcykpO1xuICBjb25zdCBjYW5jZWwgPSBwcm9wcy5jYW5jZWwgPT09IHRydWUgfHwgZ2V0RGVmYXVsdFByb3AocHJvcHMsICdjYW5jZWwnKSA9PT0gdHJ1ZTtcblxuICBpZiAoYXN5bmNUbyB8fCBjYW5jZWwgJiYgc3RhdGUuYXN5bmNJZCkge1xuICAgIHByb21pc2VzLnB1c2goc2NoZWR1bGVQcm9wcygrK2N0cmxbJ19sYXN0QXN5bmNJZCddLCB7XG4gICAgICBwcm9wcyxcbiAgICAgIHN0YXRlLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBwYXVzZTogc2hhcmVkLm5vb3AsXG4gICAgICAgIHJlc3VtZTogc2hhcmVkLm5vb3AsXG5cbiAgICAgICAgc3RhcnQocHJvcHMsIHJlc29sdmUpIHtcbiAgICAgICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgICAgICBzdG9wQXN5bmMoc3RhdGUsIGN0cmxbJ19sYXN0QXN5bmNJZCddKTtcbiAgICAgICAgICAgIHJlc29sdmUoZ2V0Q2FuY2VsbGVkUmVzdWx0KGN0cmwpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMub25SZXN0ID0gb25SZXN0O1xuICAgICAgICAgICAgcmVzb2x2ZShydW5Bc3luYyhhc3luY1RvLCBwcm9wcywgc3RhdGUsIGN0cmwpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wYXVzZWQpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXN1bWUgPT4ge1xuICAgICAgc3RhdGUucmVzdW1lUXVldWUuYWRkKHJlc3VtZSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBnZXRDb21iaW5lZFJlc3VsdChjdHJsLCBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcykpO1xuXG4gIGlmIChsb29wICYmIHJlc3VsdC5maW5pc2hlZCAmJiAhKGlzTG9vcCAmJiByZXN1bHQubm9vcCkpIHtcbiAgICBjb25zdCBuZXh0UHJvcHMgPSBjcmVhdGVMb29wVXBkYXRlKHByb3BzLCBsb29wLCB0byk7XG5cbiAgICBpZiAobmV4dFByb3BzKSB7XG4gICAgICBwcmVwYXJlS2V5cyhjdHJsLCBbbmV4dFByb3BzXSk7XG4gICAgICByZXR1cm4gZmx1c2hVcGRhdGUoY3RybCwgbmV4dFByb3BzLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAob25SZXNvbHZlKSB7XG4gICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiBvblJlc29sdmUocmVzdWx0LCBjdHJsLCBjdHJsLml0ZW0pKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRTcHJpbmdzKGN0cmwsIHByb3BzKSB7XG4gIGNvbnN0IHNwcmluZ3MgPSBfZXh0ZW5kcyh7fSwgY3RybC5zcHJpbmdzKTtcblxuICBpZiAocHJvcHMpIHtcbiAgICBzaGFyZWQuZWFjaChzaGFyZWQudG9BcnJheShwcm9wcyksIHByb3BzID0+IHtcbiAgICAgIGlmIChzaGFyZWQuaXMudW5kKHByb3BzLmtleXMpKSB7XG4gICAgICAgIHByb3BzID0gY3JlYXRlVXBkYXRlKHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaGFyZWQuaXMub2JqKHByb3BzLnRvKSkge1xuICAgICAgICBwcm9wcyA9IF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICAgIHRvOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByZXBhcmVTcHJpbmdzKHNwcmluZ3MsIHByb3BzLCBrZXkgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlU3ByaW5nKGtleSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldFNwcmluZ3MoY3RybCwgc3ByaW5ncyk7XG4gIHJldHVybiBzcHJpbmdzO1xufVxuZnVuY3Rpb24gc2V0U3ByaW5ncyhjdHJsLCBzcHJpbmdzKSB7XG4gIHNoYXJlZC5lYWNoUHJvcChzcHJpbmdzLCAoc3ByaW5nLCBrZXkpID0+IHtcbiAgICBpZiAoIWN0cmwuc3ByaW5nc1trZXldKSB7XG4gICAgICBjdHJsLnNwcmluZ3Nba2V5XSA9IHNwcmluZztcbiAgICAgIHNoYXJlZC5hZGRGbHVpZE9ic2VydmVyKHNwcmluZywgY3RybCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ByaW5nKGtleSwgb2JzZXJ2ZXIpIHtcbiAgY29uc3Qgc3ByaW5nID0gbmV3IFNwcmluZ1ZhbHVlKCk7XG4gIHNwcmluZy5rZXkgPSBrZXk7XG5cbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgc2hhcmVkLmFkZEZsdWlkT2JzZXJ2ZXIoc3ByaW5nLCBvYnNlcnZlcik7XG4gIH1cblxuICByZXR1cm4gc3ByaW5nO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlU3ByaW5ncyhzcHJpbmdzLCBwcm9wcywgY3JlYXRlKSB7XG4gIGlmIChwcm9wcy5rZXlzKSB7XG4gICAgc2hhcmVkLmVhY2gocHJvcHMua2V5cywga2V5ID0+IHtcbiAgICAgIGNvbnN0IHNwcmluZyA9IHNwcmluZ3Nba2V5XSB8fCAoc3ByaW5nc1trZXldID0gY3JlYXRlKGtleSkpO1xuICAgICAgc3ByaW5nWydfcHJlcGFyZU5vZGUnXShwcm9wcyk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZUtleXMoY3RybCwgcXVldWUpIHtcbiAgc2hhcmVkLmVhY2gocXVldWUsIHByb3BzID0+IHtcbiAgICBwcmVwYXJlU3ByaW5ncyhjdHJsLnNwcmluZ3MsIHByb3BzLCBrZXkgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNwcmluZyhrZXksIGN0cmwpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmNvbnN0IF9leGNsdWRlZCQ2ID0gW1wiY2hpbGRyZW5cIl07XG5jb25zdCBTcHJpbmdDb250ZXh0ID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWYsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQ2KTtcblxuICBjb25zdCBpbmhlcml0ZWQgPSBSZWFjdC51c2VDb250ZXh0KGN0eCk7XG4gIGNvbnN0IHBhdXNlID0gcHJvcHMucGF1c2UgfHwgISFpbmhlcml0ZWQucGF1c2UsXG4gICAgICAgIGltbWVkaWF0ZSA9IHByb3BzLmltbWVkaWF0ZSB8fCAhIWluaGVyaXRlZC5pbW1lZGlhdGU7XG4gIHByb3BzID0gc2hhcmVkLnVzZU1lbW9PbmUoKCkgPT4gKHtcbiAgICBwYXVzZSxcbiAgICBpbW1lZGlhdGVcbiAgfSksIFtwYXVzZSwgaW1tZWRpYXRlXSk7XG4gIGNvbnN0IHtcbiAgICBQcm92aWRlclxuICB9ID0gY3R4O1xuICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHByb3BzXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBjdHggPSBtYWtlQ29udGV4dChTcHJpbmdDb250ZXh0LCB7fSk7XG5TcHJpbmdDb250ZXh0LlByb3ZpZGVyID0gY3R4LlByb3ZpZGVyO1xuU3ByaW5nQ29udGV4dC5Db25zdW1lciA9IGN0eC5Db25zdW1lcjtcblxuZnVuY3Rpb24gbWFrZUNvbnRleHQodGFyZ2V0LCBpbml0KSB7XG4gIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQoaW5pdCkpO1xuICB0YXJnZXQuUHJvdmlkZXIuX2NvbnRleHQgPSB0YXJnZXQ7XG4gIHRhcmdldC5Db25zdW1lci5fY29udGV4dCA9IHRhcmdldDtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuY29uc3QgU3ByaW5nUmVmID0gKCkgPT4ge1xuICBjb25zdCBjdXJyZW50ID0gW107XG5cbiAgY29uc3QgU3ByaW5nUmVmID0gZnVuY3Rpb24gU3ByaW5nUmVmKHByb3BzKSB7XG4gICAgc2hhcmVkLmRlcHJlY2F0ZURpcmVjdENhbGwoKTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgc2hhcmVkLmVhY2goY3VycmVudCwgKGN0cmwsIGkpID0+IHtcbiAgICAgIGlmIChzaGFyZWQuaXMudW5kKHByb3BzKSkge1xuICAgICAgICByZXN1bHRzLnB1c2goY3RybC5zdGFydCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IF9nZXRQcm9wcyhwcm9wcywgY3RybCwgaSk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChjdHJsLnN0YXJ0KHVwZGF0ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgU3ByaW5nUmVmLmN1cnJlbnQgPSBjdXJyZW50O1xuXG4gIFNwcmluZ1JlZi5hZGQgPSBmdW5jdGlvbiAoY3RybCkge1xuICAgIGlmICghY3VycmVudC5pbmNsdWRlcyhjdHJsKSkge1xuICAgICAgY3VycmVudC5wdXNoKGN0cmwpO1xuICAgIH1cbiAgfTtcblxuICBTcHJpbmdSZWYuZGVsZXRlID0gZnVuY3Rpb24gKGN0cmwpIHtcbiAgICBjb25zdCBpID0gY3VycmVudC5pbmRleE9mKGN0cmwpO1xuICAgIGlmICh+aSkgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gIH07XG5cbiAgU3ByaW5nUmVmLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHNoYXJlZC5lYWNoKGN1cnJlbnQsIGN0cmwgPT4gY3RybC5wYXVzZSguLi5hcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTcHJpbmdSZWYucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHNoYXJlZC5lYWNoKGN1cnJlbnQsIGN0cmwgPT4gY3RybC5yZXN1bWUoLi4uYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU3ByaW5nUmVmLnNldCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBzaGFyZWQuZWFjaChjdXJyZW50LCBjdHJsID0+IGN0cmwuc2V0KHZhbHVlcykpO1xuICB9O1xuXG4gIFNwcmluZ1JlZi5zdGFydCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBzaGFyZWQuZWFjaChjdXJyZW50LCAoY3RybCwgaSkgPT4ge1xuICAgICAgaWYgKHNoYXJlZC5pcy51bmQocHJvcHMpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChjdHJsLnN0YXJ0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gdGhpcy5fZ2V0UHJvcHMocHJvcHMsIGN0cmwsIGkpO1xuXG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goY3RybC5zdGFydCh1cGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIFNwcmluZ1JlZi5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHNoYXJlZC5lYWNoKGN1cnJlbnQsIGN0cmwgPT4gY3RybC5zdG9wKC4uLmFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFNwcmluZ1JlZi51cGRhdGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBzaGFyZWQuZWFjaChjdXJyZW50LCAoY3RybCwgaSkgPT4gY3RybC51cGRhdGUodGhpcy5fZ2V0UHJvcHMocHJvcHMsIGN0cmwsIGkpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgY29uc3QgX2dldFByb3BzID0gZnVuY3Rpb24gX2dldFByb3BzKGFyZywgY3RybCwgaW5kZXgpIHtcbiAgICByZXR1cm4gc2hhcmVkLmlzLmZ1bihhcmcpID8gYXJnKGluZGV4LCBjdHJsKSA6IGFyZztcbiAgfTtcblxuICBTcHJpbmdSZWYuX2dldFByb3BzID0gX2dldFByb3BzO1xuICByZXR1cm4gU3ByaW5nUmVmO1xufTtcblxuZnVuY3Rpb24gdXNlU3ByaW5ncyhsZW5ndGgsIHByb3BzLCBkZXBzKSB7XG4gIGNvbnN0IHByb3BzRm4gPSBzaGFyZWQuaXMuZnVuKHByb3BzKSAmJiBwcm9wcztcbiAgaWYgKHByb3BzRm4gJiYgIWRlcHMpIGRlcHMgPSBbXTtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlTWVtbygoKSA9PiBwcm9wc0ZuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMyA/IFNwcmluZ1JlZigpIDogdm9pZCAwLCBbXSk7XG4gIGNvbnN0IGxheW91dElkID0gUmVhY3QudXNlUmVmKDApO1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHNoYXJlZC51c2VGb3JjZVVwZGF0ZSgpO1xuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBjdHJsczogW10sXG4gICAgcXVldWU6IFtdLFxuXG4gICAgZmx1c2goY3RybCwgdXBkYXRlcykge1xuICAgICAgY29uc3Qgc3ByaW5ncyA9IGdldFNwcmluZ3MoY3RybCwgdXBkYXRlcyk7XG4gICAgICBjb25zdCBjYW5GbHVzaFN5bmMgPSBsYXlvdXRJZC5jdXJyZW50ID4gMCAmJiAhc3RhdGUucXVldWUubGVuZ3RoICYmICFPYmplY3Qua2V5cyhzcHJpbmdzKS5zb21lKGtleSA9PiAhY3RybC5zcHJpbmdzW2tleV0pO1xuICAgICAgcmV0dXJuIGNhbkZsdXNoU3luYyA/IGZsdXNoVXBkYXRlUXVldWUoY3RybCwgdXBkYXRlcykgOiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgc2V0U3ByaW5ncyhjdHJsLCBzcHJpbmdzKTtcbiAgICAgICAgc3RhdGUucXVldWUucHVzaCgoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShmbHVzaFVwZGF0ZVF1ZXVlKGN0cmwsIHVwZGF0ZXMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSksIFtdKTtcbiAgY29uc3QgY3RybHMgPSBSZWFjdC51c2VSZWYoWy4uLnN0YXRlLmN0cmxzXSk7XG4gIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgY29uc3QgcHJldkxlbmd0aCA9IHNoYXJlZC51c2VQcmV2KGxlbmd0aCkgfHwgMDtcbiAgUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgc2hhcmVkLmVhY2goY3RybHMuY3VycmVudC5zbGljZShsZW5ndGgsIHByZXZMZW5ndGgpLCBjdHJsID0+IHtcbiAgICAgIGRldGFjaFJlZnMoY3RybCwgcmVmKTtcbiAgICAgIGN0cmwuc3RvcCh0cnVlKTtcbiAgICB9KTtcbiAgICBjdHJscy5jdXJyZW50Lmxlbmd0aCA9IGxlbmd0aDtcbiAgICBkZWNsYXJlVXBkYXRlcyhwcmV2TGVuZ3RoLCBsZW5ndGgpO1xuICB9LCBbbGVuZ3RoXSk7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGRlY2xhcmVVcGRhdGVzKDAsIE1hdGgubWluKHByZXZMZW5ndGgsIGxlbmd0aCkpO1xuICB9LCBkZXBzKTtcblxuICBmdW5jdGlvbiBkZWNsYXJlVXBkYXRlcyhzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgY3RybCA9IGN0cmxzLmN1cnJlbnRbaV0gfHwgKGN0cmxzLmN1cnJlbnRbaV0gPSBuZXcgQ29udHJvbGxlcihudWxsLCBzdGF0ZS5mbHVzaCkpO1xuICAgICAgY29uc3QgdXBkYXRlID0gcHJvcHNGbiA/IHByb3BzRm4oaSwgY3RybCkgOiBwcm9wc1tpXTtcblxuICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICB1cGRhdGVzW2ldID0gZGVjbGFyZVVwZGF0ZSh1cGRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNwcmluZ3MgPSBjdHJscy5jdXJyZW50Lm1hcCgoY3RybCwgaSkgPT4gZ2V0U3ByaW5ncyhjdHJsLCB1cGRhdGVzW2ldKSk7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFNwcmluZ0NvbnRleHQpO1xuICBjb25zdCBwcmV2Q29udGV4dCA9IHNoYXJlZC51c2VQcmV2KGNvbnRleHQpO1xuICBjb25zdCBoYXNDb250ZXh0ID0gY29udGV4dCAhPT0gcHJldkNvbnRleHQgJiYgaGFzUHJvcHMoY29udGV4dCk7XG4gIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBsYXlvdXRJZC5jdXJyZW50Kys7XG4gICAgc3RhdGUuY3RybHMgPSBjdHJscy5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIHF1ZXVlXG4gICAgfSA9IHN0YXRlO1xuXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgc3RhdGUucXVldWUgPSBbXTtcbiAgICAgIHNoYXJlZC5lYWNoKHF1ZXVlLCBjYiA9PiBjYigpKTtcbiAgICB9XG5cbiAgICBzaGFyZWQuZWFjaChjdHJscy5jdXJyZW50LCAoY3RybCwgaSkgPT4ge1xuICAgICAgcmVmID09IG51bGwgPyB2b2lkIDAgOiByZWYuYWRkKGN0cmwpO1xuXG4gICAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgICBjdHJsLnN0YXJ0KHtcbiAgICAgICAgICBkZWZhdWx0OiBjb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuXG4gICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgIHJlcGxhY2VSZWYoY3RybCwgdXBkYXRlLnJlZik7XG5cbiAgICAgICAgaWYgKGN0cmwucmVmKSB7XG4gICAgICAgICAgY3RybC5xdWV1ZS5wdXNoKHVwZGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3RybC5zdGFydCh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBzaGFyZWQudXNlT25jZSgoKSA9PiAoKSA9PiB7XG4gICAgc2hhcmVkLmVhY2goc3RhdGUuY3RybHMsIGN0cmwgPT4gY3RybC5zdG9wKHRydWUpKTtcbiAgfSk7XG4gIGNvbnN0IHZhbHVlcyA9IHNwcmluZ3MubWFwKHggPT4gX2V4dGVuZHMoe30sIHgpKTtcbiAgcmV0dXJuIHJlZiA/IFt2YWx1ZXMsIHJlZl0gOiB2YWx1ZXM7XG59XG5cbmZ1bmN0aW9uIHVzZVNwcmluZyhwcm9wcywgZGVwcykge1xuICBjb25zdCBpc0ZuID0gc2hhcmVkLmlzLmZ1bihwcm9wcyk7XG4gIGNvbnN0IFtbdmFsdWVzXSwgcmVmXSA9IHVzZVNwcmluZ3MoMSwgaXNGbiA/IHByb3BzIDogW3Byb3BzXSwgaXNGbiA/IGRlcHMgfHwgW10gOiBkZXBzKTtcbiAgcmV0dXJuIGlzRm4gfHwgYXJndW1lbnRzLmxlbmd0aCA9PSAyID8gW3ZhbHVlcywgcmVmXSA6IHZhbHVlcztcbn1cblxuY29uc3QgaW5pdFNwcmluZ1JlZiA9ICgpID0+IFNwcmluZ1JlZigpO1xuXG5jb25zdCB1c2VTcHJpbmdSZWYgPSAoKSA9PiBSZWFjdC51c2VTdGF0ZShpbml0U3ByaW5nUmVmKVswXTtcblxuY29uc3QgdXNlU3ByaW5nVmFsdWUgPSAoaW5pdGlhbCwgcHJvcHMpID0+IHtcbiAgY29uc3Qgc3ByaW5nVmFsdWUgPSBzaGFyZWQudXNlQ29uc3RhbnQoKCkgPT4gbmV3IFNwcmluZ1ZhbHVlKGluaXRpYWwsIHByb3BzKSk7XG4gIHNoYXJlZC51c2VPbmNlKCgpID0+ICgpID0+IHtcbiAgICBzcHJpbmdWYWx1ZS5zdG9wKCk7XG4gIH0pO1xuICByZXR1cm4gc3ByaW5nVmFsdWU7XG59O1xuXG5mdW5jdGlvbiB1c2VUcmFpbChsZW5ndGgsIHByb3BzQXJnLCBkZXBzKSB7XG4gIGNvbnN0IHByb3BzRm4gPSBzaGFyZWQuaXMuZnVuKHByb3BzQXJnKSAmJiBwcm9wc0FyZztcbiAgaWYgKHByb3BzRm4gJiYgIWRlcHMpIGRlcHMgPSBbXTtcbiAgbGV0IHJldmVyc2UgPSB0cnVlO1xuICBsZXQgcGFzc2VkUmVmID0gdW5kZWZpbmVkO1xuICBjb25zdCByZXN1bHQgPSB1c2VTcHJpbmdzKGxlbmd0aCwgKGksIGN0cmwpID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IHByb3BzRm4gPyBwcm9wc0ZuKGksIGN0cmwpIDogcHJvcHNBcmc7XG4gICAgcGFzc2VkUmVmID0gcHJvcHMucmVmO1xuICAgIHJldmVyc2UgPSByZXZlcnNlICYmIHByb3BzLnJldmVyc2U7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9LCBkZXBzIHx8IFt7fV0pO1xuICBzaGFyZWQudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2hhcmVkLmVhY2gocmVzdWx0WzFdLmN1cnJlbnQsIChjdHJsLCBpKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSByZXN1bHRbMV0uY3VycmVudFtpICsgKHJldmVyc2UgPyAxIDogLTEpXTtcbiAgICAgIHJlcGxhY2VSZWYoY3RybCwgcGFzc2VkUmVmKTtcblxuICAgICAgaWYgKGN0cmwucmVmKSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBjdHJsLnVwZGF0ZSh7XG4gICAgICAgICAgICB0bzogcGFyZW50LnNwcmluZ3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBjdHJsLnN0YXJ0KHtcbiAgICAgICAgICB0bzogcGFyZW50LnNwcmluZ3NcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHJsLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGRlcHMpO1xuXG4gIGlmIChwcm9wc0ZuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xuICAgIHZhciBfcGFzc2VkUmVmO1xuXG4gICAgY29uc3QgcmVmID0gKF9wYXNzZWRSZWYgPSBwYXNzZWRSZWYpICE9IG51bGwgPyBfcGFzc2VkUmVmIDogcmVzdWx0WzFdO1xuXG4gICAgcmVmWydfZ2V0UHJvcHMnXSA9IChwcm9wc0FyZywgY3RybCwgaSkgPT4ge1xuICAgICAgY29uc3QgcHJvcHMgPSBzaGFyZWQuaXMuZnVuKHByb3BzQXJnKSA/IHByb3BzQXJnKGksIGN0cmwpIDogcHJvcHNBcmc7XG5cbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSByZWYuY3VycmVudFtpICsgKHByb3BzLnJldmVyc2UgPyAxIDogLTEpXTtcbiAgICAgICAgaWYgKHBhcmVudCkgcHJvcHMudG8gPSBwYXJlbnQuc3ByaW5ncztcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFswXTtcbn1cblxubGV0IFRyYW5zaXRpb25QaGFzZTtcblxuKGZ1bmN0aW9uIChUcmFuc2l0aW9uUGhhc2UpIHtcbiAgVHJhbnNpdGlvblBoYXNlW1wiTU9VTlRcIl0gPSBcIm1vdW50XCI7XG4gIFRyYW5zaXRpb25QaGFzZVtcIkVOVEVSXCJdID0gXCJlbnRlclwiO1xuICBUcmFuc2l0aW9uUGhhc2VbXCJVUERBVEVcIl0gPSBcInVwZGF0ZVwiO1xuICBUcmFuc2l0aW9uUGhhc2VbXCJMRUFWRVwiXSA9IFwibGVhdmVcIjtcbn0pKFRyYW5zaXRpb25QaGFzZSB8fCAoVHJhbnNpdGlvblBoYXNlID0ge30pKTtcblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbihkYXRhLCBwcm9wcywgZGVwcykge1xuICBjb25zdCBwcm9wc0ZuID0gc2hhcmVkLmlzLmZ1bihwcm9wcykgJiYgcHJvcHM7XG4gIGNvbnN0IHtcbiAgICByZXNldCxcbiAgICBzb3J0LFxuICAgIHRyYWlsID0gMCxcbiAgICBleHBpcmVzID0gdHJ1ZSxcbiAgICBleGl0QmVmb3JlRW50ZXIgPSBmYWxzZSxcbiAgICBvbkRlc3Ryb3llZCxcbiAgICByZWY6IHByb3BzUmVmLFxuICAgIGNvbmZpZzogcHJvcHNDb25maWdcbiAgfSA9IHByb3BzRm4gPyBwcm9wc0ZuKCkgOiBwcm9wcztcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlTWVtbygoKSA9PiBwcm9wc0ZuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMyA/IFNwcmluZ1JlZigpIDogdm9pZCAwLCBbXSk7XG4gIGNvbnN0IGl0ZW1zID0gc2hhcmVkLnRvQXJyYXkoZGF0YSk7XG4gIGNvbnN0IHRyYW5zaXRpb25zID0gW107XG4gIGNvbnN0IHVzZWRUcmFuc2l0aW9ucyA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgcHJldlRyYW5zaXRpb25zID0gcmVzZXQgPyBudWxsIDogdXNlZFRyYW5zaXRpb25zLmN1cnJlbnQ7XG4gIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB1c2VkVHJhbnNpdGlvbnMuY3VycmVudCA9IHRyYW5zaXRpb25zO1xuICB9KTtcbiAgc2hhcmVkLnVzZU9uY2UoKCkgPT4ge1xuICAgIHNoYXJlZC5lYWNoKHRyYW5zaXRpb25zLCB0ID0+IHtcbiAgICAgIHJlZiA9PSBudWxsID8gdm9pZCAwIDogcmVmLmFkZCh0LmN0cmwpO1xuICAgICAgdC5jdHJsLnJlZiA9IHJlZjtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2hhcmVkLmVhY2godXNlZFRyYW5zaXRpb25zLmN1cnJlbnQsIHQgPT4ge1xuICAgICAgICBpZiAodC5leHBpcmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHQuZXhwaXJhdGlvbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGFjaFJlZnModC5jdHJsLCByZWYpO1xuICAgICAgICB0LmN0cmwuc3RvcCh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuICBjb25zdCBrZXlzID0gZ2V0S2V5cyhpdGVtcywgcHJvcHNGbiA/IHByb3BzRm4oKSA6IHByb3BzLCBwcmV2VHJhbnNpdGlvbnMpO1xuICBjb25zdCBleHBpcmVkID0gcmVzZXQgJiYgdXNlZFRyYW5zaXRpb25zLmN1cnJlbnQgfHwgW107XG4gIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHNoYXJlZC5lYWNoKGV4cGlyZWQsICh7XG4gICAgY3RybCxcbiAgICBpdGVtLFxuICAgIGtleVxuICB9KSA9PiB7XG4gICAgZGV0YWNoUmVmcyhjdHJsLCByZWYpO1xuICAgIGNhbGxQcm9wKG9uRGVzdHJveWVkLCBpdGVtLCBrZXkpO1xuICB9KSk7XG4gIGNvbnN0IHJldXNlZCA9IFtdO1xuICBpZiAocHJldlRyYW5zaXRpb25zKSBzaGFyZWQuZWFjaChwcmV2VHJhbnNpdGlvbnMsICh0LCBpKSA9PiB7XG4gICAgaWYgKHQuZXhwaXJlZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHQuZXhwaXJhdGlvbklkKTtcbiAgICAgIGV4cGlyZWQucHVzaCh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IHJldXNlZFtpXSA9IGtleXMuaW5kZXhPZih0LmtleSk7XG4gICAgICBpZiAofmkpIHRyYW5zaXRpb25zW2ldID0gdDtcbiAgICB9XG4gIH0pO1xuICBzaGFyZWQuZWFjaChpdGVtcywgKGl0ZW0sIGkpID0+IHtcbiAgICBpZiAoIXRyYW5zaXRpb25zW2ldKSB7XG4gICAgICB0cmFuc2l0aW9uc1tpXSA9IHtcbiAgICAgICAga2V5OiBrZXlzW2ldLFxuICAgICAgICBpdGVtLFxuICAgICAgICBwaGFzZTogVHJhbnNpdGlvblBoYXNlLk1PVU5ULFxuICAgICAgICBjdHJsOiBuZXcgQ29udHJvbGxlcigpXG4gICAgICB9O1xuICAgICAgdHJhbnNpdGlvbnNbaV0uY3RybC5pdGVtID0gaXRlbTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChyZXVzZWQubGVuZ3RoKSB7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBjb25zdCB7XG4gICAgICBsZWF2ZVxuICAgIH0gPSBwcm9wc0ZuID8gcHJvcHNGbigpIDogcHJvcHM7XG4gICAgc2hhcmVkLmVhY2gocmV1c2VkLCAoa2V5SW5kZXgsIHByZXZJbmRleCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHByZXZUcmFuc2l0aW9uc1twcmV2SW5kZXhdO1xuXG4gICAgICBpZiAofmtleUluZGV4KSB7XG4gICAgICAgIGkgPSB0cmFuc2l0aW9ucy5pbmRleE9mKHQpO1xuICAgICAgICB0cmFuc2l0aW9uc1tpXSA9IF9leHRlbmRzKHt9LCB0LCB7XG4gICAgICAgICAgaXRlbTogaXRlbXNba2V5SW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChsZWF2ZSkge1xuICAgICAgICB0cmFuc2l0aW9ucy5zcGxpY2UoKytpLCAwLCB0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzaGFyZWQuaXMuZnVuKHNvcnQpKSB7XG4gICAgdHJhbnNpdGlvbnMuc29ydCgoYSwgYikgPT4gc29ydChhLml0ZW0sIGIuaXRlbSkpO1xuICB9XG5cbiAgbGV0IGRlbGF5ID0gLXRyYWlsO1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHNoYXJlZC51c2VGb3JjZVVwZGF0ZSgpO1xuICBjb25zdCBkZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHMocHJvcHMpO1xuICBjb25zdCBjaGFuZ2VzID0gbmV3IE1hcCgpO1xuICBjb25zdCBleGl0aW5nVHJhbnNpdGlvbnMgPSBSZWFjdC51c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgZm9yY2VDaGFuZ2UgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBzaGFyZWQuZWFjaCh0cmFuc2l0aW9ucywgKHQsIGkpID0+IHtcbiAgICBjb25zdCBrZXkgPSB0LmtleTtcbiAgICBjb25zdCBwcmV2UGhhc2UgPSB0LnBoYXNlO1xuICAgIGNvbnN0IHAgPSBwcm9wc0ZuID8gcHJvcHNGbigpIDogcHJvcHM7XG4gICAgbGV0IHRvO1xuICAgIGxldCBwaGFzZTtcbiAgICBsZXQgcHJvcHNEZWxheSA9IGNhbGxQcm9wKHAuZGVsYXkgfHwgMCwga2V5KTtcblxuICAgIGlmIChwcmV2UGhhc2UgPT0gVHJhbnNpdGlvblBoYXNlLk1PVU5UKSB7XG4gICAgICB0byA9IHAuZW50ZXI7XG4gICAgICBwaGFzZSA9IFRyYW5zaXRpb25QaGFzZS5FTlRFUjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNMZWF2ZSA9IGtleXMuaW5kZXhPZihrZXkpIDwgMDtcblxuICAgICAgaWYgKHByZXZQaGFzZSAhPSBUcmFuc2l0aW9uUGhhc2UuTEVBVkUpIHtcbiAgICAgICAgaWYgKGlzTGVhdmUpIHtcbiAgICAgICAgICB0byA9IHAubGVhdmU7XG4gICAgICAgICAgcGhhc2UgPSBUcmFuc2l0aW9uUGhhc2UuTEVBVkU7XG4gICAgICAgIH0gZWxzZSBpZiAodG8gPSBwLnVwZGF0ZSkge1xuICAgICAgICAgIHBoYXNlID0gVHJhbnNpdGlvblBoYXNlLlVQREFURTtcbiAgICAgICAgfSBlbHNlIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzTGVhdmUpIHtcbiAgICAgICAgdG8gPSBwLmVudGVyO1xuICAgICAgICBwaGFzZSA9IFRyYW5zaXRpb25QaGFzZS5FTlRFUjtcbiAgICAgIH0gZWxzZSByZXR1cm47XG4gICAgfVxuXG4gICAgdG8gPSBjYWxsUHJvcCh0bywgdC5pdGVtLCBpKTtcbiAgICB0byA9IHNoYXJlZC5pcy5vYmoodG8pID8gaW5mZXJUbyh0bykgOiB7XG4gICAgICB0b1xuICAgIH07XG5cbiAgICBpZiAoIXRvLmNvbmZpZykge1xuICAgICAgY29uc3QgY29uZmlnID0gcHJvcHNDb25maWcgfHwgZGVmYXVsdFByb3BzLmNvbmZpZztcbiAgICAgIHRvLmNvbmZpZyA9IGNhbGxQcm9wKGNvbmZpZywgdC5pdGVtLCBpLCBwaGFzZSk7XG4gICAgfVxuXG4gICAgZGVsYXkgKz0gdHJhaWw7XG5cbiAgICBjb25zdCBwYXlsb2FkID0gX2V4dGVuZHMoe30sIGRlZmF1bHRQcm9wcywge1xuICAgICAgZGVsYXk6IHByb3BzRGVsYXkgKyBkZWxheSxcbiAgICAgIHJlZjogcHJvcHNSZWYsXG4gICAgICBpbW1lZGlhdGU6IHAuaW1tZWRpYXRlLFxuICAgICAgcmVzZXQ6IGZhbHNlXG4gICAgfSwgdG8pO1xuXG4gICAgaWYgKHBoYXNlID09IFRyYW5zaXRpb25QaGFzZS5FTlRFUiAmJiBzaGFyZWQuaXMudW5kKHBheWxvYWQuZnJvbSkpIHtcbiAgICAgIGNvbnN0IF9wID0gcHJvcHNGbiA/IHByb3BzRm4oKSA6IHByb3BzO1xuXG4gICAgICBjb25zdCBmcm9tID0gc2hhcmVkLmlzLnVuZChfcC5pbml0aWFsKSB8fCBwcmV2VHJhbnNpdGlvbnMgPyBfcC5mcm9tIDogX3AuaW5pdGlhbDtcbiAgICAgIHBheWxvYWQuZnJvbSA9IGNhbGxQcm9wKGZyb20sIHQuaXRlbSwgaSk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgb25SZXNvbHZlXG4gICAgfSA9IHBheWxvYWQ7XG5cbiAgICBwYXlsb2FkLm9uUmVzb2x2ZSA9IHJlc3VsdCA9PiB7XG4gICAgICBjYWxsUHJvcChvblJlc29sdmUsIHJlc3VsdCk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHVzZWRUcmFuc2l0aW9ucy5jdXJyZW50O1xuICAgICAgY29uc3QgdCA9IHRyYW5zaXRpb25zLmZpbmQodCA9PiB0LmtleSA9PT0ga2V5KTtcbiAgICAgIGlmICghdCkgcmV0dXJuO1xuXG4gICAgICBpZiAocmVzdWx0LmNhbmNlbGxlZCAmJiB0LnBoYXNlICE9IFRyYW5zaXRpb25QaGFzZS5VUERBVEUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodC5jdHJsLmlkbGUpIHtcbiAgICAgICAgY29uc3QgaWRsZSA9IHRyYW5zaXRpb25zLmV2ZXJ5KHQgPT4gdC5jdHJsLmlkbGUpO1xuXG4gICAgICAgIGlmICh0LnBoYXNlID09IFRyYW5zaXRpb25QaGFzZS5MRUFWRSkge1xuICAgICAgICAgIGNvbnN0IGV4cGlyeSA9IGNhbGxQcm9wKGV4cGlyZXMsIHQuaXRlbSk7XG5cbiAgICAgICAgICBpZiAoZXhwaXJ5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgZXhwaXJ5TXMgPSBleHBpcnkgPT09IHRydWUgPyAwIDogZXhwaXJ5O1xuICAgICAgICAgICAgdC5leHBpcmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFpZGxlICYmIGV4cGlyeU1zID4gMCkge1xuICAgICAgICAgICAgICBpZiAoZXhwaXJ5TXMgPD0gMHg3ZmZmZmZmZikgdC5leHBpcmF0aW9uSWQgPSBzZXRUaW1lb3V0KGZvcmNlVXBkYXRlLCBleHBpcnlNcyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRsZSAmJiB0cmFuc2l0aW9ucy5zb21lKHQgPT4gdC5leHBpcmVkKSkge1xuICAgICAgICAgIGV4aXRpbmdUcmFuc2l0aW9ucy5jdXJyZW50LmRlbGV0ZSh0KTtcblxuICAgICAgICAgIGlmIChleGl0QmVmb3JlRW50ZXIpIHtcbiAgICAgICAgICAgIGZvcmNlQ2hhbmdlLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc3ByaW5ncyA9IGdldFNwcmluZ3ModC5jdHJsLCBwYXlsb2FkKTtcblxuICAgIGlmIChwaGFzZSA9PT0gVHJhbnNpdGlvblBoYXNlLkxFQVZFICYmIGV4aXRCZWZvcmVFbnRlcikge1xuICAgICAgZXhpdGluZ1RyYW5zaXRpb25zLmN1cnJlbnQuc2V0KHQsIHtcbiAgICAgICAgcGhhc2UsXG4gICAgICAgIHNwcmluZ3MsXG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFuZ2VzLnNldCh0LCB7XG4gICAgICAgIHBoYXNlLFxuICAgICAgICBzcHJpbmdzLFxuICAgICAgICBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChTcHJpbmdDb250ZXh0KTtcbiAgY29uc3QgcHJldkNvbnRleHQgPSBzaGFyZWQudXNlUHJldihjb250ZXh0KTtcbiAgY29uc3QgaGFzQ29udGV4dCA9IGNvbnRleHQgIT09IHByZXZDb250ZXh0ICYmIGhhc1Byb3BzKGNvbnRleHQpO1xuICBzaGFyZWQudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIHNoYXJlZC5lYWNoKHRyYW5zaXRpb25zLCB0ID0+IHtcbiAgICAgICAgdC5jdHJsLnN0YXJ0KHtcbiAgICAgICAgICBkZWZhdWx0OiBjb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbY29udGV4dF0pO1xuICBzaGFyZWQuZWFjaChjaGFuZ2VzLCAoXywgdCkgPT4ge1xuICAgIGlmIChleGl0aW5nVHJhbnNpdGlvbnMuY3VycmVudC5zaXplKSB7XG4gICAgICBjb25zdCBpbmQgPSB0cmFuc2l0aW9ucy5maW5kSW5kZXgoc3RhdGUgPT4gc3RhdGUua2V5ID09PSB0LmtleSk7XG4gICAgICB0cmFuc2l0aW9ucy5zcGxpY2UoaW5kLCAxKTtcbiAgICB9XG4gIH0pO1xuICBzaGFyZWQudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2hhcmVkLmVhY2goZXhpdGluZ1RyYW5zaXRpb25zLmN1cnJlbnQuc2l6ZSA/IGV4aXRpbmdUcmFuc2l0aW9ucy5jdXJyZW50IDogY2hhbmdlcywgKHtcbiAgICAgIHBoYXNlLFxuICAgICAgcGF5bG9hZFxuICAgIH0sIHQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3RybFxuICAgICAgfSA9IHQ7XG4gICAgICB0LnBoYXNlID0gcGhhc2U7XG4gICAgICByZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5hZGQoY3RybCk7XG5cbiAgICAgIGlmIChoYXNDb250ZXh0ICYmIHBoYXNlID09IFRyYW5zaXRpb25QaGFzZS5FTlRFUikge1xuICAgICAgICBjdHJsLnN0YXJ0KHtcbiAgICAgICAgICBkZWZhdWx0OiBjb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICByZXBsYWNlUmVmKGN0cmwsIHBheWxvYWQucmVmKTtcblxuICAgICAgICBpZiAoKGN0cmwucmVmIHx8IHJlZikgJiYgIWZvcmNlQ2hhbmdlLmN1cnJlbnQpIHtcbiAgICAgICAgICBjdHJsLnVwZGF0ZShwYXlsb2FkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHJsLnN0YXJ0KHBheWxvYWQpO1xuXG4gICAgICAgICAgaWYgKGZvcmNlQ2hhbmdlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGZvcmNlQ2hhbmdlLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgcmVzZXQgPyB2b2lkIDAgOiBkZXBzKTtcblxuICBjb25zdCByZW5kZXJUcmFuc2l0aW9ucyA9IHJlbmRlciA9PiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgdHJhbnNpdGlvbnMubWFwKCh0LCBpKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc3ByaW5nc1xuICAgIH0gPSBjaGFuZ2VzLmdldCh0KSB8fCB0LmN0cmw7XG4gICAgY29uc3QgZWxlbSA9IHJlbmRlcihfZXh0ZW5kcyh7fSwgc3ByaW5ncyksIHQuaXRlbSwgdCwgaSk7XG4gICAgcmV0dXJuIGVsZW0gJiYgZWxlbS50eXBlID8gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KGVsZW0udHlwZSwgX2V4dGVuZHMoe30sIGVsZW0ucHJvcHMsIHtcbiAgICAgIGtleTogc2hhcmVkLmlzLnN0cih0LmtleSkgfHwgc2hhcmVkLmlzLm51bSh0LmtleSkgPyB0LmtleSA6IHQuY3RybC5pZCxcbiAgICAgIHJlZjogZWxlbS5yZWZcbiAgICB9KSkgOiBlbGVtO1xuICB9KSk7XG5cbiAgcmV0dXJuIHJlZiA/IFtyZW5kZXJUcmFuc2l0aW9ucywgcmVmXSA6IHJlbmRlclRyYW5zaXRpb25zO1xufVxubGV0IG5leHRLZXkgPSAxO1xuXG5mdW5jdGlvbiBnZXRLZXlzKGl0ZW1zLCB7XG4gIGtleSxcbiAga2V5cyA9IGtleVxufSwgcHJldlRyYW5zaXRpb25zKSB7XG4gIGlmIChrZXlzID09PSBudWxsKSB7XG4gICAgY29uc3QgcmV1c2VkID0gbmV3IFNldCgpO1xuICAgIHJldHVybiBpdGVtcy5tYXAoaXRlbSA9PiB7XG4gICAgICBjb25zdCB0ID0gcHJldlRyYW5zaXRpb25zICYmIHByZXZUcmFuc2l0aW9ucy5maW5kKHQgPT4gdC5pdGVtID09PSBpdGVtICYmIHQucGhhc2UgIT09IFRyYW5zaXRpb25QaGFzZS5MRUFWRSAmJiAhcmV1c2VkLmhhcyh0KSk7XG5cbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHJldXNlZC5hZGQodCk7XG4gICAgICAgIHJldHVybiB0LmtleTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHRLZXkrKztcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzaGFyZWQuaXMudW5kKGtleXMpID8gaXRlbXMgOiBzaGFyZWQuaXMuZnVuKGtleXMpID8gaXRlbXMubWFwKGtleXMpIDogc2hhcmVkLnRvQXJyYXkoa2V5cyk7XG59XG5cbmNvbnN0IF9leGNsdWRlZCQ1ID0gW1wiY29udGFpbmVyXCJdO1xuY29uc3QgdXNlU2Nyb2xsID0gKF9yZWYgPSB7fSkgPT4ge1xuICBsZXQge1xuICAgIGNvbnRhaW5lclxuICB9ID0gX3JlZixcbiAgICAgIHNwcmluZ09wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkNSk7XG5cbiAgY29uc3QgW3Njcm9sbFZhbHVlcywgYXBpXSA9IHVzZVNwcmluZygoKSA9PiBfZXh0ZW5kcyh7XG4gICAgc2Nyb2xsWDogMCxcbiAgICBzY3JvbGxZOiAwLFxuICAgIHNjcm9sbFhQcm9ncmVzczogMCxcbiAgICBzY3JvbGxZUHJvZ3Jlc3M6IDBcbiAgfSwgc3ByaW5nT3B0aW9ucyksIFtdKTtcbiAgc2hhcmVkLnVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBTY3JvbGwgPSBzaGFyZWQub25TY3JvbGwoKHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSkgPT4ge1xuICAgICAgYXBpLnN0YXJ0KHtcbiAgICAgICAgc2Nyb2xsWDogeC5jdXJyZW50LFxuICAgICAgICBzY3JvbGxYUHJvZ3Jlc3M6IHgucHJvZ3Jlc3MsXG4gICAgICAgIHNjcm9sbFk6IHkuY3VycmVudCxcbiAgICAgICAgc2Nyb2xsWVByb2dyZXNzOiB5LnByb2dyZXNzXG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBjb250YWluZXI6IChjb250YWluZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRhaW5lci5jdXJyZW50KSB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2hhcmVkLmVhY2goT2JqZWN0LnZhbHVlcyhzY3JvbGxWYWx1ZXMpLCB2YWx1ZSA9PiB2YWx1ZS5zdG9wKCkpO1xuICAgICAgY2xlYW51cFNjcm9sbCgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHNjcm9sbFZhbHVlcztcbn07XG5cbmNvbnN0IF9leGNsdWRlZCQ0ID0gW1wiY29udGFpbmVyXCJdO1xuY29uc3QgdXNlUmVzaXplID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY29udGFpbmVyXG4gIH0gPSBfcmVmLFxuICAgICAgc3ByaW5nT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQ0KTtcblxuICBjb25zdCBbc2l6ZVZhbHVlcywgYXBpXSA9IHVzZVNwcmluZygoKSA9PiBfZXh0ZW5kcyh7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sIHNwcmluZ09wdGlvbnMpLCBbXSk7XG4gIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwU2Nyb2xsID0gc2hhcmVkLm9uUmVzaXplKCh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0pID0+IHtcbiAgICAgIGFwaS5zdGFydCh7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGltbWVkaWF0ZTogc2l6ZVZhbHVlcy53aWR0aC5nZXQoKSA9PT0gMCB8fCBzaXplVmFsdWVzLmhlaWdodC5nZXQoKSA9PT0gMFxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgY29udGFpbmVyOiAoY29udGFpbmVyID09IG51bGwgPyB2b2lkIDAgOiBjb250YWluZXIuY3VycmVudCkgfHwgdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNoYXJlZC5lYWNoKE9iamVjdC52YWx1ZXMoc2l6ZVZhbHVlcyksIHZhbHVlID0+IHZhbHVlLnN0b3AoKSk7XG4gICAgICBjbGVhbnVwU2Nyb2xsKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gc2l6ZVZhbHVlcztcbn07XG5cbmNvbnN0IF9leGNsdWRlZCQzID0gW1widG9cIiwgXCJmcm9tXCJdLFxuICAgICAgX2V4Y2x1ZGVkMiA9IFtcInJvb3RcIiwgXCJvbmNlXCIsIFwiYW1vdW50XCJdO1xuY29uc3QgZGVmYXVsdFRocmVzaG9sZE9wdGlvbnMgPSB7XG4gIGFueTogMCxcbiAgYWxsOiAxXG59O1xuZnVuY3Rpb24gdXNlSW5WaWV3KHByb3BzLCBhcmdzKSB7XG4gIGNvbnN0IFtpc0luVmlldywgc2V0SXNJblZpZXddID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgcHJvcHNGbiA9IHNoYXJlZC5pcy5mdW4ocHJvcHMpICYmIHByb3BzO1xuICBjb25zdCBzcHJpbmdzUHJvcHMgPSBwcm9wc0ZuID8gcHJvcHNGbigpIDoge307XG5cbiAgY29uc3Qge1xuICAgIHRvID0ge30sXG4gICAgZnJvbSA9IHt9XG4gIH0gPSBzcHJpbmdzUHJvcHMsXG4gICAgICAgIHJlc3RTcHJpbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNwcmluZ3NQcm9wcywgX2V4Y2x1ZGVkJDMpO1xuXG4gIGNvbnN0IGludGVyc2VjdGlvbkFyZ3VtZW50cyA9IHByb3BzRm4gPyBhcmdzIDogcHJvcHM7XG4gIGNvbnN0IFtzcHJpbmdzLCBhcGldID0gdXNlU3ByaW5nKCgpID0+IF9leHRlbmRzKHtcbiAgICBmcm9tXG4gIH0sIHJlc3RTcHJpbmdQcm9wcyksIFtdKTtcbiAgc2hhcmVkLnVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcblxuICAgIGNvbnN0IF9yZWYgPSBpbnRlcnNlY3Rpb25Bcmd1bWVudHMgIT0gbnVsbCA/IGludGVyc2VjdGlvbkFyZ3VtZW50cyA6IHt9LFxuICAgICAgICAgIHtcbiAgICAgIHJvb3QsXG4gICAgICBvbmNlLFxuICAgICAgYW1vdW50ID0gJ2FueSdcbiAgICB9ID0gX3JlZixcbiAgICAgICAgICByZXN0QXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZDIpO1xuXG4gICAgaWYgKCFlbGVtZW50IHx8IG9uY2UgJiYgaXNJblZpZXcgfHwgdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIGNvbnN0IGFjdGl2ZUludGVyc2VjdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgY29uc3Qgb25FbnRlciA9ICgpID0+IHtcbiAgICAgIGlmICh0bykge1xuICAgICAgICBhcGkuc3RhcnQodG8pO1xuICAgICAgfVxuXG4gICAgICBzZXRJc0luVmlldyh0cnVlKTtcblxuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICBhcGkuc3RhcnQoZnJvbSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJc0luVmlldyhmYWxzZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gb25jZSA/IHVuZGVmaW5lZCA6IGNsZWFudXA7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUludGVyc2VjdGlvbiA9IGVudHJpZXMgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3Qgb25MZWF2ZSA9IGFjdGl2ZUludGVyc2VjdGlvbnMuZ2V0KGVudHJ5LnRhcmdldCk7XG5cbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nID09PSBCb29sZWFuKG9uTGVhdmUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgY29uc3QgbmV3T25MZWF2ZSA9IG9uRW50ZXIoKTtcblxuICAgICAgICAgIGlmIChzaGFyZWQuaXMuZnVuKG5ld09uTGVhdmUpKSB7XG4gICAgICAgICAgICBhY3RpdmVJbnRlcnNlY3Rpb25zLnNldChlbnRyeS50YXJnZXQsIG5ld09uTGVhdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob25MZWF2ZSkge1xuICAgICAgICAgIG9uTGVhdmUoKTtcbiAgICAgICAgICBhY3RpdmVJbnRlcnNlY3Rpb25zLmRlbGV0ZShlbnRyeS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlSW50ZXJzZWN0aW9uLCBfZXh0ZW5kcyh7XG4gICAgICByb290OiByb290ICYmIHJvb3QuY3VycmVudCB8fCB1bmRlZmluZWQsXG4gICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInIHx8IEFycmF5LmlzQXJyYXkoYW1vdW50KSA/IGFtb3VudCA6IGRlZmF1bHRUaHJlc2hvbGRPcHRpb25zW2Ftb3VudF1cbiAgICB9LCByZXN0QXJncykpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuICgpID0+IG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgfSwgW2ludGVyc2VjdGlvbkFyZ3VtZW50c10pO1xuXG4gIGlmIChwcm9wc0ZuKSB7XG4gICAgcmV0dXJuIFtyZWYsIHNwcmluZ3NdO1xuICB9XG5cbiAgcmV0dXJuIFtyZWYsIGlzSW5WaWV3XTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkJDIgPSBbXCJjaGlsZHJlblwiXTtcbmZ1bmN0aW9uIFNwcmluZyhfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWYsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQyKTtcblxuICByZXR1cm4gY2hpbGRyZW4odXNlU3ByaW5nKHByb3BzKSk7XG59XG5cbmNvbnN0IF9leGNsdWRlZCQxID0gW1wiaXRlbXNcIiwgXCJjaGlsZHJlblwiXTtcbmZ1bmN0aW9uIFRyYWlsKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBpdGVtcyxcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJDEpO1xuXG4gIGNvbnN0IHRyYWlscyA9IHVzZVRyYWlsKGl0ZW1zLmxlbmd0aCwgcHJvcHMpO1xuICByZXR1cm4gaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNoaWxkcmVuKGl0ZW0sIGluZGV4KTtcbiAgICByZXR1cm4gc2hhcmVkLmlzLmZ1bihyZXN1bHQpID8gcmVzdWx0KHRyYWlsc1tpbmRleF0pIDogcmVzdWx0O1xuICB9KTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wiaXRlbXNcIiwgXCJjaGlsZHJlblwiXTtcbmZ1bmN0aW9uIFRyYW5zaXRpb24oX3JlZikge1xuICBsZXQge1xuICAgIGl0ZW1zLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQpO1xuXG4gIHJldHVybiB1c2VUcmFuc2l0aW9uKGl0ZW1zLCBwcm9wcykoY2hpbGRyZW4pO1xufVxuXG5jbGFzcyBJbnRlcnBvbGF0aW9uIGV4dGVuZHMgRnJhbWVWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5pZGxlID0gdHJ1ZTtcbiAgICB0aGlzLmNhbGMgPSB2b2lkIDA7XG4gICAgdGhpcy5fYWN0aXZlID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuY2FsYyA9IHNoYXJlZC5jcmVhdGVJbnRlcnBvbGF0b3IoLi4uYXJncyk7XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2dldCgpO1xuXG4gICAgY29uc3Qgbm9kZVR5cGUgPSBhbmltYXRlZCQxLmdldEFuaW1hdGVkVHlwZSh2YWx1ZSk7XG4gICAgYW5pbWF0ZWQkMS5zZXRBbmltYXRlZCh0aGlzLCBub2RlVHlwZS5jcmVhdGUodmFsdWUpKTtcbiAgfVxuXG4gIGFkdmFuY2UoX2R0KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9nZXQoKTtcblxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5nZXQoKTtcblxuICAgIGlmICghc2hhcmVkLmlzRXF1YWwodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgYW5pbWF0ZWQkMS5nZXRBbmltYXRlZCh0aGlzKS5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIHRoaXMuX29uQ2hhbmdlKHZhbHVlLCB0aGlzLmlkbGUpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pZGxlICYmIGNoZWNrSWRsZSh0aGlzLl9hY3RpdmUpKSB7XG4gICAgICBiZWNvbWVJZGxlKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXQoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gc2hhcmVkLmlzLmFycih0aGlzLnNvdXJjZSkgPyB0aGlzLnNvdXJjZS5tYXAoc2hhcmVkLmdldEZsdWlkVmFsdWUpIDogc2hhcmVkLnRvQXJyYXkoc2hhcmVkLmdldEZsdWlkVmFsdWUodGhpcy5zb3VyY2UpKTtcbiAgICByZXR1cm4gdGhpcy5jYWxjKC4uLmlucHV0cyk7XG4gIH1cblxuICBfc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuaWRsZSAmJiAhY2hlY2tJZGxlKHRoaXMuX2FjdGl2ZSkpIHtcbiAgICAgIHRoaXMuaWRsZSA9IGZhbHNlO1xuICAgICAgc2hhcmVkLmVhY2goYW5pbWF0ZWQkMS5nZXRQYXlsb2FkKHRoaXMpLCBub2RlID0+IHtcbiAgICAgICAgbm9kZS5kb25lID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNoYXJlZC5HbG9iYWxzLnNraXBBbmltYXRpb24pIHtcbiAgICAgICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiB0aGlzLmFkdmFuY2UoKSk7XG4gICAgICAgIGJlY29tZUlkbGUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFyZWQuZnJhbWVMb29wLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9hdHRhY2goKSB7XG4gICAgbGV0IHByaW9yaXR5ID0gMTtcbiAgICBzaGFyZWQuZWFjaChzaGFyZWQudG9BcnJheSh0aGlzLnNvdXJjZSksIHNvdXJjZSA9PiB7XG4gICAgICBpZiAoc2hhcmVkLmhhc0ZsdWlkVmFsdWUoc291cmNlKSkge1xuICAgICAgICBzaGFyZWQuYWRkRmx1aWRPYnNlcnZlcihzb3VyY2UsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGcmFtZVZhbHVlKHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UuaWRsZSkge1xuICAgICAgICAgIHRoaXMuX2FjdGl2ZS5hZGQoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW9yaXR5ID0gTWF0aC5tYXgocHJpb3JpdHksIHNvdXJjZS5wcmlvcml0eSArIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcblxuICAgIHRoaXMuX3N0YXJ0KCk7XG4gIH1cblxuICBfZGV0YWNoKCkge1xuICAgIHNoYXJlZC5lYWNoKHNoYXJlZC50b0FycmF5KHRoaXMuc291cmNlKSwgc291cmNlID0+IHtcbiAgICAgIGlmIChzaGFyZWQuaGFzRmx1aWRWYWx1ZShzb3VyY2UpKSB7XG4gICAgICAgIHNoYXJlZC5yZW1vdmVGbHVpZE9ic2VydmVyKHNvdXJjZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9hY3RpdmUuY2xlYXIoKTtcblxuICAgIGJlY29tZUlkbGUodGhpcyk7XG4gIH1cblxuICBldmVudE9ic2VydmVkKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gJ2NoYW5nZScpIHtcbiAgICAgIGlmIChldmVudC5pZGxlKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlLmFkZChldmVudC5wYXJlbnQpO1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudC50eXBlID09ICdpZGxlJykge1xuICAgICAgdGhpcy5fYWN0aXZlLmRlbGV0ZShldmVudC5wYXJlbnQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PSAncHJpb3JpdHknKSB7XG4gICAgICB0aGlzLnByaW9yaXR5ID0gc2hhcmVkLnRvQXJyYXkodGhpcy5zb3VyY2UpLnJlZHVjZSgoaGlnaGVzdCwgcGFyZW50KSA9PiBNYXRoLm1heChoaWdoZXN0LCAoaXNGcmFtZVZhbHVlKHBhcmVudCkgPyBwYXJlbnQucHJpb3JpdHkgOiAwKSArIDEpLCAwKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0lkbGUoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UuaWRsZSAhPT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRsZShhY3RpdmUpIHtcbiAgcmV0dXJuICFhY3RpdmUuc2l6ZSB8fCBBcnJheS5mcm9tKGFjdGl2ZSkuZXZlcnkoaXNJZGxlKTtcbn1cblxuZnVuY3Rpb24gYmVjb21lSWRsZShzZWxmKSB7XG4gIGlmICghc2VsZi5pZGxlKSB7XG4gICAgc2VsZi5pZGxlID0gdHJ1ZTtcbiAgICBzaGFyZWQuZWFjaChhbmltYXRlZCQxLmdldFBheWxvYWQoc2VsZiksIG5vZGUgPT4ge1xuICAgICAgbm9kZS5kb25lID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBzaGFyZWQuY2FsbEZsdWlkT2JzZXJ2ZXJzKHNlbGYsIHtcbiAgICAgIHR5cGU6ICdpZGxlJyxcbiAgICAgIHBhcmVudDogc2VsZlxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IHRvID0gKHNvdXJjZSwgLi4uYXJncykgPT4gbmV3IEludGVycG9sYXRpb24oc291cmNlLCBhcmdzKTtcbmNvbnN0IGludGVycG9sYXRlID0gKHNvdXJjZSwgLi4uYXJncykgPT4gKHNoYXJlZC5kZXByZWNhdGVJbnRlcnBvbGF0ZSgpLCBuZXcgSW50ZXJwb2xhdGlvbihzb3VyY2UsIGFyZ3MpKTtcblxuc2hhcmVkLkdsb2JhbHMuYXNzaWduKHtcbiAgY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yOiBzaGFyZWQuY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yLFxuICB0bzogKHNvdXJjZSwgYXJncykgPT4gbmV3IEludGVycG9sYXRpb24oc291cmNlLCBhcmdzKVxufSk7XG5jb25zdCB1cGRhdGUgPSBzaGFyZWQuZnJhbWVMb29wLmFkdmFuY2U7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnR2xvYmFscycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWQuR2xvYmFsczsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZUludGVycG9sYXRvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWQuY3JlYXRlSW50ZXJwb2xhdG9yOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZWFzaW5ncycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWQuZWFzaW5nczsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkLnVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VSZWR1Y2VkTW90aW9uJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZC51c2VSZWR1Y2VkTW90aW9uOyB9XG59KTtcbmV4cG9ydHMuQmFpbFNpZ25hbCA9IEJhaWxTaWduYWw7XG5leHBvcnRzLkNvbnRyb2xsZXIgPSBDb250cm9sbGVyO1xuZXhwb3J0cy5GcmFtZVZhbHVlID0gRnJhbWVWYWx1ZTtcbmV4cG9ydHMuSW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRpb247XG5leHBvcnRzLlNwcmluZyA9IFNwcmluZztcbmV4cG9ydHMuU3ByaW5nQ29udGV4dCA9IFNwcmluZ0NvbnRleHQ7XG5leHBvcnRzLlNwcmluZ1JlZiA9IFNwcmluZ1JlZjtcbmV4cG9ydHMuU3ByaW5nVmFsdWUgPSBTcHJpbmdWYWx1ZTtcbmV4cG9ydHMuVHJhaWwgPSBUcmFpbDtcbmV4cG9ydHMuVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG5leHBvcnRzLmNvbmZpZyA9IGNvbmZpZztcbmV4cG9ydHMuaW5mZXJUbyA9IGluZmVyVG87XG5leHBvcnRzLmludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5leHBvcnRzLnRvID0gdG87XG5leHBvcnRzLnVwZGF0ZSA9IHVwZGF0ZTtcbmV4cG9ydHMudXNlQ2hhaW4gPSB1c2VDaGFpbjtcbmV4cG9ydHMudXNlSW5WaWV3ID0gdXNlSW5WaWV3O1xuZXhwb3J0cy51c2VSZXNpemUgPSB1c2VSZXNpemU7XG5leHBvcnRzLnVzZVNjcm9sbCA9IHVzZVNjcm9sbDtcbmV4cG9ydHMudXNlU3ByaW5nID0gdXNlU3ByaW5nO1xuZXhwb3J0cy51c2VTcHJpbmdSZWYgPSB1c2VTcHJpbmdSZWY7XG5leHBvcnRzLnVzZVNwcmluZ1ZhbHVlID0gdXNlU3ByaW5nVmFsdWU7XG5leHBvcnRzLnVzZVNwcmluZ3MgPSB1c2VTcHJpbmdzO1xuZXhwb3J0cy51c2VUcmFpbCA9IHVzZVRyYWlsO1xuZXhwb3J0cy51c2VUcmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbjtcbk9iamVjdC5rZXlzKGFuaW1hdGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuaW1hdGVkW2tdOyB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhpbnRlcnBvbGF0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVycG9sYXRpb25ba107IH1cbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/core/dist/react-spring-core.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/core/dist/react-spring-core.cjs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-spring/core/dist/react-spring-core.cjs.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-spring-core.cjs.dev.js */ \"(ssr)/./node_modules/@react-spring/core/dist/react-spring-core.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9jb3JlL2Rpc3QvcmVhY3Qtc3ByaW5nLWNvcmUuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9jb3JlL2Rpc3QvcmVhY3Qtc3ByaW5nLWNvcmUuY2pzLmpzPzc0YjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVhY3Qtc3ByaW5nLWNvcmUuY2pzLnByb2QuanNcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlYWN0LXNwcmluZy1jb3JlLmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/core/dist/react-spring-core.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/rafz/dist/react-spring-rafz.cjs.dev.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-spring/rafz/dist/react-spring-rafz.cjs.dev.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nlet updateQueue = makeQueue();\nconst raf = fn => schedule(fn, updateQueue);\nlet writeQueue = makeQueue();\n\nraf.write = fn => schedule(fn, writeQueue);\n\nlet onStartQueue = makeQueue();\n\nraf.onStart = fn => schedule(fn, onStartQueue);\n\nlet onFrameQueue = makeQueue();\n\nraf.onFrame = fn => schedule(fn, onFrameQueue);\n\nlet onFinishQueue = makeQueue();\n\nraf.onFinish = fn => schedule(fn, onFinishQueue);\n\nlet timeouts = [];\n\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel);\n    if (~i) timeouts.splice(i, 1);\n    pendingCount -= ~i ? 1 : 0;\n  };\n\n  let timeout = {\n    time,\n    handler,\n    cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  pendingCount += 1;\n  start();\n  return timeout;\n};\n\nlet findTimeout = time => ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length);\n\nraf.cancel = fn => {\n  onStartQueue.delete(fn);\n  onFrameQueue.delete(fn);\n  onFinishQueue.delete(fn);\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\n\nraf.sync = fn => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\n\nraf.throttle = fn => {\n  let lastArgs;\n\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n\n  throttled.handler = fn;\n\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n\n  return throttled;\n};\n\nlet nativeRaf = typeof window != 'undefined' ? window.requestAnimationFrame : () => {};\n\nraf.use = impl => nativeRaf = impl;\n\nraf.now = typeof performance != 'undefined' ? () => performance.now() : Date.now;\n\nraf.batchedUpdates = fn => fn();\n\nraf.catch = console.error;\nraf.frameLoop = 'always';\n\nraf.advance = () => {\n  if (raf.frameLoop !== 'demand') {\n    console.warn('Cannot call the manual advancement of rafz whilst frameLoop is not set as demand');\n  } else {\n    update();\n  }\n};\n\nlet ts = -1;\nlet pendingCount = 0;\nlet sync = false;\n\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n\n    if (raf.frameLoop !== 'demand') {\n      nativeRaf(loop);\n    }\n  }\n}\n\nfunction stop() {\n  ts = -1;\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\n\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler());\n    pendingCount -= count;\n  }\n\n  if (!pendingCount) {\n    stop();\n    return;\n  }\n\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\n\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      pendingCount += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n\n    delete(fn) {\n      pendingCount -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        pendingCount -= current.size;\n        eachSafely(current, fn => fn(arg) && next.add(fn));\n        pendingCount += next.size;\n        current = next;\n      }\n    }\n\n  };\n}\n\nfunction eachSafely(values, each) {\n  values.forEach(value => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\n\nconst __raf = {\n  count() {\n    return pendingCount;\n  },\n\n  isRunning() {\n    return ts >= 0;\n  },\n\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    pendingCount = 0;\n  }\n\n};\n\nexports.__raf = __raf;\nexports.raf = raf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9yYWZ6L2Rpc3QvcmVhY3Qtc3ByaW5nLXJhZnouY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhO0FBQ2IsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL3JhZnovZGlzdC9yZWFjdC1zcHJpbmctcmFmei5janMuZGV2LmpzP2YxZjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5sZXQgdXBkYXRlUXVldWUgPSBtYWtlUXVldWUoKTtcbmNvbnN0IHJhZiA9IGZuID0+IHNjaGVkdWxlKGZuLCB1cGRhdGVRdWV1ZSk7XG5sZXQgd3JpdGVRdWV1ZSA9IG1ha2VRdWV1ZSgpO1xuXG5yYWYud3JpdGUgPSBmbiA9PiBzY2hlZHVsZShmbiwgd3JpdGVRdWV1ZSk7XG5cbmxldCBvblN0YXJ0UXVldWUgPSBtYWtlUXVldWUoKTtcblxucmFmLm9uU3RhcnQgPSBmbiA9PiBzY2hlZHVsZShmbiwgb25TdGFydFF1ZXVlKTtcblxubGV0IG9uRnJhbWVRdWV1ZSA9IG1ha2VRdWV1ZSgpO1xuXG5yYWYub25GcmFtZSA9IGZuID0+IHNjaGVkdWxlKGZuLCBvbkZyYW1lUXVldWUpO1xuXG5sZXQgb25GaW5pc2hRdWV1ZSA9IG1ha2VRdWV1ZSgpO1xuXG5yYWYub25GaW5pc2ggPSBmbiA9PiBzY2hlZHVsZShmbiwgb25GaW5pc2hRdWV1ZSk7XG5cbmxldCB0aW1lb3V0cyA9IFtdO1xuXG5yYWYuc2V0VGltZW91dCA9IChoYW5kbGVyLCBtcykgPT4ge1xuICBsZXQgdGltZSA9IHJhZi5ub3coKSArIG1zO1xuXG4gIGxldCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgbGV0IGkgPSB0aW1lb3V0cy5maW5kSW5kZXgodCA9PiB0LmNhbmNlbCA9PSBjYW5jZWwpO1xuICAgIGlmICh+aSkgdGltZW91dHMuc3BsaWNlKGksIDEpO1xuICAgIHBlbmRpbmdDb3VudCAtPSB+aSA/IDEgOiAwO1xuICB9O1xuXG4gIGxldCB0aW1lb3V0ID0ge1xuICAgIHRpbWUsXG4gICAgaGFuZGxlcixcbiAgICBjYW5jZWxcbiAgfTtcbiAgdGltZW91dHMuc3BsaWNlKGZpbmRUaW1lb3V0KHRpbWUpLCAwLCB0aW1lb3V0KTtcbiAgcGVuZGluZ0NvdW50ICs9IDE7XG4gIHN0YXJ0KCk7XG4gIHJldHVybiB0aW1lb3V0O1xufTtcblxubGV0IGZpbmRUaW1lb3V0ID0gdGltZSA9PiB+KH50aW1lb3V0cy5maW5kSW5kZXgodCA9PiB0LnRpbWUgPiB0aW1lKSB8fCB+dGltZW91dHMubGVuZ3RoKTtcblxucmFmLmNhbmNlbCA9IGZuID0+IHtcbiAgb25TdGFydFF1ZXVlLmRlbGV0ZShmbik7XG4gIG9uRnJhbWVRdWV1ZS5kZWxldGUoZm4pO1xuICBvbkZpbmlzaFF1ZXVlLmRlbGV0ZShmbik7XG4gIHVwZGF0ZVF1ZXVlLmRlbGV0ZShmbik7XG4gIHdyaXRlUXVldWUuZGVsZXRlKGZuKTtcbn07XG5cbnJhZi5zeW5jID0gZm4gPT4ge1xuICBzeW5jID0gdHJ1ZTtcbiAgcmFmLmJhdGNoZWRVcGRhdGVzKGZuKTtcbiAgc3luYyA9IGZhbHNlO1xufTtcblxucmFmLnRocm90dGxlID0gZm4gPT4ge1xuICBsZXQgbGFzdEFyZ3M7XG5cbiAgZnVuY3Rpb24gcXVldWVkRm4oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKC4uLmxhc3RBcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbGFzdEFyZ3MgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRocm90dGxlZCguLi5hcmdzKSB7XG4gICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgIHJhZi5vblN0YXJ0KHF1ZXVlZEZuKTtcbiAgfVxuXG4gIHRocm90dGxlZC5oYW5kbGVyID0gZm47XG5cbiAgdGhyb3R0bGVkLmNhbmNlbCA9ICgpID0+IHtcbiAgICBvblN0YXJ0UXVldWUuZGVsZXRlKHF1ZXVlZEZuKTtcbiAgICBsYXN0QXJncyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn07XG5cbmxldCBuYXRpdmVSYWYgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6ICgpID0+IHt9O1xuXG5yYWYudXNlID0gaW1wbCA9PiBuYXRpdmVSYWYgPSBpbXBsO1xuXG5yYWYubm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9ICd1bmRlZmluZWQnID8gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdztcblxucmFmLmJhdGNoZWRVcGRhdGVzID0gZm4gPT4gZm4oKTtcblxucmFmLmNhdGNoID0gY29uc29sZS5lcnJvcjtcbnJhZi5mcmFtZUxvb3AgPSAnYWx3YXlzJztcblxucmFmLmFkdmFuY2UgPSAoKSA9PiB7XG4gIGlmIChyYWYuZnJhbWVMb29wICE9PSAnZGVtYW5kJykge1xuICAgIGNvbnNvbGUud2FybignQ2Fubm90IGNhbGwgdGhlIG1hbnVhbCBhZHZhbmNlbWVudCBvZiByYWZ6IHdoaWxzdCBmcmFtZUxvb3AgaXMgbm90IHNldCBhcyBkZW1hbmQnKTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUoKTtcbiAgfVxufTtcblxubGV0IHRzID0gLTE7XG5sZXQgcGVuZGluZ0NvdW50ID0gMDtcbmxldCBzeW5jID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKGZuLCBxdWV1ZSkge1xuICBpZiAoc3luYykge1xuICAgIHF1ZXVlLmRlbGV0ZShmbik7XG4gICAgZm4oMCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWUuYWRkKGZuKTtcbiAgICBzdGFydCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0KCkge1xuICBpZiAodHMgPCAwKSB7XG4gICAgdHMgPSAwO1xuXG4gICAgaWYgKHJhZi5mcmFtZUxvb3AgIT09ICdkZW1hbmQnKSB7XG4gICAgICBuYXRpdmVSYWYobG9vcCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3AoKSB7XG4gIHRzID0gLTE7XG59XG5cbmZ1bmN0aW9uIGxvb3AoKSB7XG4gIGlmICh+dHMpIHtcbiAgICBuYXRpdmVSYWYobG9vcCk7XG4gICAgcmFmLmJhdGNoZWRVcGRhdGVzKHVwZGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlKCkge1xuICBsZXQgcHJldlRzID0gdHM7XG4gIHRzID0gcmFmLm5vdygpO1xuICBsZXQgY291bnQgPSBmaW5kVGltZW91dCh0cyk7XG5cbiAgaWYgKGNvdW50KSB7XG4gICAgZWFjaFNhZmVseSh0aW1lb3V0cy5zcGxpY2UoMCwgY291bnQpLCB0ID0+IHQuaGFuZGxlcigpKTtcbiAgICBwZW5kaW5nQ291bnQgLT0gY291bnQ7XG4gIH1cblxuICBpZiAoIXBlbmRpbmdDb3VudCkge1xuICAgIHN0b3AoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBvblN0YXJ0UXVldWUuZmx1c2goKTtcbiAgdXBkYXRlUXVldWUuZmx1c2gocHJldlRzID8gTWF0aC5taW4oNjQsIHRzIC0gcHJldlRzKSA6IDE2LjY2Nyk7XG4gIG9uRnJhbWVRdWV1ZS5mbHVzaCgpO1xuICB3cml0ZVF1ZXVlLmZsdXNoKCk7XG4gIG9uRmluaXNoUXVldWUuZmx1c2goKTtcbn1cblxuZnVuY3Rpb24gbWFrZVF1ZXVlKCkge1xuICBsZXQgbmV4dCA9IG5ldyBTZXQoKTtcbiAgbGV0IGN1cnJlbnQgPSBuZXh0O1xuICByZXR1cm4ge1xuICAgIGFkZChmbikge1xuICAgICAgcGVuZGluZ0NvdW50ICs9IGN1cnJlbnQgPT0gbmV4dCAmJiAhbmV4dC5oYXMoZm4pID8gMSA6IDA7XG4gICAgICBuZXh0LmFkZChmbik7XG4gICAgfSxcblxuICAgIGRlbGV0ZShmbikge1xuICAgICAgcGVuZGluZ0NvdW50IC09IGN1cnJlbnQgPT0gbmV4dCAmJiBuZXh0LmhhcyhmbikgPyAxIDogMDtcbiAgICAgIHJldHVybiBuZXh0LmRlbGV0ZShmbik7XG4gICAgfSxcblxuICAgIGZsdXNoKGFyZykge1xuICAgICAgaWYgKGN1cnJlbnQuc2l6ZSkge1xuICAgICAgICBuZXh0ID0gbmV3IFNldCgpO1xuICAgICAgICBwZW5kaW5nQ291bnQgLT0gY3VycmVudC5zaXplO1xuICAgICAgICBlYWNoU2FmZWx5KGN1cnJlbnQsIGZuID0+IGZuKGFyZykgJiYgbmV4dC5hZGQoZm4pKTtcbiAgICAgICAgcGVuZGluZ0NvdW50ICs9IG5leHQuc2l6ZTtcbiAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVhY2hTYWZlbHkodmFsdWVzLCBlYWNoKSB7XG4gIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICB0cnkge1xuICAgICAgZWFjaCh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmFmLmNhdGNoKGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IF9fcmFmID0ge1xuICBjb3VudCgpIHtcbiAgICByZXR1cm4gcGVuZGluZ0NvdW50O1xuICB9LFxuXG4gIGlzUnVubmluZygpIHtcbiAgICByZXR1cm4gdHMgPj0gMDtcbiAgfSxcblxuICBjbGVhcigpIHtcbiAgICB0cyA9IC0xO1xuICAgIHRpbWVvdXRzID0gW107XG4gICAgb25TdGFydFF1ZXVlID0gbWFrZVF1ZXVlKCk7XG4gICAgdXBkYXRlUXVldWUgPSBtYWtlUXVldWUoKTtcbiAgICBvbkZyYW1lUXVldWUgPSBtYWtlUXVldWUoKTtcbiAgICB3cml0ZVF1ZXVlID0gbWFrZVF1ZXVlKCk7XG4gICAgb25GaW5pc2hRdWV1ZSA9IG1ha2VRdWV1ZSgpO1xuICAgIHBlbmRpbmdDb3VudCA9IDA7XG4gIH1cblxufTtcblxuZXhwb3J0cy5fX3JhZiA9IF9fcmFmO1xuZXhwb3J0cy5yYWYgPSByYWY7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/rafz/dist/react-spring-rafz.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/rafz/dist/react-spring-rafz.cjs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-spring/rafz/dist/react-spring-rafz.cjs.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-spring-rafz.cjs.dev.js */ \"(ssr)/./node_modules/@react-spring/rafz/dist/react-spring-rafz.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9yYWZ6L2Rpc3QvcmVhY3Qtc3ByaW5nLXJhZnouY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9yYWZ6L2Rpc3QvcmVhY3Qtc3ByaW5nLXJhZnouY2pzLmpzPzVhZmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVhY3Qtc3ByaW5nLXJhZnouY2pzLnByb2QuanNcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlYWN0LXNwcmluZy1yYWZ6LmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/rafz/dist/react-spring-rafz.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.dev.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.dev.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar rafz = __webpack_require__(/*! @react-spring/rafz */ \"(ssr)/./node_modules/@react-spring/rafz/dist/react-spring-rafz.cjs.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction noop() {}\nconst defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {\n  value,\n  writable: true,\n  configurable: true\n});\nconst is = {\n  arr: Array.isArray,\n  obj: a => !!a && a.constructor.name === 'Object',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  und: a => a === undefined\n};\nfunction isEqual(a, b) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  return a === b;\n}\nconst each = (obj, fn) => obj.forEach(fn);\nfunction eachProp(obj, fn, ctx) {\n  if (is.arr(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn.call(ctx, obj[i], `${i}`);\n    }\n\n    return;\n  }\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn.call(ctx, obj[key], key);\n    }\n  }\n}\nconst toArray = a => is.und(a) ? [] : is.arr(a) ? a : [a];\nfunction flush(queue, iterator) {\n  if (queue.size) {\n    const items = Array.from(queue);\n    queue.clear();\n    each(items, iterator);\n  }\n}\nconst flushCalls = (queue, ...args) => flush(queue, fn => fn(...args));\nconst isSSR = () => typeof window === 'undefined' || !window.navigator || /ServerSideRendering|^Deno\\//.test(window.navigator.userAgent);\n\nlet createStringInterpolator$1;\nlet to;\nlet colors$1 = null;\nlet skipAnimation = false;\nlet willAdvance = noop;\nconst assign = globals => {\n  if (globals.to) to = globals.to;\n  if (globals.now) rafz.raf.now = globals.now;\n  if (globals.colors !== undefined) colors$1 = globals.colors;\n  if (globals.skipAnimation != null) skipAnimation = globals.skipAnimation;\n  if (globals.createStringInterpolator) createStringInterpolator$1 = globals.createStringInterpolator;\n  if (globals.requestAnimationFrame) rafz.raf.use(globals.requestAnimationFrame);\n  if (globals.batchedUpdates) rafz.raf.batchedUpdates = globals.batchedUpdates;\n  if (globals.willAdvance) willAdvance = globals.willAdvance;\n  if (globals.frameLoop) rafz.raf.frameLoop = globals.frameLoop;\n};\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  get createStringInterpolator () { return createStringInterpolator$1; },\n  get to () { return to; },\n  get colors () { return colors$1; },\n  get skipAnimation () { return skipAnimation; },\n  get willAdvance () { return willAdvance; },\n  assign: assign\n});\n\nconst startQueue = new Set();\nlet currentFrame = [];\nlet prevFrame = [];\nlet priority = 0;\nconst frameLoop = {\n  get idle() {\n    return !startQueue.size && !currentFrame.length;\n  },\n\n  start(animation) {\n    if (priority > animation.priority) {\n      startQueue.add(animation);\n      rafz.raf.onStart(flushStartQueue);\n    } else {\n      startSafely(animation);\n      rafz.raf(advance);\n    }\n  },\n\n  advance,\n\n  sort(animation) {\n    if (priority) {\n      rafz.raf.onFrame(() => frameLoop.sort(animation));\n    } else {\n      const prevIndex = currentFrame.indexOf(animation);\n\n      if (~prevIndex) {\n        currentFrame.splice(prevIndex, 1);\n        startUnsafely(animation);\n      }\n    }\n  },\n\n  clear() {\n    currentFrame = [];\n    startQueue.clear();\n  }\n\n};\n\nfunction flushStartQueue() {\n  startQueue.forEach(startSafely);\n  startQueue.clear();\n  rafz.raf(advance);\n}\n\nfunction startSafely(animation) {\n  if (!currentFrame.includes(animation)) startUnsafely(animation);\n}\n\nfunction startUnsafely(animation) {\n  currentFrame.splice(findIndex(currentFrame, other => other.priority > animation.priority), 0, animation);\n}\n\nfunction advance(dt) {\n  const nextFrame = prevFrame;\n\n  for (let i = 0; i < currentFrame.length; i++) {\n    const animation = currentFrame[i];\n    priority = animation.priority;\n\n    if (!animation.idle) {\n      willAdvance(animation);\n      animation.advance(dt);\n\n      if (!animation.idle) {\n        nextFrame.push(animation);\n      }\n    }\n  }\n\n  priority = 0;\n  prevFrame = currentFrame;\n  prevFrame.length = 0;\n  currentFrame = nextFrame;\n  return currentFrame.length > 0;\n}\n\nfunction findIndex(arr, test) {\n  const index = arr.findIndex(test);\n  return index < 0 ? arr.length : index;\n}\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst colors = {\n  transparent: 0x00000000,\n  aliceblue: 0xf0f8ffff,\n  antiquewhite: 0xfaebd7ff,\n  aqua: 0x00ffffff,\n  aquamarine: 0x7fffd4ff,\n  azure: 0xf0ffffff,\n  beige: 0xf5f5dcff,\n  bisque: 0xffe4c4ff,\n  black: 0x000000ff,\n  blanchedalmond: 0xffebcdff,\n  blue: 0x0000ffff,\n  blueviolet: 0x8a2be2ff,\n  brown: 0xa52a2aff,\n  burlywood: 0xdeb887ff,\n  burntsienna: 0xea7e5dff,\n  cadetblue: 0x5f9ea0ff,\n  chartreuse: 0x7fff00ff,\n  chocolate: 0xd2691eff,\n  coral: 0xff7f50ff,\n  cornflowerblue: 0x6495edff,\n  cornsilk: 0xfff8dcff,\n  crimson: 0xdc143cff,\n  cyan: 0x00ffffff,\n  darkblue: 0x00008bff,\n  darkcyan: 0x008b8bff,\n  darkgoldenrod: 0xb8860bff,\n  darkgray: 0xa9a9a9ff,\n  darkgreen: 0x006400ff,\n  darkgrey: 0xa9a9a9ff,\n  darkkhaki: 0xbdb76bff,\n  darkmagenta: 0x8b008bff,\n  darkolivegreen: 0x556b2fff,\n  darkorange: 0xff8c00ff,\n  darkorchid: 0x9932ccff,\n  darkred: 0x8b0000ff,\n  darksalmon: 0xe9967aff,\n  darkseagreen: 0x8fbc8fff,\n  darkslateblue: 0x483d8bff,\n  darkslategray: 0x2f4f4fff,\n  darkslategrey: 0x2f4f4fff,\n  darkturquoise: 0x00ced1ff,\n  darkviolet: 0x9400d3ff,\n  deeppink: 0xff1493ff,\n  deepskyblue: 0x00bfffff,\n  dimgray: 0x696969ff,\n  dimgrey: 0x696969ff,\n  dodgerblue: 0x1e90ffff,\n  firebrick: 0xb22222ff,\n  floralwhite: 0xfffaf0ff,\n  forestgreen: 0x228b22ff,\n  fuchsia: 0xff00ffff,\n  gainsboro: 0xdcdcdcff,\n  ghostwhite: 0xf8f8ffff,\n  gold: 0xffd700ff,\n  goldenrod: 0xdaa520ff,\n  gray: 0x808080ff,\n  green: 0x008000ff,\n  greenyellow: 0xadff2fff,\n  grey: 0x808080ff,\n  honeydew: 0xf0fff0ff,\n  hotpink: 0xff69b4ff,\n  indianred: 0xcd5c5cff,\n  indigo: 0x4b0082ff,\n  ivory: 0xfffff0ff,\n  khaki: 0xf0e68cff,\n  lavender: 0xe6e6faff,\n  lavenderblush: 0xfff0f5ff,\n  lawngreen: 0x7cfc00ff,\n  lemonchiffon: 0xfffacdff,\n  lightblue: 0xadd8e6ff,\n  lightcoral: 0xf08080ff,\n  lightcyan: 0xe0ffffff,\n  lightgoldenrodyellow: 0xfafad2ff,\n  lightgray: 0xd3d3d3ff,\n  lightgreen: 0x90ee90ff,\n  lightgrey: 0xd3d3d3ff,\n  lightpink: 0xffb6c1ff,\n  lightsalmon: 0xffa07aff,\n  lightseagreen: 0x20b2aaff,\n  lightskyblue: 0x87cefaff,\n  lightslategray: 0x778899ff,\n  lightslategrey: 0x778899ff,\n  lightsteelblue: 0xb0c4deff,\n  lightyellow: 0xffffe0ff,\n  lime: 0x00ff00ff,\n  limegreen: 0x32cd32ff,\n  linen: 0xfaf0e6ff,\n  magenta: 0xff00ffff,\n  maroon: 0x800000ff,\n  mediumaquamarine: 0x66cdaaff,\n  mediumblue: 0x0000cdff,\n  mediumorchid: 0xba55d3ff,\n  mediumpurple: 0x9370dbff,\n  mediumseagreen: 0x3cb371ff,\n  mediumslateblue: 0x7b68eeff,\n  mediumspringgreen: 0x00fa9aff,\n  mediumturquoise: 0x48d1ccff,\n  mediumvioletred: 0xc71585ff,\n  midnightblue: 0x191970ff,\n  mintcream: 0xf5fffaff,\n  mistyrose: 0xffe4e1ff,\n  moccasin: 0xffe4b5ff,\n  navajowhite: 0xffdeadff,\n  navy: 0x000080ff,\n  oldlace: 0xfdf5e6ff,\n  olive: 0x808000ff,\n  olivedrab: 0x6b8e23ff,\n  orange: 0xffa500ff,\n  orangered: 0xff4500ff,\n  orchid: 0xda70d6ff,\n  palegoldenrod: 0xeee8aaff,\n  palegreen: 0x98fb98ff,\n  paleturquoise: 0xafeeeeff,\n  palevioletred: 0xdb7093ff,\n  papayawhip: 0xffefd5ff,\n  peachpuff: 0xffdab9ff,\n  peru: 0xcd853fff,\n  pink: 0xffc0cbff,\n  plum: 0xdda0ddff,\n  powderblue: 0xb0e0e6ff,\n  purple: 0x800080ff,\n  rebeccapurple: 0x663399ff,\n  red: 0xff0000ff,\n  rosybrown: 0xbc8f8fff,\n  royalblue: 0x4169e1ff,\n  saddlebrown: 0x8b4513ff,\n  salmon: 0xfa8072ff,\n  sandybrown: 0xf4a460ff,\n  seagreen: 0x2e8b57ff,\n  seashell: 0xfff5eeff,\n  sienna: 0xa0522dff,\n  silver: 0xc0c0c0ff,\n  skyblue: 0x87ceebff,\n  slateblue: 0x6a5acdff,\n  slategray: 0x708090ff,\n  slategrey: 0x708090ff,\n  snow: 0xfffafaff,\n  springgreen: 0x00ff7fff,\n  steelblue: 0x4682b4ff,\n  tan: 0xd2b48cff,\n  teal: 0x008080ff,\n  thistle: 0xd8bfd8ff,\n  tomato: 0xff6347ff,\n  turquoise: 0x40e0d0ff,\n  violet: 0xee82eeff,\n  wheat: 0xf5deb3ff,\n  white: 0xffffffff,\n  whitesmoke: 0xf5f5f5ff,\n  yellow: 0xffff00ff,\n  yellowgreen: 0x9acd32ff\n};\n\nconst NUMBER = '[-+]?\\\\d*\\\\.?\\\\d+';\nconst PERCENTAGE = NUMBER + '%';\n\nfunction call(...parts) {\n  return '\\\\(\\\\s*(' + parts.join(')\\\\s*,\\\\s*(') + ')\\\\s*\\\\)';\n}\n\nconst rgb = new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER));\nconst rgba = new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER));\nconst hsl = new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE));\nconst hsla = new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\nconst hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\nconst hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\nconst hex6 = /^#([0-9a-fA-F]{6})$/;\nconst hex8 = /^#([0-9a-fA-F]{8})$/;\n\nfunction normalizeColor(color) {\n  let match;\n\n  if (typeof color === 'number') {\n    return color >>> 0 === color && color >= 0 && color <= 0xffffffff ? color : null;\n  }\n\n  if (match = hex6.exec(color)) return parseInt(match[1] + 'ff', 16) >>> 0;\n\n  if (colors$1 && colors$1[color] !== undefined) {\n    return colors$1[color];\n  }\n\n  if (match = rgb.exec(color)) {\n    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 0x000000ff) >>> 0;\n  }\n\n  if (match = rgba.exec(color)) {\n    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n  }\n\n  if (match = hex3.exec(color)) {\n    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + 'ff', 16) >>> 0;\n  }\n\n  if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;\n\n  if (match = hex4.exec(color)) {\n    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n  }\n\n  if (match = hsl.exec(color)) {\n    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 0x000000ff) >>> 0;\n  }\n\n  if (match = hsla.exec(color)) {\n    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n  }\n\n  return null;\n}\n\nfunction hue2rgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\n\nfunction parse255(str) {\n  const int = parseInt(str, 10);\n  if (int < 0) return 0;\n  if (int > 255) return 255;\n  return int;\n}\n\nfunction parse360(str) {\n  const int = parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\n\nfunction parse1(str) {\n  const num = parseFloat(str);\n  if (num < 0) return 0;\n  if (num > 1) return 255;\n  return Math.round(num * 255);\n}\n\nfunction parsePercentage(str) {\n  const int = parseFloat(str);\n  if (int < 0) return 0;\n  if (int > 100) return 1;\n  return int / 100;\n}\n\nfunction colorToRgba(input) {\n  let int32Color = normalizeColor(input);\n  if (int32Color === null) return input;\n  int32Color = int32Color || 0;\n  let r = (int32Color & 0xff000000) >>> 24;\n  let g = (int32Color & 0x00ff0000) >>> 16;\n  let b = (int32Color & 0x0000ff00) >>> 8;\n  let a = (int32Color & 0x000000ff) / 255;\n  return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n\nconst createInterpolator = (range, output, extrapolate) => {\n  if (is.fun(range)) {\n    return range;\n  }\n\n  if (is.arr(range)) {\n    return createInterpolator({\n      range,\n      output: output,\n      extrapolate\n    });\n  }\n\n  if (is.str(range.output[0])) {\n    return createStringInterpolator$1(range);\n  }\n\n  const config = range;\n  const outputRange = config.output;\n  const inputRange = config.range || [0, 1];\n  const extrapolateLeft = config.extrapolateLeft || config.extrapolate || 'extend';\n  const extrapolateRight = config.extrapolateRight || config.extrapolate || 'extend';\n\n  const easing = config.easing || (t => t);\n\n  return input => {\n    const range = findRange(input, inputRange);\n    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, config.map);\n  };\n};\n\nfunction interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {\n  let result = map ? map(input) : input;\n\n  if (result < inputMin) {\n    if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;\n  }\n\n  if (result > inputMax) {\n    if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;\n  }\n\n  if (outputMin === outputMax) return outputMin;\n  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax;\n  if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\n\nfunction findRange(input, inputRange) {\n  for (var i = 1; i < inputRange.length - 1; ++i) if (inputRange[i] >= input) break;\n\n  return i - 1;\n}\n\nconst steps = (steps, direction = 'end') => progress => {\n  progress = direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n  const expanded = progress * steps;\n  const rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\n  return clamp(0, 1, rounded / steps);\n};\n\nconst c1 = 1.70158;\nconst c2 = c1 * 1.525;\nconst c3 = c1 + 1;\nconst c4 = 2 * Math.PI / 3;\nconst c5 = 2 * Math.PI / 4.5;\n\nconst bounceOut = x => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984375;\n  }\n};\n\nconst easings = {\n  linear: x => x,\n  easeInQuad: x => x * x,\n  easeOutQuad: x => 1 - (1 - x) * (1 - x),\n  easeInOutQuad: x => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,\n  easeInCubic: x => x * x * x,\n  easeOutCubic: x => 1 - Math.pow(1 - x, 3),\n  easeInOutCubic: x => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,\n  easeInQuart: x => x * x * x * x,\n  easeOutQuart: x => 1 - Math.pow(1 - x, 4),\n  easeInOutQuart: x => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,\n  easeInQuint: x => x * x * x * x * x,\n  easeOutQuint: x => 1 - Math.pow(1 - x, 5),\n  easeInOutQuint: x => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,\n  easeInSine: x => 1 - Math.cos(x * Math.PI / 2),\n  easeOutSine: x => Math.sin(x * Math.PI / 2),\n  easeInOutSine: x => -(Math.cos(Math.PI * x) - 1) / 2,\n  easeInExpo: x => x === 0 ? 0 : Math.pow(2, 10 * x - 10),\n  easeOutExpo: x => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),\n  easeInOutExpo: x => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,\n  easeInCirc: x => 1 - Math.sqrt(1 - Math.pow(x, 2)),\n  easeOutCirc: x => Math.sqrt(1 - Math.pow(x - 1, 2)),\n  easeInOutCirc: x => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,\n  easeInBack: x => c3 * x * x * x - c1 * x * x,\n  easeOutBack: x => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),\n  easeInOutBack: x => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,\n  easeInElastic: x => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),\n  easeOutElastic: x => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,\n  easeInOutElastic: x => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,\n  easeInBounce: x => 1 - bounceOut(1 - x),\n  easeOutBounce: bounceOut,\n  easeInOutBounce: x => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,\n  steps\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nconst $get = Symbol.for('FluidValue.get');\nconst $observers = Symbol.for('FluidValue.observers');\n\nconst hasFluidValue = arg => Boolean(arg && arg[$get]);\n\nconst getFluidValue = arg => arg && arg[$get] ? arg[$get]() : arg;\n\nconst getFluidObservers = target => target[$observers] || null;\n\nfunction callFluidObserver(observer, event) {\n  if (observer.eventObserved) {\n    observer.eventObserved(event);\n  } else {\n    observer(event);\n  }\n}\n\nfunction callFluidObservers(target, event) {\n  let observers = target[$observers];\n\n  if (observers) {\n    observers.forEach(observer => {\n      callFluidObserver(observer, event);\n    });\n  }\n}\n\nclass FluidValue {\n  constructor(get) {\n    this[$get] = void 0;\n    this[$observers] = void 0;\n\n    if (!get && !(get = this.get)) {\n      throw Error('Unknown getter');\n    }\n\n    setFluidGetter(this, get);\n  }\n\n}\n\nconst setFluidGetter = (target, get) => setHidden(target, $get, get);\n\nfunction addFluidObserver(target, observer) {\n  if (target[$get]) {\n    let observers = target[$observers];\n\n    if (!observers) {\n      setHidden(target, $observers, observers = new Set());\n    }\n\n    if (!observers.has(observer)) {\n      observers.add(observer);\n\n      if (target.observerAdded) {\n        target.observerAdded(observers.size, observer);\n      }\n    }\n  }\n\n  return observer;\n}\n\nfunction removeFluidObserver(target, observer) {\n  let observers = target[$observers];\n\n  if (observers && observers.has(observer)) {\n    const count = observers.size - 1;\n\n    if (count) {\n      observers.delete(observer);\n    } else {\n      target[$observers] = null;\n    }\n\n    if (target.observerRemoved) {\n      target.observerRemoved(count, observer);\n    }\n  }\n}\n\nconst setHidden = (target, key, value) => Object.defineProperty(target, key, {\n  value,\n  writable: true,\n  configurable: true\n});\n\nconst numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nconst colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi;\nconst unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, 'i');\nconst rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi;\nconst cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nconst variableToRgba = input => {\n  const [token, fallback] = parseCSSVariable(input);\n\n  if (!token || isSSR()) {\n    return input;\n  }\n\n  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);\n\n  if (value) {\n    return value.trim();\n  } else if (fallback && fallback.startsWith('--')) {\n    const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);\n\n    if (_value) {\n      return _value;\n    } else {\n      return input;\n    }\n  } else if (fallback && cssVariableRegex.test(fallback)) {\n    return variableToRgba(fallback);\n  } else if (fallback) {\n    return fallback;\n  }\n\n  return input;\n};\n\nconst parseCSSVariable = current => {\n  const match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n};\n\nlet namedColorRegex;\n\nconst rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;\n\nconst createStringInterpolator = config => {\n  if (!namedColorRegex) namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join('|')})(?!\\\\w)`, 'g') : /^\\b$/;\n  const output = config.output.map(value => {\n    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);\n  });\n  const keyframes = output.map(value => value.match(numberRegex).map(Number));\n  const outputRanges = keyframes[0].map((_, i) => keyframes.map(values => {\n    if (!(i in values)) {\n      throw Error('The arity of each \"output\" value must be equal');\n    }\n\n    return values[i];\n  }));\n  const interpolators = outputRanges.map(output => createInterpolator(_extends({}, config, {\n    output\n  })));\n  return input => {\n    var _output$find;\n\n    const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find(value => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ''));\n    let i = 0;\n    return output[0].replace(numberRegex, () => `${interpolators[i++](input)}${missingUnit || ''}`).replace(rgbaRegex, rgbaRound);\n  };\n};\n\nconst prefix = 'react-spring: ';\nconst once = fn => {\n  const func = fn;\n  let called = false;\n\n  if (typeof func != 'function') {\n    throw new TypeError(`${prefix}once requires a function parameter`);\n  }\n\n  return (...args) => {\n    if (!called) {\n      func(...args);\n      called = true;\n    }\n  };\n};\nconst warnInterpolate = once(console.warn);\nfunction deprecateInterpolate() {\n  warnInterpolate(`${prefix}The \"interpolate\" function is deprecated in v9 (use \"to\" instead)`);\n}\nconst warnDirectCall = once(console.warn);\nfunction deprecateDirectCall() {\n  warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use \".start\" instead), this will be removed in later 0.X.0 versions`);\n}\n\nfunction isAnimatedString(value) {\n  return is.str(value) && (value[0] == '#' || /\\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));\n}\n\nlet observer;\nconst resizeHandlers = new WeakMap();\n\nconst handleObservation = entries => entries.forEach(({\n  target,\n  contentRect\n}) => {\n  var _resizeHandlers$get;\n\n  return (_resizeHandlers$get = resizeHandlers.get(target)) == null ? void 0 : _resizeHandlers$get.forEach(handler => handler(contentRect));\n});\n\nfunction resizeElement(handler, target) {\n  if (!observer) {\n    if (typeof ResizeObserver !== 'undefined') {\n      observer = new ResizeObserver(handleObservation);\n    }\n  }\n\n  let elementHandlers = resizeHandlers.get(target);\n\n  if (!elementHandlers) {\n    elementHandlers = new Set();\n    resizeHandlers.set(target, elementHandlers);\n  }\n\n  elementHandlers.add(handler);\n\n  if (observer) {\n    observer.observe(target);\n  }\n\n  return () => {\n    const elementHandlers = resizeHandlers.get(target);\n    if (!elementHandlers) return;\n    elementHandlers.delete(handler);\n\n    if (!elementHandlers.size && observer) {\n      observer.unobserve(target);\n    }\n  };\n}\n\nconst listeners = new Set();\nlet cleanupWindowResizeHandler;\n\nconst createResizeHandler = () => {\n  const handleResize = () => {\n    listeners.forEach(callback => callback({\n      width: window.innerWidth,\n      height: window.innerHeight\n    }));\n  };\n\n  window.addEventListener('resize', handleResize);\n  return () => {\n    window.removeEventListener('resize', handleResize);\n  };\n};\n\nconst resizeWindow = callback => {\n  listeners.add(callback);\n\n  if (!cleanupWindowResizeHandler) {\n    cleanupWindowResizeHandler = createResizeHandler();\n  }\n\n  return () => {\n    listeners.delete(callback);\n\n    if (!listeners.size && cleanupWindowResizeHandler) {\n      cleanupWindowResizeHandler();\n      cleanupWindowResizeHandler = undefined;\n    }\n  };\n};\n\nconst onResize = (callback, {\n  container: _container = document.documentElement\n} = {}) => {\n  if (_container === document.documentElement) {\n    return resizeWindow(callback);\n  } else {\n    return resizeElement(callback, _container);\n  }\n};\n\nconst progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\nconst SCROLL_KEYS = {\n  x: {\n    length: 'Width',\n    position: 'Left'\n  },\n  y: {\n    length: 'Height',\n    position: 'Top'\n  }\n};\nclass ScrollHandler {\n  constructor(callback, container) {\n    this.callback = void 0;\n    this.container = void 0;\n    this.info = void 0;\n\n    this.createAxis = () => ({\n      current: 0,\n      progress: 0,\n      scrollLength: 0\n    });\n\n    this.updateAxis = axisName => {\n      const axis = this.info[axisName];\n      const {\n        length,\n        position\n      } = SCROLL_KEYS[axisName];\n      axis.current = this.container[`scroll${position}`];\n      axis.scrollLength = this.container['scroll' + length] - this.container['client' + length];\n      axis.progress = progress(0, axis.scrollLength, axis.current);\n    };\n\n    this.update = () => {\n      this.updateAxis('x');\n      this.updateAxis('y');\n    };\n\n    this.sendEvent = () => {\n      this.callback(this.info);\n    };\n\n    this.advance = () => {\n      this.update();\n      this.sendEvent();\n    };\n\n    this.callback = callback;\n    this.container = container;\n    this.info = {\n      time: 0,\n      x: this.createAxis(),\n      y: this.createAxis()\n    };\n  }\n\n}\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\n\nconst getTarget = container => container === document.documentElement ? window : container;\n\nconst onScroll = (callback, {\n  container: _container = document.documentElement\n} = {}) => {\n  let containerHandlers = onScrollHandlers.get(_container);\n\n  if (!containerHandlers) {\n    containerHandlers = new Set();\n    onScrollHandlers.set(_container, containerHandlers);\n  }\n\n  const containerHandler = new ScrollHandler(callback, _container);\n  containerHandlers.add(containerHandler);\n\n  if (!scrollListeners.has(_container)) {\n    const listener = () => {\n      var _containerHandlers;\n\n      (_containerHandlers = containerHandlers) == null ? void 0 : _containerHandlers.forEach(handler => handler.advance());\n      return true;\n    };\n\n    scrollListeners.set(_container, listener);\n    const target = getTarget(_container);\n    window.addEventListener('resize', listener, {\n      passive: true\n    });\n\n    if (_container !== document.documentElement) {\n      resizeListeners.set(_container, onResize(listener, {\n        container: _container\n      }));\n    }\n\n    target.addEventListener('scroll', listener, {\n      passive: true\n    });\n  }\n\n  const animateScroll = scrollListeners.get(_container);\n  rafz.raf(animateScroll);\n  return () => {\n    rafz.raf.cancel(animateScroll);\n    const containerHandlers = onScrollHandlers.get(_container);\n    if (!containerHandlers) return;\n    containerHandlers.delete(containerHandler);\n    if (containerHandlers.size) return;\n    const listener = scrollListeners.get(_container);\n    scrollListeners.delete(_container);\n\n    if (listener) {\n      var _resizeListeners$get;\n\n      getTarget(_container).removeEventListener('scroll', listener);\n      window.removeEventListener('resize', listener);\n      (_resizeListeners$get = resizeListeners.get(_container)) == null ? void 0 : _resizeListeners$get();\n    }\n  };\n};\n\nfunction useConstant(init) {\n  const ref = react.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = init();\n  }\n\n  return ref.current;\n}\n\nconst useIsomorphicLayoutEffect = isSSR() ? react.useEffect : react.useLayoutEffect;\n\nconst useIsMounted = () => {\n  const isMounted = react.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  return isMounted;\n};\n\nfunction useForceUpdate() {\n  const update = react.useState()[1];\n  const isMounted = useIsMounted();\n  return () => {\n    if (isMounted.current) {\n      update(Math.random());\n    }\n  };\n}\n\nfunction useMemoOne(getResult, inputs) {\n  const [initial] = react.useState(() => ({\n    inputs,\n    result: getResult()\n  }));\n  const committed = react.useRef();\n  const prevCache = committed.current;\n  let cache = prevCache;\n\n  if (cache) {\n    const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));\n\n    if (!useCache) {\n      cache = {\n        inputs,\n        result: getResult()\n      };\n    }\n  } else {\n    cache = initial;\n  }\n\n  react.useEffect(() => {\n    committed.current = cache;\n\n    if (prevCache == initial) {\n      initial.inputs = initial.result = undefined;\n    }\n  }, [cache]);\n  return cache.result;\n}\n\nfunction areInputsEqual(next, prev) {\n  if (next.length !== prev.length) {\n    return false;\n  }\n\n  for (let i = 0; i < next.length; i++) {\n    if (next[i] !== prev[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst useOnce = effect => react.useEffect(effect, emptyDeps);\nconst emptyDeps = [];\n\nfunction usePrev(value) {\n  const prevRef = react.useRef();\n  react.useEffect(() => {\n    prevRef.current = value;\n  });\n  return prevRef.current;\n}\n\nconst useReducedMotion = () => {\n  const [reducedMotion, setReducedMotion] = react.useState(null);\n  useIsomorphicLayoutEffect(() => {\n    const mql = window.matchMedia('(prefers-reduced-motion)');\n\n    const handleMediaChange = e => {\n      setReducedMotion(e.matches);\n      assign({\n        skipAnimation: e.matches\n      });\n    };\n\n    handleMediaChange(mql);\n    mql.addEventListener('change', handleMediaChange);\n    return () => {\n      mql.removeEventListener('change', handleMediaChange);\n    };\n  }, []);\n  return reducedMotion;\n};\n\nObject.defineProperty(exports, \"raf\", ({\n  enumerable: true,\n  get: function () { return rafz.raf; }\n}));\nexports.FluidValue = FluidValue;\nexports.Globals = globals;\nexports.addFluidObserver = addFluidObserver;\nexports.callFluidObserver = callFluidObserver;\nexports.callFluidObservers = callFluidObservers;\nexports.clamp = clamp;\nexports.colorToRgba = colorToRgba;\nexports.colors = colors;\nexports.createInterpolator = createInterpolator;\nexports.createStringInterpolator = createStringInterpolator;\nexports.defineHidden = defineHidden;\nexports.deprecateDirectCall = deprecateDirectCall;\nexports.deprecateInterpolate = deprecateInterpolate;\nexports.each = each;\nexports.eachProp = eachProp;\nexports.easings = easings;\nexports.flush = flush;\nexports.flushCalls = flushCalls;\nexports.frameLoop = frameLoop;\nexports.getFluidObservers = getFluidObservers;\nexports.getFluidValue = getFluidValue;\nexports.hasFluidValue = hasFluidValue;\nexports.hex3 = hex3;\nexports.hex4 = hex4;\nexports.hex6 = hex6;\nexports.hex8 = hex8;\nexports.hsl = hsl;\nexports.hsla = hsla;\nexports.is = is;\nexports.isAnimatedString = isAnimatedString;\nexports.isEqual = isEqual;\nexports.isSSR = isSSR;\nexports.noop = noop;\nexports.onResize = onResize;\nexports.onScroll = onScroll;\nexports.once = once;\nexports.prefix = prefix;\nexports.removeFluidObserver = removeFluidObserver;\nexports.rgb = rgb;\nexports.rgba = rgba;\nexports.setFluidGetter = setFluidGetter;\nexports.toArray = toArray;\nexports.useConstant = useConstant;\nexports.useForceUpdate = useForceUpdate;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.useMemoOne = useMemoOne;\nexports.useOnce = useOnce;\nexports.usePrev = usePrev;\nexports.useReducedMotion = useReducedMotion;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9zaGFyZWQvZGlzdC9yZWFjdC1zcHJpbmctc2hhcmVkLmNqcy5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxXQUFXLG1CQUFPLENBQUMsaUdBQW9CO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyw4QkFBOEIsRUFBRTtBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFLGNBQWMsWUFBWTtBQUMxQixrQkFBa0Isa0JBQWtCO0FBQ3BDLHlCQUF5Qix1QkFBdUI7QUFDaEQsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDL0QsNkJBQTZCLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDL0UsNkJBQTZCLEVBQUU7QUFDL0IsNkJBQTZCLEVBQUU7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBLCtDQUErQywyREFBMkQ7QUFDMUc7QUFDQSxnREFBZ0QsNkRBQTZEO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkJBQTJCOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esa0NBQWtDLEVBQUUsRUFBRSxJQUFJLFlBQVksRUFBRSwrQkFBK0IsSUFBSTtBQUMzRixpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQsZUFBZSxJQUFJLGVBQWUsSUFBSSxlQUFlLElBQUksR0FBRzs7QUFFN0c7QUFDQSxvRUFBb0UsZ0NBQWdDO0FBQ3BHO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxpRkFBaUY7QUFDakY7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELDBCQUEwQixFQUFFLGtCQUFrQjtBQUNqRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQSxzSUFBc0k7QUFDdEk7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsdUNBQXNDO0FBQ3RDO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUMsRUFBQztBQUNGLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Ysd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsYUFBYTtBQUNiLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QsMEJBQTBCO0FBQzFCLGdDQUFnQztBQUNoQyxvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QixZQUFZO0FBQ1osZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osV0FBVztBQUNYLFlBQVk7QUFDWixVQUFVO0FBQ1Ysd0JBQXdCO0FBQ3hCLGVBQWU7QUFDZixhQUFhO0FBQ2IsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLGNBQWM7QUFDZCwyQkFBMkI7QUFDM0IsV0FBVztBQUNYLFlBQVk7QUFDWixzQkFBc0I7QUFDdEIsZUFBZTtBQUNmLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsaUNBQWlDO0FBQ2pDLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsZUFBZTtBQUNmLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL3NoYXJlZC9kaXN0L3JlYWN0LXNwcmluZy1zaGFyZWQuY2pzLmRldi5qcz84NTI3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHJhZnogPSByZXF1aXJlKCdAcmVhY3Qtc3ByaW5nL3JhZnonKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgZGVmaW5lSGlkZGVuID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gIHZhbHVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcbmNvbnN0IGlzID0ge1xuICBhcnI6IEFycmF5LmlzQXJyYXksXG4gIG9iajogYSA9PiAhIWEgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyxcbiAgZnVuOiBhID0+IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nLFxuICBzdHI6IGEgPT4gdHlwZW9mIGEgPT09ICdzdHJpbmcnLFxuICBudW06IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInLFxuICB1bmQ6IGEgPT4gYSA9PT0gdW5kZWZpbmVkXG59O1xuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIGlmIChpcy5hcnIoYSkpIHtcbiAgICBpZiAoIWlzLmFycihiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBhID09PSBiO1xufVxuY29uc3QgZWFjaCA9IChvYmosIGZuKSA9PiBvYmouZm9yRWFjaChmbik7XG5mdW5jdGlvbiBlYWNoUHJvcChvYmosIGZuLCBjdHgpIHtcbiAgaWYgKGlzLmFycihvYmopKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGAke2l9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBmbi5jYWxsKGN0eCwgb2JqW2tleV0sIGtleSk7XG4gICAgfVxuICB9XG59XG5jb25zdCB0b0FycmF5ID0gYSA9PiBpcy51bmQoYSkgPyBbXSA6IGlzLmFycihhKSA/IGEgOiBbYV07XG5mdW5jdGlvbiBmbHVzaChxdWV1ZSwgaXRlcmF0b3IpIHtcbiAgaWYgKHF1ZXVlLnNpemUpIHtcbiAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20ocXVldWUpO1xuICAgIHF1ZXVlLmNsZWFyKCk7XG4gICAgZWFjaChpdGVtcywgaXRlcmF0b3IpO1xuICB9XG59XG5jb25zdCBmbHVzaENhbGxzID0gKHF1ZXVlLCAuLi5hcmdzKSA9PiBmbHVzaChxdWV1ZSwgZm4gPT4gZm4oLi4uYXJncykpO1xuY29uc3QgaXNTU1IgPSAoKSA9PiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5hdmlnYXRvciB8fCAvU2VydmVyU2lkZVJlbmRlcmluZ3xeRGVub1xcLy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmxldCBjcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3IkMTtcbmxldCB0bztcbmxldCBjb2xvcnMkMSA9IG51bGw7XG5sZXQgc2tpcEFuaW1hdGlvbiA9IGZhbHNlO1xubGV0IHdpbGxBZHZhbmNlID0gbm9vcDtcbmNvbnN0IGFzc2lnbiA9IGdsb2JhbHMgPT4ge1xuICBpZiAoZ2xvYmFscy50bykgdG8gPSBnbG9iYWxzLnRvO1xuICBpZiAoZ2xvYmFscy5ub3cpIHJhZnoucmFmLm5vdyA9IGdsb2JhbHMubm93O1xuICBpZiAoZ2xvYmFscy5jb2xvcnMgIT09IHVuZGVmaW5lZCkgY29sb3JzJDEgPSBnbG9iYWxzLmNvbG9ycztcbiAgaWYgKGdsb2JhbHMuc2tpcEFuaW1hdGlvbiAhPSBudWxsKSBza2lwQW5pbWF0aW9uID0gZ2xvYmFscy5za2lwQW5pbWF0aW9uO1xuICBpZiAoZ2xvYmFscy5jcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3IpIGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvciQxID0gZ2xvYmFscy5jcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3I7XG4gIGlmIChnbG9iYWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZSkgcmFmei5yYWYudXNlKGdsb2JhbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcbiAgaWYgKGdsb2JhbHMuYmF0Y2hlZFVwZGF0ZXMpIHJhZnoucmFmLmJhdGNoZWRVcGRhdGVzID0gZ2xvYmFscy5iYXRjaGVkVXBkYXRlcztcbiAgaWYgKGdsb2JhbHMud2lsbEFkdmFuY2UpIHdpbGxBZHZhbmNlID0gZ2xvYmFscy53aWxsQWR2YW5jZTtcbiAgaWYgKGdsb2JhbHMuZnJhbWVMb29wKSByYWZ6LnJhZi5mcmFtZUxvb3AgPSBnbG9iYWxzLmZyYW1lTG9vcDtcbn07XG5cbnZhciBnbG9iYWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdldCBjcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3IgKCkgeyByZXR1cm4gY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yJDE7IH0sXG4gIGdldCB0byAoKSB7IHJldHVybiB0bzsgfSxcbiAgZ2V0IGNvbG9ycyAoKSB7IHJldHVybiBjb2xvcnMkMTsgfSxcbiAgZ2V0IHNraXBBbmltYXRpb24gKCkgeyByZXR1cm4gc2tpcEFuaW1hdGlvbjsgfSxcbiAgZ2V0IHdpbGxBZHZhbmNlICgpIHsgcmV0dXJuIHdpbGxBZHZhbmNlOyB9LFxuICBhc3NpZ246IGFzc2lnblxufSk7XG5cbmNvbnN0IHN0YXJ0UXVldWUgPSBuZXcgU2V0KCk7XG5sZXQgY3VycmVudEZyYW1lID0gW107XG5sZXQgcHJldkZyYW1lID0gW107XG5sZXQgcHJpb3JpdHkgPSAwO1xuY29uc3QgZnJhbWVMb29wID0ge1xuICBnZXQgaWRsZSgpIHtcbiAgICByZXR1cm4gIXN0YXJ0UXVldWUuc2l6ZSAmJiAhY3VycmVudEZyYW1lLmxlbmd0aDtcbiAgfSxcblxuICBzdGFydChhbmltYXRpb24pIHtcbiAgICBpZiAocHJpb3JpdHkgPiBhbmltYXRpb24ucHJpb3JpdHkpIHtcbiAgICAgIHN0YXJ0UXVldWUuYWRkKGFuaW1hdGlvbik7XG4gICAgICByYWZ6LnJhZi5vblN0YXJ0KGZsdXNoU3RhcnRRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0U2FmZWx5KGFuaW1hdGlvbik7XG4gICAgICByYWZ6LnJhZihhZHZhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgYWR2YW5jZSxcblxuICBzb3J0KGFuaW1hdGlvbikge1xuICAgIGlmIChwcmlvcml0eSkge1xuICAgICAgcmFmei5yYWYub25GcmFtZSgoKSA9PiBmcmFtZUxvb3Auc29ydChhbmltYXRpb24pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJldkluZGV4ID0gY3VycmVudEZyYW1lLmluZGV4T2YoYW5pbWF0aW9uKTtcblxuICAgICAgaWYgKH5wcmV2SW5kZXgpIHtcbiAgICAgICAgY3VycmVudEZyYW1lLnNwbGljZShwcmV2SW5kZXgsIDEpO1xuICAgICAgICBzdGFydFVuc2FmZWx5KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNsZWFyKCkge1xuICAgIGN1cnJlbnRGcmFtZSA9IFtdO1xuICAgIHN0YXJ0UXVldWUuY2xlYXIoKTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBmbHVzaFN0YXJ0UXVldWUoKSB7XG4gIHN0YXJ0UXVldWUuZm9yRWFjaChzdGFydFNhZmVseSk7XG4gIHN0YXJ0UXVldWUuY2xlYXIoKTtcbiAgcmFmei5yYWYoYWR2YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0U2FmZWx5KGFuaW1hdGlvbikge1xuICBpZiAoIWN1cnJlbnRGcmFtZS5pbmNsdWRlcyhhbmltYXRpb24pKSBzdGFydFVuc2FmZWx5KGFuaW1hdGlvbik7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VW5zYWZlbHkoYW5pbWF0aW9uKSB7XG4gIGN1cnJlbnRGcmFtZS5zcGxpY2UoZmluZEluZGV4KGN1cnJlbnRGcmFtZSwgb3RoZXIgPT4gb3RoZXIucHJpb3JpdHkgPiBhbmltYXRpb24ucHJpb3JpdHkpLCAwLCBhbmltYXRpb24pO1xufVxuXG5mdW5jdGlvbiBhZHZhbmNlKGR0KSB7XG4gIGNvbnN0IG5leHRGcmFtZSA9IHByZXZGcmFtZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRGcmFtZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGN1cnJlbnRGcmFtZVtpXTtcbiAgICBwcmlvcml0eSA9IGFuaW1hdGlvbi5wcmlvcml0eTtcblxuICAgIGlmICghYW5pbWF0aW9uLmlkbGUpIHtcbiAgICAgIHdpbGxBZHZhbmNlKGFuaW1hdGlvbik7XG4gICAgICBhbmltYXRpb24uYWR2YW5jZShkdCk7XG5cbiAgICAgIGlmICghYW5pbWF0aW9uLmlkbGUpIHtcbiAgICAgICAgbmV4dEZyYW1lLnB1c2goYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcmlvcml0eSA9IDA7XG4gIHByZXZGcmFtZSA9IGN1cnJlbnRGcmFtZTtcbiAgcHJldkZyYW1lLmxlbmd0aCA9IDA7XG4gIGN1cnJlbnRGcmFtZSA9IG5leHRGcmFtZTtcbiAgcmV0dXJuIGN1cnJlbnRGcmFtZS5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCB0ZXN0KSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyLmZpbmRJbmRleCh0ZXN0KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IGFyci5sZW5ndGggOiBpbmRleDtcbn1cblxuY29uc3QgY2xhbXAgPSAobWluLCBtYXgsIHYpID0+IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG5cbmNvbnN0IGNvbG9ycyA9IHtcbiAgdHJhbnNwYXJlbnQ6IDB4MDAwMDAwMDAsXG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmZmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkN2ZmLFxuICBhcXVhOiAweDAwZmZmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNGZmLFxuICBhenVyZTogMHhmMGZmZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjZmYsXG4gIGJpc3F1ZTogMHhmZmU0YzRmZixcbiAgYmxhY2s6IDB4MDAwMDAwZmYsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZGZmLFxuICBibHVlOiAweDAwMDBmZmZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMmZmLFxuICBicm93bjogMHhhNTJhMmFmZixcbiAgYnVybHl3b29kOiAweGRlYjg4N2ZmLFxuICBidXJudHNpZW5uYTogMHhlYTdlNWRmZixcbiAgY2FkZXRibHVlOiAweDVmOWVhMGZmLFxuICBjaGFydHJldXNlOiAweDdmZmYwMGZmLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlZmYsXG4gIGNvcmFsOiAweGZmN2Y1MGZmLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWRmZixcbiAgY29ybnNpbGs6IDB4ZmZmOGRjZmYsXG4gIGNyaW1zb246IDB4ZGMxNDNjZmYsXG4gIGN5YW46IDB4MDBmZmZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YmZmLFxuICBkYXJrY3lhbjogMHgwMDhiOGJmZixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGJmZixcbiAgZGFya2dyYXk6IDB4YTlhOWE5ZmYsXG4gIGRhcmtncmVlbjogMHgwMDY0MDBmZixcbiAgZGFya2dyZXk6IDB4YTlhOWE5ZmYsXG4gIGRhcmtraGFraTogMHhiZGI3NmJmZixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiZmYsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZmZmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMGZmLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjY2ZmLFxuICBkYXJrcmVkOiAweDhiMDAwMGZmLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YWZmLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmZmYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiZmYsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmZmYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmZmYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxZmYsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzZmYsXG4gIGRlZXBwaW5rOiAweGZmMTQ5M2ZmLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjlmZixcbiAgZGltZ3JleTogMHg2OTY5NjlmZixcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmZmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMmZmLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjBmZixcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyZmYsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGNmZixcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmZmZixcbiAgZ29sZDogMHhmZmQ3MDBmZixcbiAgZ29sZGVucm9kOiAweGRhYTUyMGZmLFxuICBncmF5OiAweDgwODA4MGZmLFxuICBncmVlbjogMHgwMDgwMDBmZixcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmZmYsXG4gIGdyZXk6IDB4ODA4MDgwZmYsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMGZmLFxuICBob3RwaW5rOiAweGZmNjliNGZmLFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjZmYsXG4gIGluZGlnbzogMHg0YjAwODJmZixcbiAgaXZvcnk6IDB4ZmZmZmYwZmYsXG4gIGtoYWtpOiAweGYwZTY4Y2ZmLFxuICBsYXZlbmRlcjogMHhlNmU2ZmFmZixcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjVmZixcbiAgbGF3bmdyZWVuOiAweDdjZmMwMGZmLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkZmYsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTZmZixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODBmZixcbiAgbGlnaHRjeWFuOiAweGUwZmZmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDJmZixcbiAgbGlnaHRncmF5OiAweGQzZDNkM2ZmLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MGZmLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzZmYsXG4gIGxpZ2h0cGluazogMHhmZmI2YzFmZixcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhZmYsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhZmYsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmFmZixcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5ZmYsXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OWZmLFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGVmZixcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwZmYsXG4gIGxpbWU6IDB4MDBmZjAwZmYsXG4gIGxpbWVncmVlbjogMHgzMmNkMzJmZixcbiAgbGluZW46IDB4ZmFmMGU2ZmYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmZmYsXG4gIG1hcm9vbjogMHg4MDAwMDBmZixcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWFmZixcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2RmZixcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkM2ZmLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiZmYsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MWZmLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlZmYsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YWZmLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjZmYsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODVmZixcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MGZmLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhZmYsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTFmZixcbiAgbW9jY2FzaW46IDB4ZmZlNGI1ZmYsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZGZmLFxuICBuYXZ5OiAweDAwMDA4MGZmLFxuICBvbGRsYWNlOiAweGZkZjVlNmZmLFxuICBvbGl2ZTogMHg4MDgwMDBmZixcbiAgb2xpdmVkcmFiOiAweDZiOGUyM2ZmLFxuICBvcmFuZ2U6IDB4ZmZhNTAwZmYsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDBmZixcbiAgb3JjaGlkOiAweGRhNzBkNmZmLFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYWZmLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4ZmYsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlZmYsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzZmYsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1ZmYsXG4gIHBlYWNocHVmZjogMHhmZmRhYjlmZixcbiAgcGVydTogMHhjZDg1M2ZmZixcbiAgcGluazogMHhmZmMwY2JmZixcbiAgcGx1bTogMHhkZGEwZGRmZixcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTZmZixcbiAgcHVycGxlOiAweDgwMDA4MGZmLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OWZmLFxuICByZWQ6IDB4ZmYwMDAwZmYsXG4gIHJvc3licm93bjogMHhiYzhmOGZmZixcbiAgcm95YWxibHVlOiAweDQxNjllMWZmLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTNmZixcbiAgc2FsbW9uOiAweGZhODA3MmZmLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MGZmLFxuICBzZWFncmVlbjogMHgyZThiNTdmZixcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlZmYsXG4gIHNpZW5uYTogMHhhMDUyMmRmZixcbiAgc2lsdmVyOiAweGMwYzBjMGZmLFxuICBza3libHVlOiAweDg3Y2VlYmZmLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkZmYsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTBmZixcbiAgc2xhdGVncmV5OiAweDcwODA5MGZmLFxuICBzbm93OiAweGZmZmFmYWZmLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2ZmZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNGZmLFxuICB0YW46IDB4ZDJiNDhjZmYsXG4gIHRlYWw6IDB4MDA4MDgwZmYsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4ZmYsXG4gIHRvbWF0bzogMHhmZjYzNDdmZixcbiAgdHVycXVvaXNlOiAweDQwZTBkMGZmLFxuICB2aW9sZXQ6IDB4ZWU4MmVlZmYsXG4gIHdoZWF0OiAweGY1ZGViM2ZmLFxuICB3aGl0ZTogMHhmZmZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjVmZixcbiAgeWVsbG93OiAweGZmZmYwMGZmLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJmZlxufTtcblxuY29uc3QgTlVNQkVSID0gJ1stK10/XFxcXGQqXFxcXC4/XFxcXGQrJztcbmNvbnN0IFBFUkNFTlRBR0UgPSBOVU1CRVIgKyAnJSc7XG5cbmZ1bmN0aW9uIGNhbGwoLi4ucGFydHMpIHtcbiAgcmV0dXJuICdcXFxcKFxcXFxzKignICsgcGFydHMuam9pbignKVxcXFxzKixcXFxccyooJykgKyAnKVxcXFxzKlxcXFwpJztcbn1cblxuY29uc3QgcmdiID0gbmV3IFJlZ0V4cCgncmdiJyArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuY29uc3QgcmdiYSA9IG5ldyBSZWdFeHAoJ3JnYmEnICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbmNvbnN0IGhzbCA9IG5ldyBSZWdFeHAoJ2hzbCcgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuY29uc3QgaHNsYSA9IG5ldyBSZWdFeHAoJ2hzbGEnICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuY29uc3QgaGV4MyA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuY29uc3QgaGV4NCA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbmNvbnN0IGhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG5jb25zdCBoZXg4ID0gL14jKFswLTlhLWZBLUZdezh9KSQvO1xuXG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICBsZXQgbWF0Y2g7XG5cbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY29sb3IgPj4+IDAgPT09IGNvbG9yICYmIGNvbG9yID49IDAgJiYgY29sb3IgPD0gMHhmZmZmZmZmZiA/IGNvbG9yIDogbnVsbDtcbiAgfVxuXG4gIGlmIChtYXRjaCA9IGhleDYuZXhlYyhjb2xvcikpIHJldHVybiBwYXJzZUludChtYXRjaFsxXSArICdmZicsIDE2KSA+Pj4gMDtcblxuICBpZiAoY29sb3JzJDEgJiYgY29sb3JzJDFbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29sb3JzJDFbY29sb3JdO1xuICB9XG5cbiAgaWYgKG1hdGNoID0gcmdiLmV4ZWMoY29sb3IpKSB7XG4gICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IDB4MDAwMDAwZmYpID4+PiAwO1xuICB9XG5cbiAgaWYgKG1hdGNoID0gcmdiYS5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgfVxuXG4gIGlmIChtYXRjaCA9IGhleDMuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgJ2ZmJywgMTYpID4+PiAwO1xuICB9XG5cbiAgaWYgKG1hdGNoID0gaGV4OC5leGVjKGNvbG9yKSkgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxNikgPj4+IDA7XG5cbiAgaWYgKG1hdGNoID0gaGV4NC5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSArIG1hdGNoWzFdICsgbWF0Y2hbMl0gKyBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbM10gKyBtYXRjaFs0XSArIG1hdGNoWzRdLCAxNikgPj4+IDA7XG4gIH1cblxuICBpZiAobWF0Y2ggPSBoc2wuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCAweDAwMDAwMGZmKSA+Pj4gMDtcbiAgfVxuXG4gIGlmIChtYXRjaCA9IGhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gIGlmICh0ID4gMSkgdCAtPSAxO1xuICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gIGNvbnN0IHAgPSAyICogbCAtIHE7XG4gIGNvbnN0IHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gIGNvbnN0IGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICBjb25zdCBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChyICogMjU1KSA8PCAyNCB8IE1hdGgucm91bmQoZyAqIDI1NSkgPDwgMTYgfCBNYXRoLnJvdW5kKGIgKiAyNTUpIDw8IDg7XG59XG5cbmZ1bmN0aW9uIHBhcnNlMjU1KHN0cikge1xuICBjb25zdCBpbnQgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApIHJldHVybiAwO1xuICBpZiAoaW50ID4gMjU1KSByZXR1cm4gMjU1O1xuICByZXR1cm4gaW50O1xufVxuXG5mdW5jdGlvbiBwYXJzZTM2MChzdHIpIHtcbiAgY29uc3QgaW50ID0gcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gKGludCAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChzdHIpO1xuICBpZiAobnVtIDwgMCkgcmV0dXJuIDA7XG4gIGlmIChudW0gPiAxKSByZXR1cm4gMjU1O1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAyNTUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBlcmNlbnRhZ2Uoc3RyKSB7XG4gIGNvbnN0IGludCA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKGludCA8IDApIHJldHVybiAwO1xuICBpZiAoaW50ID4gMTAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cblxuZnVuY3Rpb24gY29sb3JUb1JnYmEoaW5wdXQpIHtcbiAgbGV0IGludDMyQ29sb3IgPSBub3JtYWxpemVDb2xvcihpbnB1dCk7XG4gIGlmIChpbnQzMkNvbG9yID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIGludDMyQ29sb3IgPSBpbnQzMkNvbG9yIHx8IDA7XG4gIGxldCByID0gKGludDMyQ29sb3IgJiAweGZmMDAwMDAwKSA+Pj4gMjQ7XG4gIGxldCBnID0gKGludDMyQ29sb3IgJiAweDAwZmYwMDAwKSA+Pj4gMTY7XG4gIGxldCBiID0gKGludDMyQ29sb3IgJiAweDAwMDBmZjAwKSA+Pj4gODtcbiAgbGV0IGEgPSAoaW50MzJDb2xvciAmIDB4MDAwMDAwZmYpIC8gMjU1O1xuICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xufVxuXG5jb25zdCBjcmVhdGVJbnRlcnBvbGF0b3IgPSAocmFuZ2UsIG91dHB1dCwgZXh0cmFwb2xhdGUpID0+IHtcbiAgaWYgKGlzLmZ1bihyYW5nZSkpIHtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBpZiAoaXMuYXJyKHJhbmdlKSkge1xuICAgIHJldHVybiBjcmVhdGVJbnRlcnBvbGF0b3Ioe1xuICAgICAgcmFuZ2UsXG4gICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgIGV4dHJhcG9sYXRlXG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXMuc3RyKHJhbmdlLm91dHB1dFswXSkpIHtcbiAgICByZXR1cm4gY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yJDEocmFuZ2UpO1xuICB9XG5cbiAgY29uc3QgY29uZmlnID0gcmFuZ2U7XG4gIGNvbnN0IG91dHB1dFJhbmdlID0gY29uZmlnLm91dHB1dDtcbiAgY29uc3QgaW5wdXRSYW5nZSA9IGNvbmZpZy5yYW5nZSB8fCBbMCwgMV07XG4gIGNvbnN0IGV4dHJhcG9sYXRlTGVmdCA9IGNvbmZpZy5leHRyYXBvbGF0ZUxlZnQgfHwgY29uZmlnLmV4dHJhcG9sYXRlIHx8ICdleHRlbmQnO1xuICBjb25zdCBleHRyYXBvbGF0ZVJpZ2h0ID0gY29uZmlnLmV4dHJhcG9sYXRlUmlnaHQgfHwgY29uZmlnLmV4dHJhcG9sYXRlIHx8ICdleHRlbmQnO1xuXG4gIGNvbnN0IGVhc2luZyA9IGNvbmZpZy5lYXNpbmcgfHwgKHQgPT4gdCk7XG5cbiAgcmV0dXJuIGlucHV0ID0+IHtcbiAgICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlW3JhbmdlXSwgaW5wdXRSYW5nZVtyYW5nZSArIDFdLCBvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV0sIGVhc2luZywgZXh0cmFwb2xhdGVMZWZ0LCBleHRyYXBvbGF0ZVJpZ2h0LCBjb25maWcubWFwKTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dE1pbiwgaW5wdXRNYXgsIG91dHB1dE1pbiwgb3V0cHV0TWF4LCBlYXNpbmcsIGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgbWFwKSB7XG4gIGxldCByZXN1bHQgPSBtYXAgPyBtYXAoaW5wdXQpIDogaW5wdXQ7XG5cbiAgaWYgKHJlc3VsdCA8IGlucHV0TWluKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gJ2lkZW50aXR5JykgcmV0dXJuIHJlc3VsdDtlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09ICdjbGFtcCcpIHJlc3VsdCA9IGlucHV0TWluO1xuICB9XG5cbiAgaWYgKHJlc3VsdCA+IGlucHV0TWF4KSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09ICdpZGVudGl0eScpIHJldHVybiByZXN1bHQ7ZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gJ2NsYW1wJykgcmVzdWx0ID0gaW5wdXRNYXg7XG4gIH1cblxuICBpZiAob3V0cHV0TWluID09PSBvdXRwdXRNYXgpIHJldHVybiBvdXRwdXRNaW47XG4gIGlmIChpbnB1dE1pbiA9PT0gaW5wdXRNYXgpIHJldHVybiBpbnB1dCA8PSBpbnB1dE1pbiA/IG91dHB1dE1pbiA6IG91dHB1dE1heDtcbiAgaWYgKGlucHV0TWluID09PSAtSW5maW5pdHkpIHJlc3VsdCA9IC1yZXN1bHQ7ZWxzZSBpZiAoaW5wdXRNYXggPT09IEluZmluaXR5KSByZXN1bHQgPSByZXN1bHQgLSBpbnB1dE1pbjtlbHNlIHJlc3VsdCA9IChyZXN1bHQgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbik7XG4gIHJlc3VsdCA9IGVhc2luZyhyZXN1bHQpO1xuICBpZiAob3V0cHV0TWluID09PSAtSW5maW5pdHkpIHJlc3VsdCA9IC1yZXN1bHQ7ZWxzZSBpZiAob3V0cHV0TWF4ID09PSBJbmZpbml0eSkgcmVzdWx0ID0gcmVzdWx0ICsgb3V0cHV0TWluO2Vsc2UgcmVzdWx0ID0gcmVzdWx0ICogKG91dHB1dE1heCAtIG91dHB1dE1pbikgKyBvdXRwdXRNaW47XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSBpZiAoaW5wdXRSYW5nZVtpXSA+PSBpbnB1dCkgYnJlYWs7XG5cbiAgcmV0dXJuIGkgLSAxO1xufVxuXG5jb25zdCBzdGVwcyA9IChzdGVwcywgZGlyZWN0aW9uID0gJ2VuZCcpID0+IHByb2dyZXNzID0+IHtcbiAgcHJvZ3Jlc3MgPSBkaXJlY3Rpb24gPT09ICdlbmQnID8gTWF0aC5taW4ocHJvZ3Jlc3MsIDAuOTk5KSA6IE1hdGgubWF4KHByb2dyZXNzLCAwLjAwMSk7XG4gIGNvbnN0IGV4cGFuZGVkID0gcHJvZ3Jlc3MgKiBzdGVwcztcbiAgY29uc3Qgcm91bmRlZCA9IGRpcmVjdGlvbiA9PT0gJ2VuZCcgPyBNYXRoLmZsb29yKGV4cGFuZGVkKSA6IE1hdGguY2VpbChleHBhbmRlZCk7XG4gIHJldHVybiBjbGFtcCgwLCAxLCByb3VuZGVkIC8gc3RlcHMpO1xufTtcblxuY29uc3QgYzEgPSAxLjcwMTU4O1xuY29uc3QgYzIgPSBjMSAqIDEuNTI1O1xuY29uc3QgYzMgPSBjMSArIDE7XG5jb25zdCBjNCA9IDIgKiBNYXRoLlBJIC8gMztcbmNvbnN0IGM1ID0gMiAqIE1hdGguUEkgLyA0LjU7XG5cbmNvbnN0IGJvdW5jZU91dCA9IHggPT4ge1xuICBjb25zdCBuMSA9IDcuNTYyNTtcbiAgY29uc3QgZDEgPSAyLjc1O1xuXG4gIGlmICh4IDwgMSAvIGQxKSB7XG4gICAgcmV0dXJuIG4xICogeCAqIHg7XG4gIH0gZWxzZSBpZiAoeCA8IDIgLyBkMSkge1xuICAgIHJldHVybiBuMSAqICh4IC09IDEuNSAvIGQxKSAqIHggKyAwLjc1O1xuICB9IGVsc2UgaWYgKHggPCAyLjUgLyBkMSkge1xuICAgIHJldHVybiBuMSAqICh4IC09IDIuMjUgLyBkMSkgKiB4ICsgMC45Mzc1O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuMSAqICh4IC09IDIuNjI1IC8gZDEpICogeCArIDAuOTg0Mzc1O1xuICB9XG59O1xuXG5jb25zdCBlYXNpbmdzID0ge1xuICBsaW5lYXI6IHggPT4geCxcbiAgZWFzZUluUXVhZDogeCA9PiB4ICogeCxcbiAgZWFzZU91dFF1YWQ6IHggPT4gMSAtICgxIC0geCkgKiAoMSAtIHgpLFxuICBlYXNlSW5PdXRRdWFkOiB4ID0+IHggPCAwLjUgPyAyICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgMikgLyAyLFxuICBlYXNlSW5DdWJpYzogeCA9PiB4ICogeCAqIHgsXG4gIGVhc2VPdXRDdWJpYzogeCA9PiAxIC0gTWF0aC5wb3coMSAtIHgsIDMpLFxuICBlYXNlSW5PdXRDdWJpYzogeCA9PiB4IDwgMC41ID8gNCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCAzKSAvIDIsXG4gIGVhc2VJblF1YXJ0OiB4ID0+IHggKiB4ICogeCAqIHgsXG4gIGVhc2VPdXRRdWFydDogeCA9PiAxIC0gTWF0aC5wb3coMSAtIHgsIDQpLFxuICBlYXNlSW5PdXRRdWFydDogeCA9PiB4IDwgMC41ID8gOCAqIHggKiB4ICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgNCkgLyAyLFxuICBlYXNlSW5RdWludDogeCA9PiB4ICogeCAqIHggKiB4ICogeCxcbiAgZWFzZU91dFF1aW50OiB4ID0+IDEgLSBNYXRoLnBvdygxIC0geCwgNSksXG4gIGVhc2VJbk91dFF1aW50OiB4ID0+IHggPCAwLjUgPyAxNiAqIHggKiB4ICogeCAqIHggKiB4IDogMSAtIE1hdGgucG93KC0yICogeCArIDIsIDUpIC8gMixcbiAgZWFzZUluU2luZTogeCA9PiAxIC0gTWF0aC5jb3MoeCAqIE1hdGguUEkgLyAyKSxcbiAgZWFzZU91dFNpbmU6IHggPT4gTWF0aC5zaW4oeCAqIE1hdGguUEkgLyAyKSxcbiAgZWFzZUluT3V0U2luZTogeCA9PiAtKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gMixcbiAgZWFzZUluRXhwbzogeCA9PiB4ID09PSAwID8gMCA6IE1hdGgucG93KDIsIDEwICogeCAtIDEwKSxcbiAgZWFzZU91dEV4cG86IHggPT4geCA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogeCksXG4gIGVhc2VJbk91dEV4cG86IHggPT4geCA9PT0gMCA/IDAgOiB4ID09PSAxID8gMSA6IHggPCAwLjUgPyBNYXRoLnBvdygyLCAyMCAqIHggLSAxMCkgLyAyIDogKDIgLSBNYXRoLnBvdygyLCAtMjAgKiB4ICsgMTApKSAvIDIsXG4gIGVhc2VJbkNpcmM6IHggPT4gMSAtIE1hdGguc3FydCgxIC0gTWF0aC5wb3coeCwgMikpLFxuICBlYXNlT3V0Q2lyYzogeCA9PiBNYXRoLnNxcnQoMSAtIE1hdGgucG93KHggLSAxLCAyKSksXG4gIGVhc2VJbk91dENpcmM6IHggPT4geCA8IDAuNSA/ICgxIC0gTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdygyICogeCwgMikpKSAvIDIgOiAoTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCAyKSkgKyAxKSAvIDIsXG4gIGVhc2VJbkJhY2s6IHggPT4gYzMgKiB4ICogeCAqIHggLSBjMSAqIHggKiB4LFxuICBlYXNlT3V0QmFjazogeCA9PiAxICsgYzMgKiBNYXRoLnBvdyh4IC0gMSwgMykgKyBjMSAqIE1hdGgucG93KHggLSAxLCAyKSxcbiAgZWFzZUluT3V0QmFjazogeCA9PiB4IDwgMC41ID8gTWF0aC5wb3coMiAqIHgsIDIpICogKChjMiArIDEpICogMiAqIHggLSBjMikgLyAyIDogKE1hdGgucG93KDIgKiB4IC0gMiwgMikgKiAoKGMyICsgMSkgKiAoeCAqIDIgLSAyKSArIGMyKSArIDIpIC8gMixcbiAgZWFzZUluRWxhc3RpYzogeCA9PiB4ID09PSAwID8gMCA6IHggPT09IDEgPyAxIDogLU1hdGgucG93KDIsIDEwICogeCAtIDEwKSAqIE1hdGguc2luKCh4ICogMTAgLSAxMC43NSkgKiBjNCksXG4gIGVhc2VPdXRFbGFzdGljOiB4ID0+IHggPT09IDAgPyAwIDogeCA9PT0gMSA/IDEgOiBNYXRoLnBvdygyLCAtMTAgKiB4KSAqIE1hdGguc2luKCh4ICogMTAgLSAwLjc1KSAqIGM0KSArIDEsXG4gIGVhc2VJbk91dEVsYXN0aWM6IHggPT4geCA9PT0gMCA/IDAgOiB4ID09PSAxID8gMSA6IHggPCAwLjUgPyAtKE1hdGgucG93KDIsIDIwICogeCAtIDEwKSAqIE1hdGguc2luKCgyMCAqIHggLSAxMS4xMjUpICogYzUpKSAvIDIgOiBNYXRoLnBvdygyLCAtMjAgKiB4ICsgMTApICogTWF0aC5zaW4oKDIwICogeCAtIDExLjEyNSkgKiBjNSkgLyAyICsgMSxcbiAgZWFzZUluQm91bmNlOiB4ID0+IDEgLSBib3VuY2VPdXQoMSAtIHgpLFxuICBlYXNlT3V0Qm91bmNlOiBib3VuY2VPdXQsXG4gIGVhc2VJbk91dEJvdW5jZTogeCA9PiB4IDwgMC41ID8gKDEgLSBib3VuY2VPdXQoMSAtIDIgKiB4KSkgLyAyIDogKDEgKyBib3VuY2VPdXQoMiAqIHggLSAxKSkgLyAyLFxuICBzdGVwc1xufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5jb25zdCAkZ2V0ID0gU3ltYm9sLmZvcignRmx1aWRWYWx1ZS5nZXQnKTtcbmNvbnN0ICRvYnNlcnZlcnMgPSBTeW1ib2wuZm9yKCdGbHVpZFZhbHVlLm9ic2VydmVycycpO1xuXG5jb25zdCBoYXNGbHVpZFZhbHVlID0gYXJnID0+IEJvb2xlYW4oYXJnICYmIGFyZ1skZ2V0XSk7XG5cbmNvbnN0IGdldEZsdWlkVmFsdWUgPSBhcmcgPT4gYXJnICYmIGFyZ1skZ2V0XSA/IGFyZ1skZ2V0XSgpIDogYXJnO1xuXG5jb25zdCBnZXRGbHVpZE9ic2VydmVycyA9IHRhcmdldCA9PiB0YXJnZXRbJG9ic2VydmVyc10gfHwgbnVsbDtcblxuZnVuY3Rpb24gY2FsbEZsdWlkT2JzZXJ2ZXIob2JzZXJ2ZXIsIGV2ZW50KSB7XG4gIGlmIChvYnNlcnZlci5ldmVudE9ic2VydmVkKSB7XG4gICAgb2JzZXJ2ZXIuZXZlbnRPYnNlcnZlZChldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZXIoZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxGbHVpZE9ic2VydmVycyh0YXJnZXQsIGV2ZW50KSB7XG4gIGxldCBvYnNlcnZlcnMgPSB0YXJnZXRbJG9ic2VydmVyc107XG5cbiAgaWYgKG9ic2VydmVycykge1xuICAgIG9ic2VydmVycy5mb3JFYWNoKG9ic2VydmVyID0+IHtcbiAgICAgIGNhbGxGbHVpZE9ic2VydmVyKG9ic2VydmVyLCBldmVudCk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgRmx1aWRWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGdldCkge1xuICAgIHRoaXNbJGdldF0gPSB2b2lkIDA7XG4gICAgdGhpc1skb2JzZXJ2ZXJzXSA9IHZvaWQgMDtcblxuICAgIGlmICghZ2V0ICYmICEoZ2V0ID0gdGhpcy5nZXQpKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBnZXR0ZXInKTtcbiAgICB9XG5cbiAgICBzZXRGbHVpZEdldHRlcih0aGlzLCBnZXQpO1xuICB9XG5cbn1cblxuY29uc3Qgc2V0Rmx1aWRHZXR0ZXIgPSAodGFyZ2V0LCBnZXQpID0+IHNldEhpZGRlbih0YXJnZXQsICRnZXQsIGdldCk7XG5cbmZ1bmN0aW9uIGFkZEZsdWlkT2JzZXJ2ZXIodGFyZ2V0LCBvYnNlcnZlcikge1xuICBpZiAodGFyZ2V0WyRnZXRdKSB7XG4gICAgbGV0IG9ic2VydmVycyA9IHRhcmdldFskb2JzZXJ2ZXJzXTtcblxuICAgIGlmICghb2JzZXJ2ZXJzKSB7XG4gICAgICBzZXRIaWRkZW4odGFyZ2V0LCAkb2JzZXJ2ZXJzLCBvYnNlcnZlcnMgPSBuZXcgU2V0KCkpO1xuICAgIH1cblxuICAgIGlmICghb2JzZXJ2ZXJzLmhhcyhvYnNlcnZlcikpIHtcbiAgICAgIG9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuXG4gICAgICBpZiAodGFyZ2V0Lm9ic2VydmVyQWRkZWQpIHtcbiAgICAgICAgdGFyZ2V0Lm9ic2VydmVyQWRkZWQob2JzZXJ2ZXJzLnNpemUsIG9ic2VydmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZsdWlkT2JzZXJ2ZXIodGFyZ2V0LCBvYnNlcnZlcikge1xuICBsZXQgb2JzZXJ2ZXJzID0gdGFyZ2V0WyRvYnNlcnZlcnNdO1xuXG4gIGlmIChvYnNlcnZlcnMgJiYgb2JzZXJ2ZXJzLmhhcyhvYnNlcnZlcikpIHtcbiAgICBjb25zdCBjb3VudCA9IG9ic2VydmVycy5zaXplIC0gMTtcblxuICAgIGlmIChjb3VudCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFskb2JzZXJ2ZXJzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5vYnNlcnZlclJlbW92ZWQpIHtcbiAgICAgIHRhcmdldC5vYnNlcnZlclJlbW92ZWQoY291bnQsIG9ic2VydmVyKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgc2V0SGlkZGVuID0gKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gIHZhbHVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuY29uc3QgbnVtYmVyUmVnZXggPSAvWytcXC1dPyg/OjB8WzEtOV1cXGQqKSg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG5jb25zdCBjb2xvclJlZ2V4ID0gLygjKD86WzAtOWEtZl17Mn0pezIsNH18KCNbMC05YS1mXXszfSl8KHJnYnxoc2wpYT9cXCgoLT9cXGQrJT9bLFxcc10rKXsyLDN9XFxzKltcXGRcXC5dKyU/XFwpKS9naTtcbmNvbnN0IHVuaXRSZWdleCA9IG5ldyBSZWdFeHAoYCgke251bWJlclJlZ2V4LnNvdXJjZX0pKCV8W2Etel0rKWAsICdpJyk7XG5jb25zdCByZ2JhUmVnZXggPSAvcmdiYVxcKChbMC05XFwuLV0rKSwgKFswLTlcXC4tXSspLCAoWzAtOVxcLi1dKyksIChbMC05XFwuLV0rKVxcKS9naTtcbmNvbnN0IGNzc1ZhcmlhYmxlUmVnZXggPSAvdmFyXFwoKC0tW2EtekEtWjAtOS1fXSspLD8gPyhbYS16QS1aMC05ICgpJSMuLC1dKyk/XFwpLztcblxuY29uc3QgdmFyaWFibGVUb1JnYmEgPSBpbnB1dCA9PiB7XG4gIGNvbnN0IFt0b2tlbiwgZmFsbGJhY2tdID0gcGFyc2VDU1NWYXJpYWJsZShpbnB1dCk7XG5cbiAgaWYgKCF0b2tlbiB8fCBpc1NTUigpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUodG9rZW4pO1xuXG4gIGlmICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gIH0gZWxzZSBpZiAoZmFsbGJhY2sgJiYgZmFsbGJhY2suc3RhcnRzV2l0aCgnLS0nKSkge1xuICAgIGNvbnN0IF92YWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShmYWxsYmFjayk7XG5cbiAgICBpZiAoX3ZhbHVlKSB7XG4gICAgICByZXR1cm4gX3ZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZhbGxiYWNrICYmIGNzc1ZhcmlhYmxlUmVnZXgudGVzdChmYWxsYmFjaykpIHtcbiAgICByZXR1cm4gdmFyaWFibGVUb1JnYmEoZmFsbGJhY2spO1xuICB9IGVsc2UgaWYgKGZhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuY29uc3QgcGFyc2VDU1NWYXJpYWJsZSA9IGN1cnJlbnQgPT4ge1xuICBjb25zdCBtYXRjaCA9IGNzc1ZhcmlhYmxlUmVnZXguZXhlYyhjdXJyZW50KTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIFssXTtcbiAgY29uc3QgWywgdG9rZW4sIGZhbGxiYWNrXSA9IG1hdGNoO1xuICByZXR1cm4gW3Rva2VuLCBmYWxsYmFja107XG59O1xuXG5sZXQgbmFtZWRDb2xvclJlZ2V4O1xuXG5jb25zdCByZ2JhUm91bmQgPSAoXywgcDEsIHAyLCBwMywgcDQpID0+IGByZ2JhKCR7TWF0aC5yb3VuZChwMSl9LCAke01hdGgucm91bmQocDIpfSwgJHtNYXRoLnJvdW5kKHAzKX0sICR7cDR9KWA7XG5cbmNvbnN0IGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvciA9IGNvbmZpZyA9PiB7XG4gIGlmICghbmFtZWRDb2xvclJlZ2V4KSBuYW1lZENvbG9yUmVnZXggPSBjb2xvcnMkMSA/IG5ldyBSZWdFeHAoYCgke09iamVjdC5rZXlzKGNvbG9ycyQxKS5qb2luKCd8Jyl9KSg/IVxcXFx3KWAsICdnJykgOiAvXlxcYiQvO1xuICBjb25zdCBvdXRwdXQgPSBjb25maWcub3V0cHV0Lm1hcCh2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIGdldEZsdWlkVmFsdWUodmFsdWUpLnJlcGxhY2UoY3NzVmFyaWFibGVSZWdleCwgdmFyaWFibGVUb1JnYmEpLnJlcGxhY2UoY29sb3JSZWdleCwgY29sb3JUb1JnYmEpLnJlcGxhY2UobmFtZWRDb2xvclJlZ2V4LCBjb2xvclRvUmdiYSk7XG4gIH0pO1xuICBjb25zdCBrZXlmcmFtZXMgPSBvdXRwdXQubWFwKHZhbHVlID0+IHZhbHVlLm1hdGNoKG51bWJlclJlZ2V4KS5tYXAoTnVtYmVyKSk7XG4gIGNvbnN0IG91dHB1dFJhbmdlcyA9IGtleWZyYW1lc1swXS5tYXAoKF8sIGkpID0+IGtleWZyYW1lcy5tYXAodmFsdWVzID0+IHtcbiAgICBpZiAoIShpIGluIHZhbHVlcykpIHtcbiAgICAgIHRocm93IEVycm9yKCdUaGUgYXJpdHkgb2YgZWFjaCBcIm91dHB1dFwiIHZhbHVlIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzW2ldO1xuICB9KSk7XG4gIGNvbnN0IGludGVycG9sYXRvcnMgPSBvdXRwdXRSYW5nZXMubWFwKG91dHB1dCA9PiBjcmVhdGVJbnRlcnBvbGF0b3IoX2V4dGVuZHMoe30sIGNvbmZpZywge1xuICAgIG91dHB1dFxuICB9KSkpO1xuICByZXR1cm4gaW5wdXQgPT4ge1xuICAgIHZhciBfb3V0cHV0JGZpbmQ7XG5cbiAgICBjb25zdCBtaXNzaW5nVW5pdCA9ICF1bml0UmVnZXgudGVzdChvdXRwdXRbMF0pICYmICgoX291dHB1dCRmaW5kID0gb3V0cHV0LmZpbmQodmFsdWUgPT4gdW5pdFJlZ2V4LnRlc3QodmFsdWUpKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdXRwdXQkZmluZC5yZXBsYWNlKG51bWJlclJlZ2V4LCAnJykpO1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gb3V0cHV0WzBdLnJlcGxhY2UobnVtYmVyUmVnZXgsICgpID0+IGAke2ludGVycG9sYXRvcnNbaSsrXShpbnB1dCl9JHttaXNzaW5nVW5pdCB8fCAnJ31gKS5yZXBsYWNlKHJnYmFSZWdleCwgcmdiYVJvdW5kKTtcbiAgfTtcbn07XG5cbmNvbnN0IHByZWZpeCA9ICdyZWFjdC1zcHJpbmc6ICc7XG5jb25zdCBvbmNlID0gZm4gPT4ge1xuICBjb25zdCBmdW5jID0gZm47XG4gIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7cHJlZml4fW9uY2UgcmVxdWlyZXMgYSBmdW5jdGlvbiBwYXJhbWV0ZXJgKTtcbiAgfVxuXG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBmdW5jKC4uLmFyZ3MpO1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG59O1xuY29uc3Qgd2FybkludGVycG9sYXRlID0gb25jZShjb25zb2xlLndhcm4pO1xuZnVuY3Rpb24gZGVwcmVjYXRlSW50ZXJwb2xhdGUoKSB7XG4gIHdhcm5JbnRlcnBvbGF0ZShgJHtwcmVmaXh9VGhlIFwiaW50ZXJwb2xhdGVcIiBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIGluIHY5ICh1c2UgXCJ0b1wiIGluc3RlYWQpYCk7XG59XG5jb25zdCB3YXJuRGlyZWN0Q2FsbCA9IG9uY2UoY29uc29sZS53YXJuKTtcbmZ1bmN0aW9uIGRlcHJlY2F0ZURpcmVjdENhbGwoKSB7XG4gIHdhcm5EaXJlY3RDYWxsKGAke3ByZWZpeH1EaXJlY3RseSBjYWxsaW5nIHN0YXJ0IGluc3RlYWQgb2YgdXNpbmcgdGhlIGFwaSBvYmplY3QgaXMgZGVwcmVjYXRlZCBpbiB2OSAodXNlIFwiLnN0YXJ0XCIgaW5zdGVhZCksIHRoaXMgd2lsbCBiZSByZW1vdmVkIGluIGxhdGVyIDAuWC4wIHZlcnNpb25zYCk7XG59XG5cbmZ1bmN0aW9uIGlzQW5pbWF0ZWRTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIGlzLnN0cih2YWx1ZSkgJiYgKHZhbHVlWzBdID09ICcjJyB8fCAvXFxkLy50ZXN0KHZhbHVlKSB8fCAhaXNTU1IoKSAmJiBjc3NWYXJpYWJsZVJlZ2V4LnRlc3QodmFsdWUpIHx8IHZhbHVlIGluIChjb2xvcnMkMSB8fCB7fSkpO1xufVxuXG5sZXQgb2JzZXJ2ZXI7XG5jb25zdCByZXNpemVIYW5kbGVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IGhhbmRsZU9ic2VydmF0aW9uID0gZW50cmllcyA9PiBlbnRyaWVzLmZvckVhY2goKHtcbiAgdGFyZ2V0LFxuICBjb250ZW50UmVjdFxufSkgPT4ge1xuICB2YXIgX3Jlc2l6ZUhhbmRsZXJzJGdldDtcblxuICByZXR1cm4gKF9yZXNpemVIYW5kbGVycyRnZXQgPSByZXNpemVIYW5kbGVycy5nZXQodGFyZ2V0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXNpemVIYW5kbGVycyRnZXQuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoY29udGVudFJlY3QpKTtcbn0pO1xuXG5mdW5jdGlvbiByZXNpemVFbGVtZW50KGhhbmRsZXIsIHRhcmdldCkge1xuICBpZiAoIW9ic2VydmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGhhbmRsZU9ic2VydmF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBsZXQgZWxlbWVudEhhbmRsZXJzID0gcmVzaXplSGFuZGxlcnMuZ2V0KHRhcmdldCk7XG5cbiAgaWYgKCFlbGVtZW50SGFuZGxlcnMpIHtcbiAgICBlbGVtZW50SGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgcmVzaXplSGFuZGxlcnMuc2V0KHRhcmdldCwgZWxlbWVudEhhbmRsZXJzKTtcbiAgfVxuXG4gIGVsZW1lbnRIYW5kbGVycy5hZGQoaGFuZGxlcik7XG5cbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQodGFyZ2V0KTtcbiAgICBpZiAoIWVsZW1lbnRIYW5kbGVycykgcmV0dXJuO1xuICAgIGVsZW1lbnRIYW5kbGVycy5kZWxldGUoaGFuZGxlcik7XG5cbiAgICBpZiAoIWVsZW1lbnRIYW5kbGVycy5zaXplICYmIG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUodGFyZ2V0KTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbmxldCBjbGVhbnVwV2luZG93UmVzaXplSGFuZGxlcjtcblxuY29uc3QgY3JlYXRlUmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHtcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgfSkpO1xuICB9O1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICB9O1xufTtcblxuY29uc3QgcmVzaXplV2luZG93ID0gY2FsbGJhY2sgPT4ge1xuICBsaXN0ZW5lcnMuYWRkKGNhbGxiYWNrKTtcblxuICBpZiAoIWNsZWFudXBXaW5kb3dSZXNpemVIYW5kbGVyKSB7XG4gICAgY2xlYW51cFdpbmRvd1Jlc2l6ZUhhbmRsZXIgPSBjcmVhdGVSZXNpemVIYW5kbGVyKCk7XG4gIH1cblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spO1xuXG4gICAgaWYgKCFsaXN0ZW5lcnMuc2l6ZSAmJiBjbGVhbnVwV2luZG93UmVzaXplSGFuZGxlcikge1xuICAgICAgY2xlYW51cFdpbmRvd1Jlc2l6ZUhhbmRsZXIoKTtcbiAgICAgIGNsZWFudXBXaW5kb3dSZXNpemVIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IG9uUmVzaXplID0gKGNhbGxiYWNrLCB7XG4gIGNvbnRhaW5lcjogX2NvbnRhaW5lciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxufSA9IHt9KSA9PiB7XG4gIGlmIChfY29udGFpbmVyID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcmVzaXplV2luZG93KGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzaXplRWxlbWVudChjYWxsYmFjaywgX2NvbnRhaW5lcik7XG4gIH1cbn07XG5cbmNvbnN0IHByb2dyZXNzID0gKG1pbiwgbWF4LCB2YWx1ZSkgPT4gbWF4IC0gbWluID09PSAwID8gMSA6ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcblxuY29uc3QgU0NST0xMX0tFWVMgPSB7XG4gIHg6IHtcbiAgICBsZW5ndGg6ICdXaWR0aCcsXG4gICAgcG9zaXRpb246ICdMZWZ0J1xuICB9LFxuICB5OiB7XG4gICAgbGVuZ3RoOiAnSGVpZ2h0JyxcbiAgICBwb3NpdGlvbjogJ1RvcCdcbiAgfVxufTtcbmNsYXNzIFNjcm9sbEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgY29udGFpbmVyKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHZvaWQgMDtcbiAgICB0aGlzLmluZm8gPSB2b2lkIDA7XG5cbiAgICB0aGlzLmNyZWF0ZUF4aXMgPSAoKSA9PiAoe1xuICAgICAgY3VycmVudDogMCxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgc2Nyb2xsTGVuZ3RoOiAwXG4gICAgfSk7XG5cbiAgICB0aGlzLnVwZGF0ZUF4aXMgPSBheGlzTmFtZSA9PiB7XG4gICAgICBjb25zdCBheGlzID0gdGhpcy5pbmZvW2F4aXNOYW1lXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBwb3NpdGlvblxuICAgICAgfSA9IFNDUk9MTF9LRVlTW2F4aXNOYW1lXTtcbiAgICAgIGF4aXMuY3VycmVudCA9IHRoaXMuY29udGFpbmVyW2BzY3JvbGwke3Bvc2l0aW9ufWBdO1xuICAgICAgYXhpcy5zY3JvbGxMZW5ndGggPSB0aGlzLmNvbnRhaW5lclsnc2Nyb2xsJyArIGxlbmd0aF0gLSB0aGlzLmNvbnRhaW5lclsnY2xpZW50JyArIGxlbmd0aF07XG4gICAgICBheGlzLnByb2dyZXNzID0gcHJvZ3Jlc3MoMCwgYXhpcy5zY3JvbGxMZW5ndGgsIGF4aXMuY3VycmVudCk7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVBeGlzKCd4Jyk7XG4gICAgICB0aGlzLnVwZGF0ZUF4aXMoJ3knKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZW5kRXZlbnQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMuaW5mbyk7XG4gICAgfTtcblxuICAgIHRoaXMuYWR2YW5jZSA9ICgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLnNlbmRFdmVudCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5pbmZvID0ge1xuICAgICAgdGltZTogMCxcbiAgICAgIHg6IHRoaXMuY3JlYXRlQXhpcygpLFxuICAgICAgeTogdGhpcy5jcmVhdGVBeGlzKClcbiAgICB9O1xuICB9XG5cbn1cblxuY29uc3Qgc2Nyb2xsTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlc2l6ZUxpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBvblNjcm9sbEhhbmRsZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuY29uc3QgZ2V0VGFyZ2V0ID0gY29udGFpbmVyID0+IGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gd2luZG93IDogY29udGFpbmVyO1xuXG5jb25zdCBvblNjcm9sbCA9IChjYWxsYmFjaywge1xuICBjb250YWluZXI6IF9jb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbn0gPSB7fSkgPT4ge1xuICBsZXQgY29udGFpbmVySGFuZGxlcnMgPSBvblNjcm9sbEhhbmRsZXJzLmdldChfY29udGFpbmVyKTtcblxuICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzKSB7XG4gICAgY29udGFpbmVySGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgb25TY3JvbGxIYW5kbGVycy5zZXQoX2NvbnRhaW5lciwgY29udGFpbmVySGFuZGxlcnMpO1xuICB9XG5cbiAgY29uc3QgY29udGFpbmVySGFuZGxlciA9IG5ldyBTY3JvbGxIYW5kbGVyKGNhbGxiYWNrLCBfY29udGFpbmVyKTtcbiAgY29udGFpbmVySGFuZGxlcnMuYWRkKGNvbnRhaW5lckhhbmRsZXIpO1xuXG4gIGlmICghc2Nyb2xsTGlzdGVuZXJzLmhhcyhfY29udGFpbmVyKSkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb250YWluZXJIYW5kbGVycztcblxuICAgICAgKF9jb250YWluZXJIYW5kbGVycyA9IGNvbnRhaW5lckhhbmRsZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRhaW5lckhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyLmFkdmFuY2UoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2Nyb2xsTGlzdGVuZXJzLnNldChfY29udGFpbmVyLCBsaXN0ZW5lcik7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KF9jb250YWluZXIpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBsaXN0ZW5lciwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKF9jb250YWluZXIgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgcmVzaXplTGlzdGVuZXJzLnNldChfY29udGFpbmVyLCBvblJlc2l6ZShsaXN0ZW5lciwge1xuICAgICAgICBjb250YWluZXI6IF9jb250YWluZXJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgbGlzdGVuZXIsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGFuaW1hdGVTY3JvbGwgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KF9jb250YWluZXIpO1xuICByYWZ6LnJhZihhbmltYXRlU2Nyb2xsKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByYWZ6LnJhZi5jYW5jZWwoYW5pbWF0ZVNjcm9sbCk7XG4gICAgY29uc3QgY29udGFpbmVySGFuZGxlcnMgPSBvblNjcm9sbEhhbmRsZXJzLmdldChfY29udGFpbmVyKTtcbiAgICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzKSByZXR1cm47XG4gICAgY29udGFpbmVySGFuZGxlcnMuZGVsZXRlKGNvbnRhaW5lckhhbmRsZXIpO1xuICAgIGlmIChjb250YWluZXJIYW5kbGVycy5zaXplKSByZXR1cm47XG4gICAgY29uc3QgbGlzdGVuZXIgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KF9jb250YWluZXIpO1xuICAgIHNjcm9sbExpc3RlbmVycy5kZWxldGUoX2NvbnRhaW5lcik7XG5cbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIHZhciBfcmVzaXplTGlzdGVuZXJzJGdldDtcblxuICAgICAgZ2V0VGFyZ2V0KF9jb250YWluZXIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGxpc3RlbmVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICAoX3Jlc2l6ZUxpc3RlbmVycyRnZXQgPSByZXNpemVMaXN0ZW5lcnMuZ2V0KF9jb250YWluZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc2l6ZUxpc3RlbmVycyRnZXQoKTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiB1c2VDb25zdGFudChpbml0KSB7XG4gIGNvbnN0IHJlZiA9IHJlYWN0LnVzZVJlZihudWxsKTtcblxuICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICByZWYuY3VycmVudCA9IGluaXQoKTtcbiAgfVxuXG4gIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzU1NSKCkgPyByZWFjdC51c2VFZmZlY3QgOiByZWFjdC51c2VMYXlvdXRFZmZlY3Q7XG5cbmNvbnN0IHVzZUlzTW91bnRlZCA9ICgpID0+IHtcbiAgY29uc3QgaXNNb3VudGVkID0gcmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzTW91bnRlZDtcbn07XG5cbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICBjb25zdCB1cGRhdGUgPSByZWFjdC51c2VTdGF0ZSgpWzFdO1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIHVwZGF0ZShNYXRoLnJhbmRvbSgpKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW9PbmUoZ2V0UmVzdWx0LCBpbnB1dHMpIHtcbiAgY29uc3QgW2luaXRpYWxdID0gcmVhY3QudXNlU3RhdGUoKCkgPT4gKHtcbiAgICBpbnB1dHMsXG4gICAgcmVzdWx0OiBnZXRSZXN1bHQoKVxuICB9KSk7XG4gIGNvbnN0IGNvbW1pdHRlZCA9IHJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBwcmV2Q2FjaGUgPSBjb21taXR0ZWQuY3VycmVudDtcbiAgbGV0IGNhY2hlID0gcHJldkNhY2hlO1xuXG4gIGlmIChjYWNoZSkge1xuICAgIGNvbnN0IHVzZUNhY2hlID0gQm9vbGVhbihpbnB1dHMgJiYgY2FjaGUuaW5wdXRzICYmIGFyZUlucHV0c0VxdWFsKGlucHV0cywgY2FjaGUuaW5wdXRzKSk7XG5cbiAgICBpZiAoIXVzZUNhY2hlKSB7XG4gICAgICBjYWNoZSA9IHtcbiAgICAgICAgaW5wdXRzLFxuICAgICAgICByZXN1bHQ6IGdldFJlc3VsdCgpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYWNoZSA9IGluaXRpYWw7XG4gIH1cblxuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbW1pdHRlZC5jdXJyZW50ID0gY2FjaGU7XG5cbiAgICBpZiAocHJldkNhY2hlID09IGluaXRpYWwpIHtcbiAgICAgIGluaXRpYWwuaW5wdXRzID0gaW5pdGlhbC5yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCBbY2FjaGVdKTtcbiAgcmV0dXJuIGNhY2hlLnJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYXJlSW5wdXRzRXF1YWwobmV4dCwgcHJldikge1xuICBpZiAobmV4dC5sZW5ndGggIT09IHByZXYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5leHRbaV0gIT09IHByZXZbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgdXNlT25jZSA9IGVmZmVjdCA9PiByZWFjdC51c2VFZmZlY3QoZWZmZWN0LCBlbXB0eURlcHMpO1xuY29uc3QgZW1wdHlEZXBzID0gW107XG5cbmZ1bmN0aW9uIHVzZVByZXYodmFsdWUpIHtcbiAgY29uc3QgcHJldlJlZiA9IHJlYWN0LnVzZVJlZigpO1xuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByZXZSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHByZXZSZWYuY3VycmVudDtcbn1cblxuY29uc3QgdXNlUmVkdWNlZE1vdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgW3JlZHVjZWRNb3Rpb24sIHNldFJlZHVjZWRNb3Rpb25dID0gcmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1xbCA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbiknKTtcblxuICAgIGNvbnN0IGhhbmRsZU1lZGlhQ2hhbmdlID0gZSA9PiB7XG4gICAgICBzZXRSZWR1Y2VkTW90aW9uKGUubWF0Y2hlcyk7XG4gICAgICBhc3NpZ24oe1xuICAgICAgICBza2lwQW5pbWF0aW9uOiBlLm1hdGNoZXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBoYW5kbGVNZWRpYUNoYW5nZShtcWwpO1xuICAgIG1xbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVNZWRpYUNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1xbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVNZWRpYUNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gcmVkdWNlZE1vdGlvbjtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmFmJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhZnoucmFmOyB9XG59KTtcbmV4cG9ydHMuRmx1aWRWYWx1ZSA9IEZsdWlkVmFsdWU7XG5leHBvcnRzLkdsb2JhbHMgPSBnbG9iYWxzO1xuZXhwb3J0cy5hZGRGbHVpZE9ic2VydmVyID0gYWRkRmx1aWRPYnNlcnZlcjtcbmV4cG9ydHMuY2FsbEZsdWlkT2JzZXJ2ZXIgPSBjYWxsRmx1aWRPYnNlcnZlcjtcbmV4cG9ydHMuY2FsbEZsdWlkT2JzZXJ2ZXJzID0gY2FsbEZsdWlkT2JzZXJ2ZXJzO1xuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZXhwb3J0cy5jb2xvclRvUmdiYSA9IGNvbG9yVG9SZ2JhO1xuZXhwb3J0cy5jb2xvcnMgPSBjb2xvcnM7XG5leHBvcnRzLmNyZWF0ZUludGVycG9sYXRvciA9IGNyZWF0ZUludGVycG9sYXRvcjtcbmV4cG9ydHMuY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yID0gY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yO1xuZXhwb3J0cy5kZWZpbmVIaWRkZW4gPSBkZWZpbmVIaWRkZW47XG5leHBvcnRzLmRlcHJlY2F0ZURpcmVjdENhbGwgPSBkZXByZWNhdGVEaXJlY3RDYWxsO1xuZXhwb3J0cy5kZXByZWNhdGVJbnRlcnBvbGF0ZSA9IGRlcHJlY2F0ZUludGVycG9sYXRlO1xuZXhwb3J0cy5lYWNoID0gZWFjaDtcbmV4cG9ydHMuZWFjaFByb3AgPSBlYWNoUHJvcDtcbmV4cG9ydHMuZWFzaW5ncyA9IGVhc2luZ3M7XG5leHBvcnRzLmZsdXNoID0gZmx1c2g7XG5leHBvcnRzLmZsdXNoQ2FsbHMgPSBmbHVzaENhbGxzO1xuZXhwb3J0cy5mcmFtZUxvb3AgPSBmcmFtZUxvb3A7XG5leHBvcnRzLmdldEZsdWlkT2JzZXJ2ZXJzID0gZ2V0Rmx1aWRPYnNlcnZlcnM7XG5leHBvcnRzLmdldEZsdWlkVmFsdWUgPSBnZXRGbHVpZFZhbHVlO1xuZXhwb3J0cy5oYXNGbHVpZFZhbHVlID0gaGFzRmx1aWRWYWx1ZTtcbmV4cG9ydHMuaGV4MyA9IGhleDM7XG5leHBvcnRzLmhleDQgPSBoZXg0O1xuZXhwb3J0cy5oZXg2ID0gaGV4NjtcbmV4cG9ydHMuaGV4OCA9IGhleDg7XG5leHBvcnRzLmhzbCA9IGhzbDtcbmV4cG9ydHMuaHNsYSA9IGhzbGE7XG5leHBvcnRzLmlzID0gaXM7XG5leHBvcnRzLmlzQW5pbWF0ZWRTdHJpbmcgPSBpc0FuaW1hdGVkU3RyaW5nO1xuZXhwb3J0cy5pc0VxdWFsID0gaXNFcXVhbDtcbmV4cG9ydHMuaXNTU1IgPSBpc1NTUjtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5leHBvcnRzLm9uUmVzaXplID0gb25SZXNpemU7XG5leHBvcnRzLm9uU2Nyb2xsID0gb25TY3JvbGw7XG5leHBvcnRzLm9uY2UgPSBvbmNlO1xuZXhwb3J0cy5wcmVmaXggPSBwcmVmaXg7XG5leHBvcnRzLnJlbW92ZUZsdWlkT2JzZXJ2ZXIgPSByZW1vdmVGbHVpZE9ic2VydmVyO1xuZXhwb3J0cy5yZ2IgPSByZ2I7XG5leHBvcnRzLnJnYmEgPSByZ2JhO1xuZXhwb3J0cy5zZXRGbHVpZEdldHRlciA9IHNldEZsdWlkR2V0dGVyO1xuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcbmV4cG9ydHMudXNlQ29uc3RhbnQgPSB1c2VDb25zdGFudDtcbmV4cG9ydHMudXNlRm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZTtcbmV4cG9ydHMudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW9PbmUgPSB1c2VNZW1vT25lO1xuZXhwb3J0cy51c2VPbmNlID0gdXNlT25jZTtcbmV4cG9ydHMudXNlUHJldiA9IHVzZVByZXY7XG5leHBvcnRzLnVzZVJlZHVjZWRNb3Rpb24gPSB1c2VSZWR1Y2VkTW90aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-spring-shared.cjs.dev.js */ \"(ssr)/./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9zaGFyZWQvZGlzdC9yZWFjdC1zcHJpbmctc2hhcmVkLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsNkpBQTREO0FBQzlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvc2hhcmVkL2Rpc3QvcmVhY3Qtc3ByaW5nLXNoYXJlZC5janMuanM/YzJlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9yZWFjdC1zcHJpbmctc2hhcmVkLmNqcy5wcm9kLmpzXCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9yZWFjdC1zcHJpbmctc2hhcmVkLmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/three/dist/react-spring-three.cjs.dev.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@react-spring/three/dist/react-spring-three.cjs.dev.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar fiber = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js\");\nvar core = __webpack_require__(/*! @react-spring/core */ \"(ssr)/./node_modules/@react-spring/core/dist/react-spring-core.cjs.js\");\nvar shared = __webpack_require__(/*! @react-spring/shared */ \"(ssr)/./node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js\");\nvar animated$1 = __webpack_require__(/*! @react-spring/animated */ \"(ssr)/./node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js\");\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\n\nconst primitives = ['primitive'].concat(Object.keys(THREE__namespace).filter(key => /^[A-Z]/.test(key)).map(key => key[0].toLowerCase() + key.slice(1)));\n\ncore.Globals.assign({\n  createStringInterpolator: shared.createStringInterpolator,\n  colors: shared.colors,\n  frameLoop: 'demand'\n});\nfiber.addEffect(() => {\n  shared.raf.advance();\n});\nconst host = animated$1.createHost(primitives, {\n  applyAnimatedValues: fiber.applyProps\n});\nconst animated = host.animated;\n\nexports.a = animated;\nexports.animated = animated;\nObject.keys(core).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return core[k]; }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy90aHJlZS9kaXN0L3JlYWN0LXNwcmluZy10aHJlZS5janMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsWUFBWSxtQkFBTyxDQUFDLGlHQUFvQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsaUdBQW9CO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyx1R0FBc0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsNkdBQXdCO0FBQ2pELFlBQVksbUJBQU8sQ0FBQyx5REFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsU0FBUztBQUNULGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy90aHJlZS9kaXN0L3JlYWN0LXNwcmluZy10aHJlZS5janMuZGV2LmpzPzUwNzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZmliZXIgPSByZXF1aXJlKCdAcmVhY3QtdGhyZWUvZmliZXInKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQHJlYWN0LXNwcmluZy9jb3JlJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnQHJlYWN0LXNwcmluZy9zaGFyZWQnKTtcbnZhciBhbmltYXRlZCQxID0gcmVxdWlyZSgnQHJlYWN0LXNwcmluZy9hbmltYXRlZCcpO1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbltcImRlZmF1bHRcIl0gPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIFRIUkVFX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoVEhSRUUpO1xuXG5jb25zdCBwcmltaXRpdmVzID0gWydwcmltaXRpdmUnXS5jb25jYXQoT2JqZWN0LmtleXMoVEhSRUVfX25hbWVzcGFjZSkuZmlsdGVyKGtleSA9PiAvXltBLVpdLy50ZXN0KGtleSkpLm1hcChrZXkgPT4ga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpKTtcblxuY29yZS5HbG9iYWxzLmFzc2lnbih7XG4gIGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcjogc2hhcmVkLmNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcixcbiAgY29sb3JzOiBzaGFyZWQuY29sb3JzLFxuICBmcmFtZUxvb3A6ICdkZW1hbmQnXG59KTtcbmZpYmVyLmFkZEVmZmVjdCgoKSA9PiB7XG4gIHNoYXJlZC5yYWYuYWR2YW5jZSgpO1xufSk7XG5jb25zdCBob3N0ID0gYW5pbWF0ZWQkMS5jcmVhdGVIb3N0KHByaW1pdGl2ZXMsIHtcbiAgYXBwbHlBbmltYXRlZFZhbHVlczogZmliZXIuYXBwbHlQcm9wc1xufSk7XG5jb25zdCBhbmltYXRlZCA9IGhvc3QuYW5pbWF0ZWQ7XG5cbmV4cG9ydHMuYSA9IGFuaW1hdGVkO1xuZXhwb3J0cy5hbmltYXRlZCA9IGFuaW1hdGVkO1xuT2JqZWN0LmtleXMoY29yZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlW2tdOyB9XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/three/dist/react-spring-three.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/three/dist/react-spring-three.cjs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-spring/three/dist/react-spring-three.cjs.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-spring-three.cjs.dev.js */ \"(ssr)/./node_modules/@react-spring/three/dist/react-spring-three.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy90aHJlZS9kaXN0L3JlYWN0LXNwcmluZy10aHJlZS5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDBKQUEyRDtBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL3RocmVlL2Rpc3QvcmVhY3Qtc3ByaW5nLXRocmVlLmNqcy5qcz8yN2IwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlYWN0LXNwcmluZy10aHJlZS5janMucHJvZC5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVhY3Qtc3ByaW5nLXRocmVlLmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-spring/three/dist/react-spring-three.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/types/animated.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-spring/types/animated.js ***!
  \******************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/@react-spring/types/interpolation.js":
/*!***********************************************************!*\
  !*** ./node_modules/@react-spring/types/interpolation.js ***!
  \***********************************************************/
/***/ (() => {



/***/ })

};
;