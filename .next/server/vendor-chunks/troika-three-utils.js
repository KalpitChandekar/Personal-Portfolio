/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-utils";
exports.ids = ["vendor-chunks/troika-three-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.umd.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\")) :\n  0;\n}(this, (function (exports, three) { 'use strict';\n\n  /**\n   * Regular expression for matching the `void main() {` opener line in GLSL.\n   * @type {RegExp}\n   */\n  const voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n  /**\n   * Recursively expands all `#include <xyz>` statements within string of shader code.\n   * Copied from three's WebGLProgram#parseIncludes for external use.\n   *\n   * @param {string} source - The GLSL source code to evaluate\n   * @return {string} The GLSL code with all includes expanded\n   */\n  function expandShaderIncludes( source ) {\n    const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n      let chunk = three.ShaderChunk[include];\n      return chunk ? expandShaderIncludes(chunk) : match\n    }\n    return source.replace( pattern, replace )\n  }\n\n  /*\n   * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n   * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n   * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n   */\n\n  const _lut = [];\n\n  for (let i = 0; i < 256; i++) {\n    _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n  }\n\n  function generateUUID() {\n\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n    const d0 = Math.random() * 0xffffffff | 0;\n    const d1 = Math.random() * 0xffffffff | 0;\n    const d2 = Math.random() * 0xffffffff | 0;\n    const d3 = Math.random() * 0xffffffff | 0;\n    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n      _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n      _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n      _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n    // .toUpperCase() here flattens concatenated strings to save heap memory space.\n    return uuid.toUpperCase()\n\n  }\n\n  // Local assign polyfill to avoid importing troika-core\n  const assign = Object.assign || function(/*target, ...sources*/) {\n    let target = arguments[0];\n    for (let i = 1, len = arguments.length; i < len; i++) {\n      let source = arguments[i];\n      if (source) {\n        for (let prop in source) {\n          if (Object.prototype.hasOwnProperty.call(source, prop)) {\n            target[prop] = source[prop];\n          }\n        }\n      }\n    }\n    return target\n  };\n\n\n  const epoch = Date.now();\n  const CONSTRUCTOR_CACHE = new WeakMap();\n  const SHADER_UPGRADE_CACHE = new Map();\n\n  // Material ids must be integers, but we can't access the increment from Three's `Material` module,\n  // so let's choose a sufficiently large starting value that should theoretically never collide.\n  let materialInstanceId = 1e10;\n\n  /**\n   * A utility for creating a custom shader material derived from another material's\n   * shaders. This allows you to inject custom shader logic and transforms into the\n   * builtin ThreeJS materials without having to recreate them from scratch.\n   *\n   * @param {THREE.Material} baseMaterial - the original material to derive from\n   *\n   * @param {Object} options - How the base material should be modified.\n   * @param {Object} options.defines - Custom `defines` for the material\n   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n   *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n   *        both shaders, and it will automatically be updated on each render frame with a number of\n   *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n   *        true calendar time.\n   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n   *        those attributes exposed by their normal names as read/write values.\n   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n   *        shader's `void main` function.\n   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n   *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n   *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n   *        want those to apply to your changes use `fragmentColorTransform` instead.\n   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n   *        output value. Will be injected near the end of the `void main` function, but before any\n   *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n   *        `fragmentMainOutro`.\n   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n   *        for performing custom rewrites of the full shader code. Useful if you need to do something\n   *        special that's not covered by the other builtin options. This function will be executed before\n   *        any other transforms are applied.\n   * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n   *        material, rather than the default behavior of copying it. This allows the derived material to\n   *        automatically pick up changes made to the base material and its properties. This can be useful\n   *        where the derived material is hidden from the user as an implementation detail, allowing them\n   *        to work with the original material like normal. But it can result in unexpected behavior if not\n   *        handled carefully.\n   *\n   * @return {THREE.Material}\n   *\n   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n   * which can be called to get a variant of the derived material for use in shadow casting. If the\n   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n   * scenarios, e.g. skipping antialiasing or expensive shader logic.\n   */\n  function createDerivedMaterial(baseMaterial, options) {\n    // Generate a key that is unique to the content of these `options`. We'll use this\n    // throughout for caching and for generating the upgraded shader code. This increases\n    // the likelihood that the resulting shaders will line up across multiple calls so\n    // their GL programs can be shared and cached.\n    const optionsKey = getKeyForOptions(options);\n\n    // First check to see if we've already derived from this baseMaterial using this\n    // unique set of options, and if so reuse the constructor to avoid some allocations.\n    let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n    if (!ctorsByDerivation) {\n      CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n    }\n    if (ctorsByDerivation[optionsKey]) {\n      return new ctorsByDerivation[optionsKey]()\n    }\n\n    const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n    const onBeforeCompile = function (shaderInfo, renderer) {\n      baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n      // Upgrade the shaders, caching the result by incoming source code\n      const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n      let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n      if (!upgradedShaders) {\n        const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n        upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n      }\n\n      // Inject upgraded shaders and uniforms into the program\n      shaderInfo.vertexShader = upgradedShaders.vertexShader;\n      shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n      assign(shaderInfo.uniforms, this.uniforms);\n\n      // Inject auto-updating time uniform if requested\n      if (options.timeUniform) {\n        shaderInfo.uniforms[options.timeUniform] = {\n          get value() {return Date.now() - epoch}\n        };\n      }\n\n      // Users can still add their own handlers on top of ours\n      if (this[privateBeforeCompileProp]) {\n        this[privateBeforeCompileProp](shaderInfo);\n      }\n    };\n\n    const DerivedMaterial = function DerivedMaterial() {\n      return derive(options.chained ? baseMaterial : baseMaterial.clone())\n    };\n\n    const derive = function(base) {\n      // Prototype chain to the base material\n      const derived = Object.create(base, descriptor);\n\n      // Store the baseMaterial for reference; this is always the original even when cloning\n      Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n      // Needs its own ids\n      Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n      derived.uuid = generateUUID();\n\n      // Merge uniforms, defines, and extensions\n      derived.uniforms = assign({}, base.uniforms, options.uniforms);\n      derived.defines = assign({}, base.defines, options.defines);\n      derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n      derived.extensions = assign({}, base.extensions, options.extensions);\n\n      // Don't inherit EventDispatcher listeners\n      derived._listeners = undefined;\n\n      return derived\n    };\n\n    const descriptor = {\n      constructor: {value: DerivedMaterial},\n      isDerivedMaterial: {value: true},\n\n      customProgramCacheKey: {\n        writable: true,\n        configurable: true,\n        value: function () {\n          return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n        }\n      },\n\n      onBeforeCompile: {\n        get() {\n          return onBeforeCompile\n        },\n        set(fn) {\n          this[privateBeforeCompileProp] = fn;\n        }\n      },\n\n      copy: {\n        writable: true,\n        configurable: true,\n        value: function (source) {\n          baseMaterial.copy.call(this, source);\n          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n            assign(this.extensions, source.extensions);\n            assign(this.defines, source.defines);\n            assign(this.uniforms, three.UniformsUtils.clone(source.uniforms));\n          }\n          return this\n        }\n      },\n\n      clone: {\n        writable: true,\n        configurable: true,\n        value: function () {\n          const newBase = new baseMaterial.constructor();\n          return derive(newBase).copy(this)\n        }\n      },\n\n      /**\n       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDepthMaterial: {\n        writable: true,\n        configurable: true,\n        value: function() {\n          let depthMaterial = this._depthMaterial;\n          if (!depthMaterial) {\n            depthMaterial = this._depthMaterial = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDepthMaterial()\n                : new three.MeshDepthMaterial({ depthPacking: three.RGBADepthPacking }),\n              options\n            );\n            depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n            depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n          return depthMaterial\n        }\n      },\n\n      /**\n       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDistanceMaterial: {\n        writable: true,\n        configurable: true,\n        value: function() {\n          let distanceMaterial = this._distanceMaterial;\n          if (!distanceMaterial) {\n            distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDistanceMaterial()\n                : new three.MeshDistanceMaterial(),\n              options\n            );\n            distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n            distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n          return distanceMaterial\n        }\n      },\n\n      dispose: {\n        writable: true,\n        configurable: true,\n        value() {\n          const {_depthMaterial, _distanceMaterial} = this;\n          if (_depthMaterial) _depthMaterial.dispose();\n          if (_distanceMaterial) _distanceMaterial.dispose();\n          baseMaterial.dispose.call(this);\n        }\n      }\n    };\n\n    ctorsByDerivation[optionsKey] = DerivedMaterial;\n    return new DerivedMaterial()\n  }\n\n\n  function upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n    let {\n      vertexDefs,\n      vertexMainIntro,\n      vertexMainOutro,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro,\n      fragmentMainOutro,\n      fragmentColorTransform,\n      customRewriter,\n      timeUniform\n    } = options;\n\n    vertexDefs = vertexDefs || '';\n    vertexMainIntro = vertexMainIntro || '';\n    vertexMainOutro = vertexMainOutro || '';\n    fragmentDefs = fragmentDefs || '';\n    fragmentMainIntro = fragmentMainIntro || '';\n    fragmentMainOutro = fragmentMainOutro || '';\n\n    // Expand includes if needed\n    if (vertexTransform || customRewriter) {\n      vertexShader = expandShaderIncludes(vertexShader);\n    }\n    if (fragmentColorTransform || customRewriter) {\n      // We need to be able to find postprocessing chunks after include expansion in order to\n      // put them after the fragmentColorTransform, so mark them with comments first. Even if\n      // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n      // so we still mark them.\n      fragmentShader = fragmentShader.replace(\n        /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n        '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n      );\n      fragmentShader = expandShaderIncludes(fragmentShader);\n    }\n\n    // Apply custom rewriter function\n    if (customRewriter) {\n      let res = customRewriter({vertexShader, fragmentShader});\n      vertexShader = res.vertexShader;\n      fragmentShader = res.fragmentShader;\n    }\n\n    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n    if (fragmentColorTransform) {\n      let postChunks = [];\n      fragmentShader = fragmentShader.replace(\n        /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n        match => {\n          postChunks.push(match);\n          return ''\n        }\n      );\n      fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n    }\n\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n      const code = `\\nuniform float ${timeUniform};\\n`;\n      vertexDefs = code + vertexDefs;\n      fragmentDefs = code + fragmentDefs;\n    }\n\n    // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n    if (vertexTransform) {\n      // Hoist these defs to the very top so they work in other function defs\n      vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n      vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n      vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n      vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n        return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n      });\n\n      // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n      // Perhaps the other textures too going forward?\n      if (!(material.map && material.map.channel > 0)) {\n        vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n      }\n    }\n\n    // Inject defs and intro/outro snippets\n    vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n    return {\n      vertexShader,\n      fragmentShader\n    }\n  }\n\n  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n      shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n      );\n      shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n    }\n    return shaderCode\n  }\n\n\n  function optionsJsonReplacer(key, value) {\n    return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n  }\n\n  let _idCtr = 0;\n  const optionsHashesToIds = new Map();\n  function getKeyForOptions(options) {\n    const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n    let id = optionsHashesToIds.get(optionsHash);\n    if (id == null) {\n      optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n    }\n    return id\n  }\n\n  // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n  // TODO how can we keep this from getting stale?\n  const MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'toon',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n\n  /**\n   * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n   * used to render that material.\n   *\n   * @param material - the Material instance\n   * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n   */\n  function getShadersForMaterial(material) {\n    let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n  }\n\n  /**\n   * Find all uniforms and their types within a shader code string.\n   *\n   * @param {string} shader - The shader code to parse\n   * @return {object} mapping of uniform names to their glsl type\n   */\n  function getShaderUniformTypes(shader) {\n    let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n    let uniforms = Object.create(null);\n    let match;\n    while ((match = uniformRE.exec(shader)) !== null) {\n      uniforms[match[2]] = match[1];\n    }\n    return uniforms\n  }\n\n  /**\n   * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n   * that happened in ThreeJS r123.\n   * @param {Matrix4} srcMatrix\n   * @param {Matrix4} [tgtMatrix]\n   */\n  function invertMatrix4(srcMatrix, tgtMatrix = new three.Matrix4()) {\n    if (typeof tgtMatrix.invert === 'function') {\n      tgtMatrix.copy(srcMatrix).invert();\n    } else {\n      tgtMatrix.getInverse(srcMatrix);\n    }\n    return tgtMatrix\n  }\n\n  /*\n  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,\n  divided into a reasonable number of height segments.\n  */\n\n  const vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\n  const vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\n  const fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\n  const fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n  // Debugging: separate color for each of the 6 sides:\n  // const fragmentColorTransform = `\n  // float sideNum = floor(vUV.x * 6.0);\n  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n  //   vec3(1.0, 0.0, 1.0);\n  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n  // `\n\n\n\n  function createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(\n      baseMaterial,\n      {\n        chained: true,\n        uniforms: {\n          pointA: {value: new three.Vector3()},\n          controlA: {value: new three.Vector3()},\n          controlB: {value: new three.Vector3()},\n          pointB: {value: new three.Vector3()},\n          radius: {value: 0.01},\n          dashing: {value: new three.Vector3()} //on, off, offset\n        },\n        vertexDefs,\n        vertexTransform,\n        fragmentDefs,\n        fragmentMainIntro\n      }\n    )\n  }\n\n  let geometry = null;\n\n  const defaultBaseMaterial = /*#__PURE__*/new three.MeshStandardMaterial({color: 0xffffff, side: three.DoubleSide});\n\n\n  /**\n   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n   * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n   * automatically.\n   *\n   * The cubiz bezier path is determined by its four `Vector3` properties:\n   * - `pointA`\n   * - `controlA`\n   * - `controlB`\n   * - `pointB`\n   *\n   * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n   *\n   * You can also give the tube a dashed appearance with two properties:\n   *\n   * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n   *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n   *   used as input to the cubic bezier function, not its visible length.)\n   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n   *\n   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n   * thicker tubes.\n   *\n   * TODO: proper geometry bounding sphere and raycasting\n   * TODO: allow control of the geometry's segment counts\n   */\n  class BezierMesh extends three.Mesh {\n    static getGeometry() {\n      return geometry || (geometry =\n        new three.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n      )\n    }\n\n    constructor() {\n      super(\n        BezierMesh.getGeometry(),\n        defaultBaseMaterial\n      );\n\n      this.pointA = new three.Vector3();\n      this.controlA = new three.Vector3();\n      this.controlB = new three.Vector3();\n      this.pointB = new three.Vector3();\n      this.radius = 0.01;\n      this.dashArray = new three.Vector2();\n      this.dashOffset = 0;\n\n      // TODO - disabling frustum culling until I figure out how to customize the\n      //  geometry's bounding sphere that gets used\n      this.frustumCulled = false;\n    }\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n      let derivedMaterial = this._derivedMaterial;\n      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial\n    }\n    set material(baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    }\n\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n      return this.material.getDepthMaterial()\n    }\n    get customDistanceMaterial() {\n      return this.material.getDistanceMaterial()\n    }\n\n    onBeforeRender() {\n      const {uniforms} = this.material;\n      const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    }\n\n    raycast(/*raycaster, intersects*/) {\n      // TODO - just fail for now\n    }\n  }\n\n  exports.BezierMesh = BezierMesh;\n  exports.createDerivedMaterial = createDerivedMaterial;\n  exports.expandShaderIncludes = expandShaderIncludes;\n  exports.getShaderUniformTypes = getShaderUniformTypes;\n  exports.getShadersForMaterial = getShadersForMaterial;\n  exports.invertMatrix4 = invertMatrix4;\n  exports.voidMainRegExp = voidMainRegExp;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLnVtZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMseURBQU87QUFDakcsRUFBRSxDQUNpSTtBQUNuSSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQSx1REFBdUQ7QUFDdkQsWUFBWTtBQUNaO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUSxrRUFBa0Usa0JBQWtCO0FBQ3pHLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FB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Q2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS11dGlscy9kaXN0L3Ryb2lrYS10aHJlZS11dGlscy51bWQuanM/ZDlmMSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3RocmVlJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICd0aHJlZSddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnRyb2lrYV90aHJlZV91dGlscyA9IHt9LCBnbG9iYWwuVEhSRUUpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCB0aHJlZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgdGhlIGB2b2lkIG1haW4oKSB7YCBvcGVuZXIgbGluZSBpbiBHTFNMLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgY29uc3Qgdm9pZE1haW5SZWdFeHAgPSAvXFxidm9pZFxccyttYWluXFxzKlxcKFxccypcXClcXHMqey9nO1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBleHBhbmRzIGFsbCBgI2luY2x1ZGUgPHh5ej5gIHN0YXRlbWVudHMgd2l0aGluIHN0cmluZyBvZiBzaGFkZXIgY29kZS5cbiAgICogQ29waWVkIGZyb20gdGhyZWUncyBXZWJHTFByb2dyYW0jcGFyc2VJbmNsdWRlcyBmb3IgZXh0ZXJuYWwgdXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gVGhlIEdMU0wgc291cmNlIGNvZGUgdG8gZXZhbHVhdGVcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgR0xTTCBjb2RlIHdpdGggYWxsIGluY2x1ZGVzIGV4cGFuZGVkXG4gICAqL1xuICBmdW5jdGlvbiBleHBhbmRTaGFkZXJJbmNsdWRlcyggc291cmNlICkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSAvXlsgXFx0XSojaW5jbHVkZSArPChbXFx3XFxkLi9dKyk+L2dtO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UobWF0Y2gsIGluY2x1ZGUpIHtcbiAgICAgIGxldCBjaHVuayA9IHRocmVlLlNoYWRlckNodW5rW2luY2x1ZGVdO1xuICAgICAgcmV0dXJuIGNodW5rID8gZXhwYW5kU2hhZGVySW5jbHVkZXMoY2h1bmspIDogbWF0Y2hcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlIClcbiAgfVxuXG4gIC8qXG4gICAqIFRoaXMgaXMgYSBkaXJlY3QgY29weSBvZiBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEIGZyb20gVGhyZWUuanMsIHRvIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgd2l0aCB0aHJlZVxuICAgKiB2ZXJzaW9ucyBiZWZvcmUgMC4xMTMuMCBhcyBpdCB3YXMgY2hhbmdlZCBmcm9tIE1hdGggdG8gTWF0aFV0aWxzIGluIHRoYXQgdmVyc2lvbi5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL2RkOGI1YWEzYjI3MGMxNzA5NmI5MDk0NWNkMmQ2ZDFiMTNhYWVjNTMvc3JjL21hdGgvTWF0aFV0aWxzLmpzI0wxNlxuICAgKi9cblxuICBjb25zdCBfbHV0ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIF9sdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgKGkpLnRvU3RyaW5nKDE2KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxuXG4gICAgY29uc3QgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgY29uc3QgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgY29uc3QgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgY29uc3QgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgY29uc3QgdXVpZCA9IF9sdXRbZDAgJiAweGZmXSArIF9sdXRbZDAgPj4gOCAmIDB4ZmZdICsgX2x1dFtkMCA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMCA+PiAyNCAmIDB4ZmZdICsgJy0nICtcbiAgICAgIF9sdXRbZDEgJiAweGZmXSArIF9sdXRbZDEgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMSA+PiAxNiAmIDB4MGYgfCAweDQwXSArIF9sdXRbZDEgPj4gMjQgJiAweGZmXSArICctJyArXG4gICAgICBfbHV0W2QyICYgMHgzZiB8IDB4ODBdICsgX2x1dFtkMiA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QyID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QyID4+IDI0ICYgMHhmZl0gK1xuICAgICAgX2x1dFtkMyAmIDB4ZmZdICsgX2x1dFtkMyA+PiA4ICYgMHhmZl0gKyBfbHV0W2QzID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QzID4+IDI0ICYgMHhmZl07XG5cbiAgICAvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG4gICAgcmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKVxuXG4gIH1cblxuICAvLyBMb2NhbCBhc3NpZ24gcG9seWZpbGwgdG8gYXZvaWQgaW1wb3J0aW5nIHRyb2lrYS1jb3JlXG4gIGNvbnN0IGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oLyp0YXJnZXQsIC4uLnNvdXJjZXMqLykge1xuICAgIGxldCB0YXJnZXQgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9O1xuXG5cbiAgY29uc3QgZXBvY2ggPSBEYXRlLm5vdygpO1xuICBjb25zdCBDT05TVFJVQ1RPUl9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IFNIQURFUl9VUEdSQURFX0NBQ0hFID0gbmV3IE1hcCgpO1xuXG4gIC8vIE1hdGVyaWFsIGlkcyBtdXN0IGJlIGludGVnZXJzLCBidXQgd2UgY2FuJ3QgYWNjZXNzIHRoZSBpbmNyZW1lbnQgZnJvbSBUaHJlZSdzIGBNYXRlcmlhbGAgbW9kdWxlLFxuICAvLyBzbyBsZXQncyBjaG9vc2UgYSBzdWZmaWNpZW50bHkgbGFyZ2Ugc3RhcnRpbmcgdmFsdWUgdGhhdCBzaG91bGQgdGhlb3JldGljYWxseSBuZXZlciBjb2xsaWRlLlxuICBsZXQgbWF0ZXJpYWxJbnN0YW5jZUlkID0gMWUxMDtcblxuICAvKipcbiAgICogQSB1dGlsaXR5IGZvciBjcmVhdGluZyBhIGN1c3RvbSBzaGFkZXIgbWF0ZXJpYWwgZGVyaXZlZCBmcm9tIGFub3RoZXIgbWF0ZXJpYWwnc1xuICAgKiBzaGFkZXJzLiBUaGlzIGFsbG93cyB5b3UgdG8gaW5qZWN0IGN1c3RvbSBzaGFkZXIgbG9naWMgYW5kIHRyYW5zZm9ybXMgaW50byB0aGVcbiAgICogYnVpbHRpbiBUaHJlZUpTIG1hdGVyaWFscyB3aXRob3V0IGhhdmluZyB0byByZWNyZWF0ZSB0aGVtIGZyb20gc2NyYXRjaC5cbiAgICpcbiAgICogQHBhcmFtIHtUSFJFRS5NYXRlcmlhbH0gYmFzZU1hdGVyaWFsIC0gdGhlIG9yaWdpbmFsIG1hdGVyaWFsIHRvIGRlcml2ZSBmcm9tXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gSG93IHRoZSBiYXNlIG1hdGVyaWFsIHNob3VsZCBiZSBtb2RpZmllZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGVmaW5lcyAtIEN1c3RvbSBgZGVmaW5lc2AgZm9yIHRoZSBtYXRlcmlhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5leHRlbnNpb25zIC0gQ3VzdG9tIGBleHRlbnNpb25zYCBmb3IgdGhlIG1hdGVyaWFsLCBlLmcuIGB7ZGVyaXZhdGl2ZXM6IHRydWV9YFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy51bmlmb3JtcyAtIEN1c3RvbSBgdW5pZm9ybXNgIGZvciB1c2UgaW4gdGhlIG1vZGlmaWVkIHNoYWRlci4gVGhlc2UgY2FuXG4gICAqICAgICAgICBiZSBhY2Nlc3NlZCBhbmQgbWFuaXB1bGF0ZWQgdmlhIHRoZSByZXN1bHRpbmcgbWF0ZXJpYWwncyBgdW5pZm9ybXNgIHByb3BlcnR5LCBqdXN0IGxpa2VcbiAgICogICAgICAgIGluIGEgU2hhZGVyTWF0ZXJpYWwuIFlvdSBkbyBub3QgbmVlZCB0byByZXBlYXQgdGhlIGJhc2UgbWF0ZXJpYWwncyBvd24gdW5pZm9ybXMgaGVyZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltZVVuaWZvcm0gLSBJZiBzcGVjaWZpZWQsIGEgdW5pZm9ybSBvZiB0aGlzIG5hbWUgd2lsbCBiZSBpbmplY3RlZCBpbnRvXG4gICAqICAgICAgICBib3RoIHNoYWRlcnMsIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgdXBkYXRlZCBvbiBlYWNoIHJlbmRlciBmcmFtZSB3aXRoIGEgbnVtYmVyIG9mXG4gICAqICAgICAgICBlbGFwc2VkIG1pbGxpc2Vjb25kcy4gVGhlIFwiemVyb1wiIGVwb2NoIHRpbWUgaXMgbm90IHNpZ25pZmljYW50IHNvIGRvbid0IHJlbHkgb24gdGhpcyBhcyBhXG4gICAqICAgICAgICB0cnVlIGNhbGVuZGFyIHRpbWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSB2ZXJ0ZXggc2hhZGVyJ3MgdG9wLWxldmVsXG4gICAqICAgICAgICBkZWZpbml0aW9ucywgYWJvdmUgdGhlIGB2b2lkIG1haW4oKWAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleE1haW5JbnRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSB0b3Agb2YgdGhlIHZlcnRleFxuICAgKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleE1haW5PdXRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSBlbmQgb2YgdGhlIHZlcnRleFxuICAgKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleFRyYW5zZm9ybSAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gbWFuaXB1bGF0ZSB0aGUgYHBvc2l0aW9uYCwgYG5vcm1hbGAsXG4gICAqICAgICAgICBhbmQvb3IgYHV2YCB2ZXJ0ZXggYXR0cmlidXRlcy4gVGhpcyBjb2RlIHdpbGwgYmUgd3JhcHBlZCB3aXRoaW4gYSBzdGFuZGFsb25lIGZ1bmN0aW9uIHdpdGhcbiAgICogICAgICAgIHRob3NlIGF0dHJpYnV0ZXMgZXhwb3NlZCBieSB0aGVpciBub3JtYWwgbmFtZXMgYXMgcmVhZC93cml0ZSB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50RGVmcyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGludG8gdGhlIGZyYWdtZW50IHNoYWRlcidzIHRvcC1sZXZlbFxuICAgKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudE1haW5JbnRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSB0b3Agb2YgdGhlIGZyYWdtZW50XG4gICAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnRNYWluT3V0cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudFxuICAgKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uIFlvdSBjYW4gbWFuaXB1bGF0ZSBgZ2xfRnJhZ0NvbG9yYCBoZXJlIGJ1dCBrZWVwIGluIG1pbmQgaXQgZ29lc1xuICAgKiAgICAgICAgYWZ0ZXIgYW55IG9mIFRocmVlSlMncyBjb2xvciBwb3N0cHJvY2Vzc2luZyBzaGFkZXIgY2h1bmtzICh0b25lbWFwcGluZywgZm9nLCBldGMuKSwgc28gaWYgeW91XG4gICAqICAgICAgICB3YW50IHRob3NlIHRvIGFwcGx5IHRvIHlvdXIgY2hhbmdlcyB1c2UgYGZyYWdtZW50Q29sb3JUcmFuc2Zvcm1gIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBnbF9GcmFnQ29sb3JgXG4gICAqICAgICAgICBvdXRwdXQgdmFsdWUuIFdpbGwgYmUgaW5qZWN0ZWQgbmVhciB0aGUgZW5kIG9mIHRoZSBgdm9pZCBtYWluYCBmdW5jdGlvbiwgYnV0IGJlZm9yZSBhbnlcbiAgICogICAgICAgIG9mIFRocmVlSlMncyBjb2xvciBwb3N0cHJvY2Vzc2luZyBzaGFkZXIgY2h1bmtzICh0b25lbWFwcGluZywgZm9nLCBldGMuKSwgYW5kIGJlZm9yZSB0aGVcbiAgICogICAgICAgIGBmcmFnbWVudE1haW5PdXRyb2AuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb248e3ZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcn0+Ont2ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXJ9fSBvcHRpb25zLmN1c3RvbVJld3JpdGVyIC0gQSBmdW5jdGlvblxuICAgKiAgICAgICAgZm9yIHBlcmZvcm1pbmcgY3VzdG9tIHJld3JpdGVzIG9mIHRoZSBmdWxsIHNoYWRlciBjb2RlLiBVc2VmdWwgaWYgeW91IG5lZWQgdG8gZG8gc29tZXRoaW5nXG4gICAqICAgICAgICBzcGVjaWFsIHRoYXQncyBub3QgY292ZXJlZCBieSB0aGUgb3RoZXIgYnVpbHRpbiBvcHRpb25zLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlXG4gICAqICAgICAgICBhbnkgb3RoZXIgdHJhbnNmb3JtcyBhcmUgYXBwbGllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNoYWluZWQgLSBTZXQgdG8gYHRydWVgIHRvIHByb3RvdHlwZS1jaGFpbiB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0byB0aGUgYmFzZVxuICAgKiAgICAgICAgbWF0ZXJpYWwsIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGNvcHlpbmcgaXQuIFRoaXMgYWxsb3dzIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvXG4gICAqICAgICAgICBhdXRvbWF0aWNhbGx5IHBpY2sgdXAgY2hhbmdlcyBtYWRlIHRvIHRoZSBiYXNlIG1hdGVyaWFsIGFuZCBpdHMgcHJvcGVydGllcy4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqICAgICAgICB3aGVyZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBpcyBoaWRkZW4gZnJvbSB0aGUgdXNlciBhcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGFsbG93aW5nIHRoZW1cbiAgICogICAgICAgIHRvIHdvcmsgd2l0aCB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgbGlrZSBub3JtYWwuIEJ1dCBpdCBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IgaWYgbm90XG4gICAqICAgICAgICBoYW5kbGVkIGNhcmVmdWxseS5cbiAgICpcbiAgICogQHJldHVybiB7VEhSRUUuTWF0ZXJpYWx9XG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBtYXRlcmlhbCB3aWxsIGFsc28gaGF2ZSB0d28gbmV3IG1ldGhvZHMsIGBnZXREZXB0aE1hdGVyaWFsKClgIGFuZCBgZ2V0RGlzdGFuY2VNYXRlcmlhbCgpYCxcbiAgICogd2hpY2ggY2FuIGJlIGNhbGxlZCB0byBnZXQgYSB2YXJpYW50IG9mIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGZvciB1c2UgaW4gc2hhZG93IGNhc3RpbmcuIElmIHRoZVxuICAgKiB0YXJnZXQgbWVzaCBpcyBleHBlY3RlZCB0byBjYXN0IHNoYWRvd3MsIHRoZW4geW91IGNhbiBhc3NpZ24gdGhlc2UgdG8gdGhlIG1lc2gncyBgY3VzdG9tRGVwdGhNYXRlcmlhbGBcbiAgICogKGZvciBkaXJlY3Rpb25hbCBhbmQgc3BvdCBsaWdodHMpIGFuZC9vciBgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbGAgKGZvciBwb2ludCBsaWdodHMpIHByb3BlcnRpZXMgdG9cbiAgICogYWxsb3cgdGhlIGNhc3Qgc2hhZG93IHRvIGhvbm9yIHlvdXIgZGVyaXZlZCBzaGFkZXIncyB2ZXJ0ZXggdHJhbnNmb3JtcyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy4gVGhlc2VcbiAgICogd2lsbCBhbHNvIHNldCBhIGN1c3RvbSBgI2RlZmluZSBJU19ERVBUSF9NQVRFUklBTGAgb3IgYCNkZWZpbmUgSVNfRElTVEFOQ0VfTUFURVJJQUxgIHRoYXQgeW91IGNhbiBsb29rXG4gICAqIGZvciBpbiB5b3VyIGRlcml2ZWQgc2hhZGVycyB3aXRoIGAjaWZkZWZgIHRvIGN1c3RvbWl6ZSB0aGVpciBiZWhhdmlvciBmb3IgdGhlIGRlcHRoIG9yIGRpc3RhbmNlXG4gICAqIHNjZW5hcmlvcywgZS5nLiBza2lwcGluZyBhbnRpYWxpYXNpbmcgb3IgZXhwZW5zaXZlIHNoYWRlciBsb2dpYy5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIG9wdGlvbnMpIHtcbiAgICAvLyBHZW5lcmF0ZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgY29udGVudCBvZiB0aGVzZSBgb3B0aW9uc2AuIFdlJ2xsIHVzZSB0aGlzXG4gICAgLy8gdGhyb3VnaG91dCBmb3IgY2FjaGluZyBhbmQgZm9yIGdlbmVyYXRpbmcgdGhlIHVwZ3JhZGVkIHNoYWRlciBjb2RlLiBUaGlzIGluY3JlYXNlc1xuICAgIC8vIHRoZSBsaWtlbGlob29kIHRoYXQgdGhlIHJlc3VsdGluZyBzaGFkZXJzIHdpbGwgbGluZSB1cCBhY3Jvc3MgbXVsdGlwbGUgY2FsbHMgc29cbiAgICAvLyB0aGVpciBHTCBwcm9ncmFtcyBjYW4gYmUgc2hhcmVkIGFuZCBjYWNoZWQuXG4gICAgY29uc3Qgb3B0aW9uc0tleSA9IGdldEtleUZvck9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgd2UndmUgYWxyZWFkeSBkZXJpdmVkIGZyb20gdGhpcyBiYXNlTWF0ZXJpYWwgdXNpbmcgdGhpc1xuICAgIC8vIHVuaXF1ZSBzZXQgb2Ygb3B0aW9ucywgYW5kIGlmIHNvIHJldXNlIHRoZSBjb25zdHJ1Y3RvciB0byBhdm9pZCBzb21lIGFsbG9jYXRpb25zLlxuICAgIGxldCBjdG9yc0J5RGVyaXZhdGlvbiA9IENPTlNUUlVDVE9SX0NBQ0hFLmdldChiYXNlTWF0ZXJpYWwpO1xuICAgIGlmICghY3RvcnNCeURlcml2YXRpb24pIHtcbiAgICAgIENPTlNUUlVDVE9SX0NBQ0hFLnNldChiYXNlTWF0ZXJpYWwsIChjdG9yc0J5RGVyaXZhdGlvbiA9IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgICB9XG4gICAgaWYgKGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldKSB7XG4gICAgICByZXR1cm4gbmV3IGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldKClcbiAgICB9XG5cbiAgICBjb25zdCBwcml2YXRlQmVmb3JlQ29tcGlsZVByb3AgPSBgX29uQmVmb3JlQ29tcGlsZSR7b3B0aW9uc0tleX1gO1xuXG4gICAgLy8gUHJpdmF0ZSBvbkJlZm9yZUNvbXBpbGUgaGFuZGxlciB0aGF0IGluamVjdHMgdGhlIG1vZGlmaWVkIHNoYWRlcnMgYW5kIHVuaWZvcm1zIHdoZW5cbiAgICAvLyB0aGUgcmVuZGVyZXIgc3dpdGNoZXMgdG8gdGhpcyBtYXRlcmlhbCdzIHByb2dyYW1cbiAgICBjb25zdCBvbkJlZm9yZUNvbXBpbGUgPSBmdW5jdGlvbiAoc2hhZGVySW5mbywgcmVuZGVyZXIpIHtcbiAgICAgIGJhc2VNYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUuY2FsbCh0aGlzLCBzaGFkZXJJbmZvLCByZW5kZXJlcik7XG5cbiAgICAgIC8vIFVwZ3JhZGUgdGhlIHNoYWRlcnMsIGNhY2hpbmcgdGhlIHJlc3VsdCBieSBpbmNvbWluZyBzb3VyY2UgY29kZVxuICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgKyAnfCcgKyBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyO1xuICAgICAgbGV0IHVwZ3JhZGVkU2hhZGVycyA9IFNIQURFUl9VUEdSQURFX0NBQ0hFW2NhY2hlS2V5XTtcbiAgICAgIGlmICghdXBncmFkZWRTaGFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHVwZ3JhZGVkID0gdXBncmFkZVNoYWRlcnModGhpcywgc2hhZGVySW5mbywgb3B0aW9ucywgb3B0aW9uc0tleSk7XG4gICAgICAgIHVwZ3JhZGVkU2hhZGVycyA9IFNIQURFUl9VUEdSQURFX0NBQ0hFW2NhY2hlS2V5XSA9IHVwZ3JhZGVkO1xuICAgICAgfVxuXG4gICAgICAvLyBJbmplY3QgdXBncmFkZWQgc2hhZGVycyBhbmQgdW5pZm9ybXMgaW50byB0aGUgcHJvZ3JhbVxuICAgICAgc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgPSB1cGdyYWRlZFNoYWRlcnMudmVydGV4U2hhZGVyO1xuICAgICAgc2hhZGVySW5mby5mcmFnbWVudFNoYWRlciA9IHVwZ3JhZGVkU2hhZGVycy5mcmFnbWVudFNoYWRlcjtcbiAgICAgIGFzc2lnbihzaGFkZXJJbmZvLnVuaWZvcm1zLCB0aGlzLnVuaWZvcm1zKTtcblxuICAgICAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICAgICAgaWYgKG9wdGlvbnMudGltZVVuaWZvcm0pIHtcbiAgICAgICAgc2hhZGVySW5mby51bmlmb3Jtc1tvcHRpb25zLnRpbWVVbmlmb3JtXSA9IHtcbiAgICAgICAgICBnZXQgdmFsdWUoKSB7cmV0dXJuIERhdGUubm93KCkgLSBlcG9jaH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlcnMgY2FuIHN0aWxsIGFkZCB0aGVpciBvd24gaGFuZGxlcnMgb24gdG9wIG9mIG91cnNcbiAgICAgIGlmICh0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0pIHtcbiAgICAgICAgdGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKHNoYWRlckluZm8pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBEZXJpdmVkTWF0ZXJpYWwgPSBmdW5jdGlvbiBEZXJpdmVkTWF0ZXJpYWwoKSB7XG4gICAgICByZXR1cm4gZGVyaXZlKG9wdGlvbnMuY2hhaW5lZCA/IGJhc2VNYXRlcmlhbCA6IGJhc2VNYXRlcmlhbC5jbG9uZSgpKVxuICAgIH07XG5cbiAgICBjb25zdCBkZXJpdmUgPSBmdW5jdGlvbihiYXNlKSB7XG4gICAgICAvLyBQcm90b3R5cGUgY2hhaW4gdG8gdGhlIGJhc2UgbWF0ZXJpYWxcbiAgICAgIGNvbnN0IGRlcml2ZWQgPSBPYmplY3QuY3JlYXRlKGJhc2UsIGRlc2NyaXB0b3IpO1xuXG4gICAgICAvLyBTdG9yZSB0aGUgYmFzZU1hdGVyaWFsIGZvciByZWZlcmVuY2U7IHRoaXMgaXMgYWx3YXlzIHRoZSBvcmlnaW5hbCBldmVuIHdoZW4gY2xvbmluZ1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWQsICdiYXNlTWF0ZXJpYWwnLCB7IHZhbHVlOiBiYXNlTWF0ZXJpYWwgfSk7XG5cbiAgICAgIC8vIE5lZWRzIGl0cyBvd24gaWRzXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZCwgJ2lkJywgeyB2YWx1ZTogbWF0ZXJpYWxJbnN0YW5jZUlkKysgfSk7XG4gICAgICBkZXJpdmVkLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuICAgICAgLy8gTWVyZ2UgdW5pZm9ybXMsIGRlZmluZXMsIGFuZCBleHRlbnNpb25zXG4gICAgICBkZXJpdmVkLnVuaWZvcm1zID0gYXNzaWduKHt9LCBiYXNlLnVuaWZvcm1zLCBvcHRpb25zLnVuaWZvcm1zKTtcbiAgICAgIGRlcml2ZWQuZGVmaW5lcyA9IGFzc2lnbih7fSwgYmFzZS5kZWZpbmVzLCBvcHRpb25zLmRlZmluZXMpO1xuICAgICAgZGVyaXZlZC5kZWZpbmVzW2BUUk9JS0FfREVSSVZFRF9NQVRFUklBTF8ke29wdGlvbnNLZXl9YF0gPSAnJzsgLy9mb3JjZSBhIHByb2dyYW0gY2hhbmdlIGZyb20gdGhlIGJhc2UgbWF0ZXJpYWxcbiAgICAgIGRlcml2ZWQuZXh0ZW5zaW9ucyA9IGFzc2lnbih7fSwgYmFzZS5leHRlbnNpb25zLCBvcHRpb25zLmV4dGVuc2lvbnMpO1xuXG4gICAgICAvLyBEb24ndCBpbmhlcml0IEV2ZW50RGlzcGF0Y2hlciBsaXN0ZW5lcnNcbiAgICAgIGRlcml2ZWQuX2xpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGRlcml2ZWRcbiAgICB9O1xuXG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7dmFsdWU6IERlcml2ZWRNYXRlcmlhbH0sXG4gICAgICBpc0Rlcml2ZWRNYXRlcmlhbDoge3ZhbHVlOiB0cnVlfSxcblxuICAgICAgY3VzdG9tUHJvZ3JhbUNhY2hlS2V5OiB7XG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNYXRlcmlhbC5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKSArICd8JyArIG9wdGlvbnNLZXlcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25CZWZvcmVDb21waWxlOiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gb25CZWZvcmVDb21waWxlXG4gICAgICAgIH0sXG4gICAgICAgIHNldChmbikge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSA9IGZuO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjb3B5OiB7XG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgYmFzZU1hdGVyaWFsLmNvcHkuY2FsbCh0aGlzLCBzb3VyY2UpO1xuICAgICAgICAgIGlmICghYmFzZU1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgIWJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbCkge1xuICAgICAgICAgICAgYXNzaWduKHRoaXMuZXh0ZW5zaW9ucywgc291cmNlLmV4dGVuc2lvbnMpO1xuICAgICAgICAgICAgYXNzaWduKHRoaXMuZGVmaW5lcywgc291cmNlLmRlZmluZXMpO1xuICAgICAgICAgICAgYXNzaWduKHRoaXMudW5pZm9ybXMsIHRocmVlLlVuaWZvcm1zVXRpbHMuY2xvbmUoc291cmNlLnVuaWZvcm1zKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNsb25lOiB7XG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgbmV3QmFzZSA9IG5ldyBiYXNlTWF0ZXJpYWwuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICByZXR1cm4gZGVyaXZlKG5ld0Jhc2UpLmNvcHkodGhpcylcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVdGlsaXR5IHRvIGdldCBhIE1lc2hEZXB0aE1hdGVyaWFsIHRoYXQgd2lsbCBob25vciB0aGlzIGRlcml2ZWQgbWF0ZXJpYWwncyB2ZXJ0ZXhcbiAgICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgICAqL1xuICAgICAgZ2V0RGVwdGhNYXRlcmlhbDoge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsO1xuICAgICAgICAgIGlmICghZGVwdGhNYXRlcmlhbCkge1xuICAgICAgICAgICAgZGVwdGhNYXRlcmlhbCA9IHRoaXMuX2RlcHRoTWF0ZXJpYWwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICAgIDogbmV3IHRocmVlLk1lc2hEZXB0aE1hdGVyaWFsKHsgZGVwdGhQYWNraW5nOiB0aHJlZS5SR0JBRGVwdGhQYWNraW5nIH0pLFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVwdGhNYXRlcmlhbC5kZWZpbmVzLklTX0RFUFRIX01BVEVSSUFMID0gJyc7XG4gICAgICAgICAgICBkZXB0aE1hdGVyaWFsLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtczsgLy9hdXRvbWF0aWNhbGx5IHJlY2lldmUgc2FtZSB1bmlmb3JtIHZhbHVlc1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVwdGhNYXRlcmlhbFxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERpc3RhbmNlTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAgICogdHJhbnNmb3JtYXRpb25zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLlxuICAgICAgICovXG4gICAgICBnZXREaXN0YW5jZU1hdGVyaWFsOiB7XG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZGlzdGFuY2VNYXRlcmlhbCA9IHRoaXMuX2Rpc3RhbmNlTWF0ZXJpYWw7XG4gICAgICAgICAgaWYgKCFkaXN0YW5jZU1hdGVyaWFsKSB7XG4gICAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsID0gdGhpcy5fZGlzdGFuY2VNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgICAgYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsXG4gICAgICAgICAgICAgICAgPyBiYXNlTWF0ZXJpYWwuZ2V0RGlzdGFuY2VNYXRlcmlhbCgpXG4gICAgICAgICAgICAgICAgOiBuZXcgdGhyZWUuTWVzaERpc3RhbmNlTWF0ZXJpYWwoKSxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwuZGVmaW5lcy5JU19ESVNUQU5DRV9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7IC8vYXV0b21hdGljYWxseSByZWNpZXZlIHNhbWUgdW5pZm9ybSB2YWx1ZXNcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpc3RhbmNlTWF0ZXJpYWxcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGlzcG9zZToge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICBjb25zdCB7X2RlcHRoTWF0ZXJpYWwsIF9kaXN0YW5jZU1hdGVyaWFsfSA9IHRoaXM7XG4gICAgICAgICAgaWYgKF9kZXB0aE1hdGVyaWFsKSBfZGVwdGhNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgaWYgKF9kaXN0YW5jZU1hdGVyaWFsKSBfZGlzdGFuY2VNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgYmFzZU1hdGVyaWFsLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSA9IERlcml2ZWRNYXRlcmlhbDtcbiAgICByZXR1cm4gbmV3IERlcml2ZWRNYXRlcmlhbCgpXG4gIH1cblxuXG4gIGZ1bmN0aW9uIHVwZ3JhZGVTaGFkZXJzKG1hdGVyaWFsLCB7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0sIG9wdGlvbnMsIGtleSkge1xuICAgIGxldCB7XG4gICAgICB2ZXJ0ZXhEZWZzLFxuICAgICAgdmVydGV4TWFpbkludHJvLFxuICAgICAgdmVydGV4TWFpbk91dHJvLFxuICAgICAgdmVydGV4VHJhbnNmb3JtLFxuICAgICAgZnJhZ21lbnREZWZzLFxuICAgICAgZnJhZ21lbnRNYWluSW50cm8sXG4gICAgICBmcmFnbWVudE1haW5PdXRybyxcbiAgICAgIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sXG4gICAgICBjdXN0b21SZXdyaXRlcixcbiAgICAgIHRpbWVVbmlmb3JtXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICB2ZXJ0ZXhEZWZzID0gdmVydGV4RGVmcyB8fCAnJztcbiAgICB2ZXJ0ZXhNYWluSW50cm8gPSB2ZXJ0ZXhNYWluSW50cm8gfHwgJyc7XG4gICAgdmVydGV4TWFpbk91dHJvID0gdmVydGV4TWFpbk91dHJvIHx8ICcnO1xuICAgIGZyYWdtZW50RGVmcyA9IGZyYWdtZW50RGVmcyB8fCAnJztcbiAgICBmcmFnbWVudE1haW5JbnRybyA9IGZyYWdtZW50TWFpbkludHJvIHx8ICcnO1xuICAgIGZyYWdtZW50TWFpbk91dHJvID0gZnJhZ21lbnRNYWluT3V0cm8gfHwgJyc7XG5cbiAgICAvLyBFeHBhbmQgaW5jbHVkZXMgaWYgbmVlZGVkXG4gICAgaWYgKHZlcnRleFRyYW5zZm9ybSB8fCBjdXN0b21SZXdyaXRlcikge1xuICAgICAgdmVydGV4U2hhZGVyID0gZXhwYW5kU2hhZGVySW5jbHVkZXModmVydGV4U2hhZGVyKTtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gYmUgYWJsZSB0byBmaW5kIHBvc3Rwcm9jZXNzaW5nIGNodW5rcyBhZnRlciBpbmNsdWRlIGV4cGFuc2lvbiBpbiBvcmRlciB0b1xuICAgICAgLy8gcHV0IHRoZW0gYWZ0ZXIgdGhlIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sIHNvIG1hcmsgdGhlbSB3aXRoIGNvbW1lbnRzIGZpcnN0LiBFdmVuIGlmXG4gICAgICAvLyB0aGlzIHBhcnRpY3VsYXIgZGVyaXZhdGlvbiBkb2Vzbid0IGhhdmUgYSBmcmFnbWVudENvbG9yVHJhbnNmb3JtLCBvdGhlciBkZXJpdmF0aW9ucyBtYXksXG4gICAgICAvLyBzbyB3ZSBzdGlsbCBtYXJrIHRoZW0uXG4gICAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAgIC9eWyBcXHRdKiNpbmNsdWRlIDwoKD86dG9uZW1hcHBpbmd8ZW5jb2RpbmdzfGZvZ3xwcmVtdWx0aXBsaWVkX2FscGhhfGRpdGhlcmluZylfZnJhZ21lbnQpPi9nbSxcbiAgICAgICAgJ1xcbi8vIUJFR0lOX1BPU1RfQ0hVTksgJDFcXG4kJlxcbi8vIUVORF9QT1NUX0NIVU5LXFxuJ1xuICAgICAgKTtcbiAgICAgIGZyYWdtZW50U2hhZGVyID0gZXhwYW5kU2hhZGVySW5jbHVkZXMoZnJhZ21lbnRTaGFkZXIpO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGN1c3RvbSByZXdyaXRlciBmdW5jdGlvblxuICAgIGlmIChjdXN0b21SZXdyaXRlcikge1xuICAgICAgbGV0IHJlcyA9IGN1c3RvbVJld3JpdGVyKHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSByZXMudmVydGV4U2hhZGVyO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgPSByZXMuZnJhZ21lbnRTaGFkZXI7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gbmVlZHMgdG8gZ28gYmVmb3JlIGFueSBwb3N0cHJvY2Vzc2luZyBjaHVua3MsIHNvIGV4dHJhY3RcbiAgICAvLyB0aG9zZSBhbmQgcmUtaW5zZXJ0IHRoZW0gaW50byB0aGUgb3V0cm8gaW4gdGhlIGNvcnJlY3QgcGxhY2U6XG4gICAgaWYgKGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0pIHtcbiAgICAgIGxldCBwb3N0Q2h1bmtzID0gW107XG4gICAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAgIC9eXFwvXFwvIUJFR0lOX1BPU1RfQ0hVTktbXl0rP15cXC9cXC8hRU5EX1BPU1RfQ0hVTksvZ20sIC8vIFteXSs/ID0gbm9uLWdyZWVkeSBtYXRjaCBvZiBhbnkgY2hhcnMgaW5jbHVkaW5nIG5ld2xpbmVzXG4gICAgICAgIG1hdGNoID0+IHtcbiAgICAgICAgICBwb3N0Q2h1bmtzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgZnJhZ21lbnRNYWluT3V0cm8gPSBgJHtmcmFnbWVudENvbG9yVHJhbnNmb3JtfVxcbiR7cG9zdENodW5rcy5qb2luKCdcXG4nKX1cXG4ke2ZyYWdtZW50TWFpbk91dHJvfWA7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICAgIGlmICh0aW1lVW5pZm9ybSkge1xuICAgICAgY29uc3QgY29kZSA9IGBcXG51bmlmb3JtIGZsb2F0ICR7dGltZVVuaWZvcm19O1xcbmA7XG4gICAgICB2ZXJ0ZXhEZWZzID0gY29kZSArIHZlcnRleERlZnM7XG4gICAgICBmcmFnbWVudERlZnMgPSBjb2RlICsgZnJhZ21lbnREZWZzO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBhIGZ1bmN0aW9uIGZvciB0aGUgdmVydGV4VHJhbnNmb3JtIGFuZCByZW5hbWUgYWxsIHVzYWdlcyBvZiBwb3NpdGlvbi9ub3JtYWwvdXZcbiAgICBpZiAodmVydGV4VHJhbnNmb3JtKSB7XG4gICAgICAvLyBIb2lzdCB0aGVzZSBkZWZzIHRvIHRoZSB2ZXJ5IHRvcCBzbyB0aGV5IHdvcmsgaW4gb3RoZXIgZnVuY3Rpb24gZGVmc1xuICAgICAgdmVydGV4U2hhZGVyID0gYHZlYzMgdHJvaWthX3Bvc2l0aW9uXyR7a2V5fTtcbnZlYzMgdHJvaWthX25vcm1hbF8ke2tleX07XG52ZWMyIHRyb2lrYV91dl8ke2tleX07XG4ke3ZlcnRleFNoYWRlcn1cbmA7XG4gICAgICB2ZXJ0ZXhEZWZzID0gYCR7dmVydGV4RGVmc31cbnZvaWQgdHJvaWthVmVydGV4VHJhbnNmb3JtJHtrZXl9KGlub3V0IHZlYzMgcG9zaXRpb24sIGlub3V0IHZlYzMgbm9ybWFsLCBpbm91dCB2ZWMyIHV2KSB7XG4gICR7dmVydGV4VHJhbnNmb3JtfVxufVxuYDtcbiAgICAgIHZlcnRleE1haW5JbnRybyA9IGBcbnRyb2lrYV9wb3NpdGlvbl8ke2tleX0gPSB2ZWMzKHBvc2l0aW9uKTtcbnRyb2lrYV9ub3JtYWxfJHtrZXl9ID0gdmVjMyhub3JtYWwpO1xudHJvaWthX3V2XyR7a2V5fSA9IHZlYzIodXYpO1xudHJvaWthVmVydGV4VHJhbnNmb3JtJHtrZXl9KHRyb2lrYV9wb3NpdGlvbl8ke2tleX0sIHRyb2lrYV9ub3JtYWxfJHtrZXl9LCB0cm9pa2FfdXZfJHtrZXl9KTtcbiR7dmVydGV4TWFpbkludHJvfVxuYDtcbiAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKC9cXGIocG9zaXRpb258bm9ybWFsfHV2KVxcYi9nLCAobWF0Y2gsIG1hdGNoMSwgaW5kZXgsIGZ1bGxTdHIpID0+IHtcbiAgICAgICAgcmV0dXJuIC9cXGJhdHRyaWJ1dGVcXHMrdmVjWzIzXVxccyskLy50ZXN0KGZ1bGxTdHIuc3Vic3RyKDAsIGluZGV4KSkgPyBtYXRjaDEgOiBgdHJvaWthXyR7bWF0Y2gxfV8ke2tleX1gXG4gICAgICB9KTtcblxuICAgICAgLy8gVGhyZWUgcjE1MiBpbnRyb2R1Y2VkIHRoZSBNQVBfVVYgdG9rZW4sIHJlcGxhY2UgaXQgdG9vIGlmIGl0J3MgcG9pbnRpbmcgdG8gdGhlIG1haW4gJ3V2J1xuICAgICAgLy8gUGVyaGFwcyB0aGUgb3RoZXIgdGV4dHVyZXMgdG9vIGdvaW5nIGZvcndhcmQ/XG4gICAgICBpZiAoIShtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmNoYW5uZWwgPiAwKSkge1xuICAgICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiTUFQX1VWXFxiL2csIGB0cm9pa2FfdXZfJHtrZXl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGRlZnMgYW5kIGludHJvL291dHJvIHNuaXBwZXRzXG4gICAgdmVydGV4U2hhZGVyID0gaW5qZWN0SW50b1NoYWRlckNvZGUodmVydGV4U2hhZGVyLCBrZXksIHZlcnRleERlZnMsIHZlcnRleE1haW5JbnRybywgdmVydGV4TWFpbk91dHJvKTtcbiAgICBmcmFnbWVudFNoYWRlciA9IGluamVjdEludG9TaGFkZXJDb2RlKGZyYWdtZW50U2hhZGVyLCBrZXksIGZyYWdtZW50RGVmcywgZnJhZ21lbnRNYWluSW50cm8sIGZyYWdtZW50TWFpbk91dHJvKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluamVjdEludG9TaGFkZXJDb2RlKHNoYWRlckNvZGUsIGlkLCBkZWZzLCBpbnRybywgb3V0cm8pIHtcbiAgICBpZiAoaW50cm8gfHwgb3V0cm8gfHwgZGVmcykge1xuICAgICAgc2hhZGVyQ29kZSA9IHNoYWRlckNvZGUucmVwbGFjZSh2b2lkTWFpblJlZ0V4cCwgYFxuJHtkZWZzfVxudm9pZCB0cm9pa2FPcmlnTWFpbiR7aWR9KCkge2BcbiAgICAgICk7XG4gICAgICBzaGFkZXJDb2RlICs9IGBcbnZvaWQgbWFpbigpIHtcbiAgJHtpbnRyb31cbiAgdHJvaWthT3JpZ01haW4ke2lkfSgpO1xuICAke291dHJvfVxufWA7XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXJDb2RlXG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9wdGlvbnNKc29uUmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBrZXkgPT09ICd1bmlmb3JtcycgPyB1bmRlZmluZWQgOiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWVcbiAgfVxuXG4gIGxldCBfaWRDdHIgPSAwO1xuICBjb25zdCBvcHRpb25zSGFzaGVzVG9JZHMgPSBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGdldEtleUZvck9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNIYXNoID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgb3B0aW9uc0pzb25SZXBsYWNlcik7XG4gICAgbGV0IGlkID0gb3B0aW9uc0hhc2hlc1RvSWRzLmdldChvcHRpb25zSGFzaCk7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnNIYXNoZXNUb0lkcy5zZXQob3B0aW9uc0hhc2gsIChpZCA9ICsrX2lkQ3RyKSk7XG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG5cbiAgLy8gQ29waWVkIGZyb20gdGhyZWVqcyBXZWJHTFByb2dyYW1zLmpzIHNvIHdlIGNhbiByZXNvbHZlIGJ1aWx0aW4gbWF0ZXJpYWxzIHRvIHRoZWlyIHNoYWRlcnNcbiAgLy8gVE9ETyBob3cgY2FuIHdlIGtlZXAgdGhpcyBmcm9tIGdldHRpbmcgc3RhbGU/XG4gIGNvbnN0IE1BVEVSSUFMX1RZUEVTX1RPX1NIQURFUlMgPSB7XG4gICAgTWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXG4gICAgTWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuICAgIE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXG4gICAgTWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gICAgTWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICAgIE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxuICAgIE1lc2hUb29uTWF0ZXJpYWw6ICd0b29uJyxcbiAgICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgICBNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgICBNZXNoTWF0Y2FwTWF0ZXJpYWw6ICdtYXRjYXAnLFxuICAgIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICAgIExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXG4gICAgUG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnLFxuICAgIFNoYWRvd01hdGVyaWFsOiAnc2hhZG93JyxcbiAgICBTcHJpdGVNYXRlcmlhbDogJ3Nwcml0ZSdcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBUaHJlZS5qcyBgTWF0ZXJpYWxgIGluc3RhbmNlLCBmaW5kIHRoZSBzaGFkZXJzL3VuaWZvcm1zIHRoYXQgd2lsbCBiZVxuICAgKiB1c2VkIHRvIHJlbmRlciB0aGF0IG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0gbWF0ZXJpYWwgLSB0aGUgTWF0ZXJpYWwgaW5zdGFuY2VcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIHRoZSBtYXRlcmlhbCdzIHNoYWRlciBpbmZvOiBge3VuaWZvcm1zOnt9LCBmcmFnbWVudFNoYWRlcjonJywgdmVydGV4U2hhZGVyOicnfWBcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNoYWRlcnNGb3JNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgIGxldCBidWlsdGluVHlwZSA9IE1BVEVSSUFMX1RZUEVTX1RPX1NIQURFUlNbbWF0ZXJpYWwudHlwZV07XG4gICAgcmV0dXJuIGJ1aWx0aW5UeXBlID8gdGhyZWUuU2hhZGVyTGliW2J1aWx0aW5UeXBlXSA6IG1hdGVyaWFsIC8vVE9ETyBmYWxsYmFjayBmb3IgdW5rbm93biB0eXBlP1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIHVuaWZvcm1zIGFuZCB0aGVpciB0eXBlcyB3aXRoaW4gYSBzaGFkZXIgY29kZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXIgLSBUaGUgc2hhZGVyIGNvZGUgdG8gcGFyc2VcbiAgICogQHJldHVybiB7b2JqZWN0fSBtYXBwaW5nIG9mIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgZ2xzbCB0eXBlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTaGFkZXJVbmlmb3JtVHlwZXMoc2hhZGVyKSB7XG4gICAgbGV0IHVuaWZvcm1SRSA9IC9cXGJ1bmlmb3JtXFxzKyhpbnR8ZmxvYXR8dmVjWzIzNF18bWF0WzM0XSlcXHMrKFtBLVphLXpfXVtcXHddKikvZztcbiAgICBsZXQgdW5pZm9ybXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gdW5pZm9ybVJFLmV4ZWMoc2hhZGVyKSkgIT09IG51bGwpIHtcbiAgICAgIHVuaWZvcm1zW21hdGNoWzJdXSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgICByZXR1cm4gdW5pZm9ybXNcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIHNtb290aGluZyBvdXQgdGhlIGBtLmdldEludmVyc2UoeClgIC0tPiBgbS5jb3B5KHgpLmludmVydCgpYCBjb252ZXJzaW9uXG4gICAqIHRoYXQgaGFwcGVuZWQgaW4gVGhyZWVKUyByMTIzLlxuICAgKiBAcGFyYW0ge01hdHJpeDR9IHNyY01hdHJpeFxuICAgKiBAcGFyYW0ge01hdHJpeDR9IFt0Z3RNYXRyaXhdXG4gICAqL1xuICBmdW5jdGlvbiBpbnZlcnRNYXRyaXg0KHNyY01hdHJpeCwgdGd0TWF0cml4ID0gbmV3IHRocmVlLk1hdHJpeDQoKSkge1xuICAgIGlmICh0eXBlb2YgdGd0TWF0cml4LmludmVydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGd0TWF0cml4LmNvcHkoc3JjTWF0cml4KS5pbnZlcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGd0TWF0cml4LmdldEludmVyc2Uoc3JjTWF0cml4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRndE1hdHJpeFxuICB9XG5cbiAgLypcbiAgSW5wdXQgZ2VvbWV0cnkgaXMgYSBjeWxpbmRlciB3aXRoIHI9MSwgaGVpZ2h0IGluIHkgZGltZW5zaW9uIGZyb20gMCB0byAxLFxuICBkaXZpZGVkIGludG8gYSByZWFzb25hYmxlIG51bWJlciBvZiBoZWlnaHQgc2VnbWVudHMuXG4gICovXG5cbiAgY29uc3QgdmVydGV4RGVmcyA9IGBcbnVuaWZvcm0gdmVjMyBwb2ludEE7XG51bmlmb3JtIHZlYzMgY29udHJvbEE7XG51bmlmb3JtIHZlYzMgY29udHJvbEI7XG51bmlmb3JtIHZlYzMgcG9pbnRCO1xudW5pZm9ybSBmbG9hdCByYWRpdXM7XG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XG5cbnZlYzMgY3ViaWNCZXppZXIodmVjMyBwMSwgdmVjMyBjMSwgdmVjMyBjMiwgdmVjMyBwMiwgZmxvYXQgdCkge1xuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XG4gIGZsb2F0IGIwID0gdDIgKiB0MiAqIHQyO1xuICBmbG9hdCBiMSA9IDMuMCAqIHQgKiB0MiAqIHQyO1xuICBmbG9hdCBiMiA9IDMuMCAqIHQgKiB0ICogdDI7XG4gIGZsb2F0IGIzID0gdCAqIHQgKiB0O1xuICByZXR1cm4gYjAgKiBwMSArIGIxICogYzEgKyBiMiAqIGMyICsgYjMgKiBwMjtcbn1cblxudmVjMyBjdWJpY0JlemllckRlcml2YXRpdmUodmVjMyBwMSwgdmVjMyBjMSwgdmVjMyBjMiwgdmVjMyBwMiwgZmxvYXQgdCkge1xuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XG4gIHJldHVybiAtMy4wICogcDEgKiB0MiAqIHQyICtcbiAgICBjMSAqICgzLjAgKiB0MiAqIHQyIC0gNi4wICogdDIgKiB0KSArXG4gICAgYzIgKiAoNi4wICogdDIgKiB0IC0gMy4wICogdCAqIHQpICtcbiAgICAzLjAgKiBwMiAqIHQgKiB0O1xufVxuYDtcblxuICBjb25zdCB2ZXJ0ZXhUcmFuc2Zvcm0gPSBgXG5mbG9hdCB0ID0gcG9zaXRpb24ueTtcbmJlemllclQgPSB0O1xudmVjMyBiZXppZXJDZW50ZXJQb3MgPSBjdWJpY0Jlemllcihwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KTtcbnZlYzMgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KSk7XG5cbi8vIE1ha2UgXCJzaWRld2F5c1wiIGFsd2F5cyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBjYW1lcmEgcmF5OyB0aGlzIGVuc3VyZXMgdGhhdCBhbnkgdHdpc3RzXG4vLyBpbiB0aGUgY3lsaW5kZXIgb2NjdXIgd2hlcmUgeW91IHdvbid0IHNlZSB0aGVtOiBcbnZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbE1hdHJpeCAqIHZlYzMoMC4wLCAwLjAsIDEuMCk7XG5pZiAoYmV6aWVyRGlyID09IHZpZXdEaXJlY3Rpb24pIHtcbiAgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0ID09IDEuMCA/IHQgLSAwLjAwMDEgOiB0ICsgMC4wMDAxKSk7XG59XG52ZWMzIHNpZGV3YXlzID0gbm9ybWFsaXplKGNyb3NzKGJlemllckRpciwgdmlld0RpcmVjdGlvbikpO1xudmVjMyB1cGlzaCA9IG5vcm1hbGl6ZShjcm9zcyhzaWRld2F5cywgYmV6aWVyRGlyKSk7XG5cbi8vIEJ1aWxkIGEgbWF0cml4IGZvciB0cmFuc2Zvcm1pbmcgdGhpcyBkaXNjIGluIHRoZSBjeWxpbmRlcjpcbm1hdDQgZGlzY1R4O1xuZGlzY1R4WzBdLnh5eiA9IHNpZGV3YXlzICogcmFkaXVzO1xuZGlzY1R4WzFdLnh5eiA9IGJlemllckRpciAqIHJhZGl1cztcbmRpc2NUeFsyXS54eXogPSB1cGlzaCAqIHJhZGl1cztcbmRpc2NUeFszXS54eXogPSBiZXppZXJDZW50ZXJQb3M7XG5kaXNjVHhbM11bM10gPSAxLjA7XG5cbi8vIEFwcGx5IHRyYW5zZm9ybSwgaWdub3Jpbmcgb3JpZ2luYWwgeVxucG9zaXRpb24gPSAoZGlzY1R4ICogdmVjNChwb3NpdGlvbi54LCAwLjAsIHBvc2l0aW9uLnosIDEuMCkpLnh5ejtcbm5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKGRpc2NUeCkgKiBub3JtYWwpO1xuYDtcblxuICBjb25zdCBmcmFnbWVudERlZnMgPSBgXG51bmlmb3JtIHZlYzMgZGFzaGluZztcbnZhcnlpbmcgZmxvYXQgYmV6aWVyVDtcbmA7XG5cbiAgY29uc3QgZnJhZ21lbnRNYWluSW50cm8gPSBgXG5pZiAoZGFzaGluZy54ICsgZGFzaGluZy55ID4gMC4wKSB7XG4gIGZsb2F0IGRhc2hGcmFjID0gbW9kKGJlemllclQgLSBkYXNoaW5nLnosIGRhc2hpbmcueCArIGRhc2hpbmcueSk7XG4gIGlmIChkYXNoRnJhYyA+IGRhc2hpbmcueCkge1xuICAgIGRpc2NhcmQ7XG4gIH1cbn1cbmA7XG5cbiAgLy8gRGVidWdnaW5nOiBzZXBhcmF0ZSBjb2xvciBmb3IgZWFjaCBvZiB0aGUgNiBzaWRlczpcbiAgLy8gY29uc3QgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSA9IGBcbiAgLy8gZmxvYXQgc2lkZU51bSA9IGZsb29yKHZVVi54ICogNi4wKTtcbiAgLy8gdmVjMyBtaXhDb2xvciA9IHNpZGVOdW0gPCAxLjAgPyB2ZWMzKDEuMCwgMC4wLCAwLjApIDpcbiAgLy8gICBzaWRlTnVtIDwgMi4wID8gdmVjMygwLjAsIDEuMCwgMS4wKSA6XG4gIC8vICAgc2lkZU51bSA8IDMuMCA/IHZlYzMoMS4wLCAxLjAsIDAuMCkgOlxuICAvLyAgIHNpZGVOdW0gPCA0LjAgPyB2ZWMzKDAuMCwgMC4wLCAxLjApIDpcbiAgLy8gICBzaWRlTnVtIDwgNS4wID8gdmVjMygwLjAsIDEuMCwgMC4wKSA6XG4gIC8vICAgdmVjMygxLjAsIDAuMCwgMS4wKTtcbiAgLy8gZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peChnbF9GcmFnQ29sb3IueHl6LCBtaXhDb2xvciwgMC41KTtcbiAgLy8gYFxuXG5cblxuICBmdW5jdGlvbiBjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgIGJhc2VNYXRlcmlhbCxcbiAgICAgIHtcbiAgICAgICAgY2hhaW5lZDogdHJ1ZSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBwb2ludEE6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKX0sXG4gICAgICAgICAgY29udHJvbEE6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKX0sXG4gICAgICAgICAgY29udHJvbEI6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKX0sXG4gICAgICAgICAgcG9pbnRCOiB7dmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IzKCl9LFxuICAgICAgICAgIHJhZGl1czoge3ZhbHVlOiAwLjAxfSxcbiAgICAgICAgICBkYXNoaW5nOiB7dmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IzKCl9IC8vb24sIG9mZiwgb2Zmc2V0XG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRleERlZnMsXG4gICAgICAgIHZlcnRleFRyYW5zZm9ybSxcbiAgICAgICAgZnJhZ21lbnREZWZzLFxuICAgICAgICBmcmFnbWVudE1haW5JbnRyb1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIGxldCBnZW9tZXRyeSA9IG51bGw7XG5cbiAgY29uc3QgZGVmYXVsdEJhc2VNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9uZXcgdGhyZWUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe2NvbG9yOiAweGZmZmZmZiwgc2lkZTogdGhyZWUuRG91YmxlU2lkZX0pO1xuXG5cbiAgLyoqXG4gICAqIEEgVGhyZWVKUyBgTWVzaGAgdGhhdCBiZW5kcyBhIHR1YmUgc2hhcGUgYWxvbmcgYSAzRCBjdWJpYyBiZXppZXIgcGF0aC4gVGhlIGJlbmRpbmcgaXMgZG9uZVxuICAgKiBieSBkZWZvcm1pbmcgYSBzdHJhaWdodCBjeWxpbmRyaWNhbCBnZW9tZXRyeSBpbiB0aGUgdmVydGV4IHNoYWRlciBiYXNlZCBvbiBhIHNldCBvZiBmb3VyXG4gICAqIGNvbnRyb2wgcG9pbnQgdW5pZm9ybXMuIEl0IHBhdGNoZXMgdGhlIG5lY2Vzc2FyeSBHTFNMIGludG8gdGhlIG1lc2gncyBhc3NpZ25lZCBgbWF0ZXJpYWxgXG4gICAqIGF1dG9tYXRpY2FsbHkuXG4gICAqXG4gICAqIFRoZSBjdWJpeiBiZXppZXIgcGF0aCBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBmb3VyIGBWZWN0b3IzYCBwcm9wZXJ0aWVzOlxuICAgKiAtIGBwb2ludEFgXG4gICAqIC0gYGNvbnRyb2xBYFxuICAgKiAtIGBjb250cm9sQmBcbiAgICogLSBgcG9pbnRCYFxuICAgKlxuICAgKiBUaGUgdHViZSdzIHJhZGl1cyBpcyBjb250cm9sbGVkIGJ5IGl0cyBgcmFkaXVzYCBwcm9wZXJ0eSwgd2hpY2ggZGVmYXVsdHMgdG8gYDAuMDFgLlxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gZ2l2ZSB0aGUgdHViZSBhIGRhc2hlZCBhcHBlYXJhbmNlIHdpdGggdHdvIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIC0gYGRhc2hBcnJheWAgLSBhbiBhcnJheSBvZiB0d28gbnVtYmVycywgZGVmaW5pbmcgdGhlIGxlbmd0aCBvZiBcIm9uXCIgYW5kIFwib2ZmXCIgcGFydHMgb2ZcbiAgICogICB0aGUgZGFzaC4gRWFjaCBpcyBhIDAtMSByYXRpbyBvZiB0aGUgZW50aXJlIHBhdGgncyBsZW5ndGguIChBY3R1YWxseSB0aGlzIGlzIHRoZSBgdGAgbGVuZ3RoXG4gICAqICAgdXNlZCBhcyBpbnB1dCB0byB0aGUgY3ViaWMgYmV6aWVyIGZ1bmN0aW9uLCBub3QgaXRzIHZpc2libGUgbGVuZ3RoLilcbiAgICogLSBgZGFzaE9mZnNldGAgLSBvZmZzZXQgb2Ygd2hlcmUgdGhlIGRhc2ggc3RhcnRzLiBZb3UgY2FuIGFuaW1hdGUgdGhpcyB0byBtYWtlIHRoZSBkYXNoZXMgbW92ZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBkYXNoZXMgd2lsbCBhcHBlYXIgbGlrZSBhIGhvbGxvdyB0dWJlLCBub3Qgc29saWQuIFRoaXMgd2lsbCBiZSBtb3JlIGFwcGFyZW50IG9uXG4gICAqIHRoaWNrZXIgdHViZXMuXG4gICAqXG4gICAqIFRPRE86IHByb3BlciBnZW9tZXRyeSBib3VuZGluZyBzcGhlcmUgYW5kIHJheWNhc3RpbmdcbiAgICogVE9ETzogYWxsb3cgY29udHJvbCBvZiB0aGUgZ2VvbWV0cnkncyBzZWdtZW50IGNvdW50c1xuICAgKi9cbiAgY2xhc3MgQmV6aWVyTWVzaCBleHRlbmRzIHRocmVlLk1lc2gge1xuICAgIHN0YXRpYyBnZXRHZW9tZXRyeSgpIHtcbiAgICAgIHJldHVybiBnZW9tZXRyeSB8fCAoZ2VvbWV0cnkgPVxuICAgICAgICBuZXcgdGhyZWUuQ3lsaW5kZXJHZW9tZXRyeSgxLCAxLCAxLCA2LCA2NCkudHJhbnNsYXRlKDAsIDAuNSwgMClcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKFxuICAgICAgICBCZXppZXJNZXNoLmdldEdlb21ldHJ5KCksXG4gICAgICAgIGRlZmF1bHRCYXNlTWF0ZXJpYWxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMucG9pbnRBID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY29udHJvbEEgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICAgICAgdGhpcy5jb250cm9sQiA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgICB0aGlzLnBvaW50QiA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgICB0aGlzLnJhZGl1cyA9IDAuMDE7XG4gICAgICB0aGlzLmRhc2hBcnJheSA9IG5ldyB0aHJlZS5WZWN0b3IyKCk7XG4gICAgICB0aGlzLmRhc2hPZmZzZXQgPSAwO1xuXG4gICAgICAvLyBUT0RPIC0gZGlzYWJsaW5nIGZydXN0dW0gY3VsbGluZyB1bnRpbCBJIGZpZ3VyZSBvdXQgaG93IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAgIC8vICBnZW9tZXRyeSdzIGJvdW5kaW5nIHNwaGVyZSB0aGF0IGdldHMgdXNlZFxuICAgICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlciBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyB0aGUgYmFzZSBtYXRlcmlhbCB3aXRoIG91ciB1cGdyYWRlcy4gV2UgZG8gdGhlIHdyYXBwaW5nXG4gICAgLy8gbGF6aWx5IG9uIF9yZWFkXyByYXRoZXIgdGhhbiB3cml0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3cmFwcGluZyBvbiB0cmFuc2llbnQgdmFsdWVzLlxuICAgIGdldCBtYXRlcmlhbCgpIHtcbiAgICAgIGxldCBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWw7XG4gICAgICBjb25zdCBiYXNlTWF0ZXJpYWwgPSB0aGlzLl9iYXNlTWF0ZXJpYWwgfHwgdGhpcy5fZGVmYXVsdE1hdGVyaWFsIHx8ICh0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgPSBkZWZhdWx0QmFzZU1hdGVyaWFsLmNsb25lKCkpO1xuICAgICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICAgICAgICAvLyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHdoZW4gaXRzIGJhc2UgbWF0ZXJpYWwgaXMgZGlzcG9zZWQ6XG4gICAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICAgIGJhc2VNYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25EaXNwb3NlKTtcbiAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXJpdmVkTWF0ZXJpYWxcbiAgICB9XG4gICAgc2V0IG1hdGVyaWFsKGJhc2VNYXRlcmlhbCkge1xuICAgICAgdGhpcy5fYmFzZU1hdGVyaWFsID0gYmFzZU1hdGVyaWFsO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbmQgdXBkYXRlIG1hdGVyaWFsIGZvciBzaGFkb3dzIHVwb24gcmVxdWVzdDpcbiAgICBnZXQgY3VzdG9tRGVwdGhNYXRlcmlhbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICAgIH1cbiAgICBnZXQgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICAgIH1cblxuICAgIG9uQmVmb3JlUmVuZGVyKCkge1xuICAgICAgY29uc3Qge3VuaWZvcm1zfSA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICBjb25zdCB7cG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgcmFkaXVzLCBkYXNoQXJyYXksIGRhc2hPZmZzZXR9ID0gdGhpcztcbiAgICAgIHVuaWZvcm1zLnBvaW50QS52YWx1ZS5jb3B5KHBvaW50QSk7XG4gICAgICB1bmlmb3Jtcy5jb250cm9sQS52YWx1ZS5jb3B5KGNvbnRyb2xBKTtcbiAgICAgIHVuaWZvcm1zLmNvbnRyb2xCLnZhbHVlLmNvcHkoY29udHJvbEIpO1xuICAgICAgdW5pZm9ybXMucG9pbnRCLnZhbHVlLmNvcHkocG9pbnRCKTtcbiAgICAgIHVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJhZGl1cztcbiAgICAgIHVuaWZvcm1zLmRhc2hpbmcudmFsdWUuc2V0KGRhc2hBcnJheS54LCBkYXNoQXJyYXkueSwgZGFzaE9mZnNldCB8fCAwKTtcbiAgICB9XG5cbiAgICByYXljYXN0KC8qcmF5Y2FzdGVyLCBpbnRlcnNlY3RzKi8pIHtcbiAgICAgIC8vIFRPRE8gLSBqdXN0IGZhaWwgZm9yIG5vd1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydHMuQmV6aWVyTWVzaCA9IEJlemllck1lc2g7XG4gIGV4cG9ydHMuY3JlYXRlRGVyaXZlZE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsO1xuICBleHBvcnRzLmV4cGFuZFNoYWRlckluY2x1ZGVzID0gZXhwYW5kU2hhZGVySW5jbHVkZXM7XG4gIGV4cG9ydHMuZ2V0U2hhZGVyVW5pZm9ybVR5cGVzID0gZ2V0U2hhZGVyVW5pZm9ybVR5cGVzO1xuICBleHBvcnRzLmdldFNoYWRlcnNGb3JNYXRlcmlhbCA9IGdldFNoYWRlcnNGb3JNYXRlcmlhbDtcbiAgZXhwb3J0cy5pbnZlcnRNYXRyaXg0ID0gaW52ZXJ0TWF0cml4NDtcbiAgZXhwb3J0cy52b2lkTWFpblJlZ0V4cCA9IHZvaWRNYWluUmVnRXhwO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js\n");

/***/ })

};
;