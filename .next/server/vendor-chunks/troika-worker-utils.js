/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-worker-utils";
exports.ids = ["vendor-chunks/troika-worker-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js":
/*!**************************************************************************!*\
  !*** ./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, (function (exports) { 'use strict';\n\n  /**\n   * Main content for the worker that handles the loading and execution of\n   * modules within it.\n   */\n  function workerBootstrap() {\n    var modules = Object.create(null);\n\n    // Handle messages for registering a module\n    function registerModule(ref, callback) {\n      var id = ref.id;\n      var name = ref.name;\n      var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n      var init = ref.init; if ( init === void 0 ) init = function(){};\n      var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n      // Only register once\n      if (modules[id]) { return }\n\n      try {\n        // If any dependencies are modules, ensure they're registered and grab their value\n        dependencies = dependencies.map(function (dep) {\n          if (dep && dep.isWorkerModule) {\n            registerModule(dep, function (depResult) {\n              if (depResult instanceof Error) { throw depResult }\n            });\n            dep = modules[dep.id].value;\n          }\n          return dep\n        });\n\n        // Rehydrate functions\n        init = rehydrate((\"<\" + name + \">.init\"), init);\n        if (getTransferables) {\n          getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n        }\n\n        // Initialize the module and store its value\n        var value = null;\n        if (typeof init === 'function') {\n          value = init.apply(void 0, dependencies);\n        } else {\n          console.error('worker module init function failed to rehydrate');\n        }\n        modules[id] = {\n          id: id,\n          value: value,\n          getTransferables: getTransferables\n        };\n        callback(value);\n      } catch(err) {\n        if (!(err && err.noLog)) {\n          console.error(err);\n        }\n        callback(err);\n      }\n    }\n\n    // Handle messages for calling a registered module's result function\n    function callModule(ref, callback) {\n      var ref$1;\n\n      var id = ref.id;\n      var args = ref.args;\n      if (!modules[id] || typeof modules[id].value !== 'function') {\n        callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n      }\n      try {\n        var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n        if (result && typeof result.then === 'function') {\n          result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n        } else {\n          handleResult(result);\n        }\n      } catch(err) {\n        callback(err);\n      }\n      function handleResult(result) {\n        try {\n          var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n          if (!tx || !Array.isArray(tx) || !tx.length) {\n            tx = undefined; //postMessage is very picky about not passing null or empty transferables\n          }\n          callback(result, tx);\n        } catch(err) {\n          console.error(err);\n          callback(err);\n        }\n      }\n    }\n\n    function rehydrate(name, str) {\n      var result = void 0;\n      self.troikaDefine = function (r) { return result = r; };\n      var url = URL.createObjectURL(\n        new Blob(\n          [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n          {type: 'application/javascript'}\n        )\n      );\n      try {\n        importScripts(url);\n      } catch(err) {\n        console.error(err);\n      }\n      URL.revokeObjectURL(url);\n      delete self.troikaDefine;\n      return result\n    }\n\n    // Handler for all messages within the worker\n    self.addEventListener('message', function (e) {\n      var ref = e.data;\n      var messageId = ref.messageId;\n      var action = ref.action;\n      var data = ref.data;\n      try {\n        // Module registration\n        if (action === 'registerModule') {\n          registerModule(data, function (result) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: {isCallable: typeof result === 'function'}\n              });\n            }\n          });\n        }\n        // Invocation\n        if (action === 'callModule') {\n          callModule(data, function (result, transferables) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: result\n              }, transferables || undefined);\n            }\n          });\n        }\n      } catch(err) {\n        postMessage({\n          messageId: messageId,\n          success: false,\n          error: err.stack\n        });\n      }\n    });\n  }\n\n  /**\n   * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n   * thread, for when the execution environment doesn't support web workers or they\n   * are disallowed due to e.g. CSP security restrictions.\n   */\n  function defineMainThreadModule(options) {\n    var moduleFunc = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return moduleFunc._getInitResult().then(function (initResult) {\n        if (typeof initResult === 'function') {\n          return initResult.apply(void 0, args)\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function')\n        }\n      })\n    };\n    moduleFunc._getInitResult = function() {\n      // We can ignore getTransferables in main thread. TODO workerId?\n      var dependencies = options.dependencies;\n      var init = options.init;\n\n      // Resolve dependencies\n      dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }\n      ) : [];\n\n      // Invoke init with the resolved dependencies\n      var initPromise = Promise.all(dependencies).then(function (deps) {\n        return init.apply(null, deps)\n      });\n\n      // Cache the resolved promise for subsequent calls\n      moduleFunc._getInitResult = function () { return initPromise; };\n\n      return initPromise\n    };\n    return moduleFunc\n  }\n\n  var supportsWorkers = function () {\n    var supported = false;\n\n    // Only attempt worker initialization in browsers; elsewhere it would just be\n    // noise e.g. loading into a Node environment for SSR.\n    if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n      try {\n        // TODO additional checks for things like importScripts within the worker?\n        //  Would need to be an async check.\n        var worker = new Worker(\n          URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))\n        );\n        worker.terminate();\n        supported = true;\n      } catch (err) {\n        if (typeof process !== 'undefined' && \"development\" === 'test') {} else {\n          console.log(\n            (\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\")\n          );\n        }\n      }\n    }\n\n    // Cached result\n    supportsWorkers = function () { return supported; };\n    return supported\n  };\n\n  var _workerModuleId = 0;\n  var _messageId = 0;\n  var _allowInitAsString = false;\n  var workers = Object.create(null);\n  var registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\n  var openRequests = Object.create(null);\n\n\n  /**\n   * Define a module of code that will be executed with a web worker. This provides a simple\n   * interface for moving chunks of logic off the main thread, and managing their dependencies\n   * among one another.\n   *\n   * @param {object} options\n   * @param {function} options.init\n   * @param {array} [options.dependencies]\n   * @param {function} [options.getTransferables]\n   * @param {string} [options.name]\n   * @param {string} [options.workerId]\n   * @return {function(...[*]): {then}}\n   */\n  function defineWorkerModule(options) {\n    if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n      throw new Error('requires `options.init` function')\n    }\n    var dependencies = options.dependencies;\n    var init = options.init;\n    var getTransferables = options.getTransferables;\n    var workerId = options.workerId;\n\n    if (!supportsWorkers()) {\n      return defineMainThreadModule(options)\n    }\n\n    if (workerId == null) {\n      workerId = '#default';\n    }\n    var id = \"workerModule\" + (++_workerModuleId);\n    var name = options.name || id;\n    var registrationPromise = null;\n\n    dependencies = dependencies && dependencies.map(function (dep) {\n      // Wrap raw functions as worker modules with no dependencies\n      if (typeof dep === 'function' && !dep.workerModuleData) {\n        _allowInitAsString = true;\n        dep = defineWorkerModule({\n          workerId: workerId,\n          name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n          init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n        });\n        _allowInitAsString = false;\n      }\n      // Grab postable data for worker modules\n      if (dep && dep.workerModuleData) {\n        dep = dep.workerModuleData;\n      }\n      return dep\n    });\n\n    function moduleFunc() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Register this module if needed\n      if (!registrationPromise) {\n        registrationPromise = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n        var unregister = function () {\n          registrationPromise = null;\n          registeredModules[workerId].delete(unregister);\n        }\n        ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n      }\n\n      // Invoke the module, returning a promise\n      return registrationPromise.then(function (ref) {\n        var isCallable = ref.isCallable;\n\n        if (isCallable) {\n          return callWorker(workerId,'callModule', {id: id, args: args})\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function')\n        }\n      })\n    }\n    moduleFunc.workerModuleData = {\n      isWorkerModule: true,\n      id: id,\n      name: name,\n      dependencies: dependencies,\n      init: stringifyFunction(init),\n      getTransferables: getTransferables && stringifyFunction(getTransferables)\n    };\n    return moduleFunc\n  }\n\n  /**\n   * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\n   * This only terminates the Worker itself; the worker module will remain available\n   * and if you call it again its Worker will be respawned.\n   * @param {string} workerId\n   */\n  function terminateWorker(workerId) {\n    // Unregister all modules that were registered in that worker\n    if (registeredModules[workerId]) {\n      registeredModules[workerId].forEach(function (unregister) {\n        unregister();\n      });\n    }\n    // Terminate the Worker object\n    if (workers[workerId]) {\n      workers[workerId].terminate();\n      delete workers[workerId];\n    }\n  }\n\n  /**\n   * Stringifies a function into a form that can be deserialized in the worker\n   * @param fn\n   */\n  function stringifyFunction(fn) {\n    var str = fn.toString();\n    // If it was defined in object method/property format, it needs to be modified\n    if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n      str = 'function ' + str;\n    }\n    return str\n  }\n\n\n  function getWorker(workerId) {\n    var worker = workers[workerId];\n    if (!worker) {\n      // Bootstrap the worker's content\n      var bootstrap = stringifyFunction(workerBootstrap);\n\n      // Create the worker from the bootstrap function content\n      worker = workers[workerId] = new Worker(\n        URL.createObjectURL(\n          new Blob(\n            [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n            {type: 'application/javascript'}\n          )\n        )\n      );\n\n      // Single handler for response messages from the worker\n      worker.onmessage = function (e) {\n        var response = e.data;\n        var msgId = response.messageId;\n        var callback = openRequests[msgId];\n        if (!callback) {\n          throw new Error('WorkerModule response with empty or unknown messageId')\n        }\n        delete openRequests[msgId];\n        callback(response);\n      };\n    }\n    return worker\n  }\n\n  // Issue a call to the worker with a callback to handle the response\n  function callWorker(workerId, action, data) {\n    return new Promise(function (resolve, reject) {\n      var messageId = ++_messageId;\n      openRequests[messageId] = function (response) {\n        if (response.success) {\n          resolve(response.result);\n        } else {\n          reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n        }\n      };\n      getWorker(workerId).postMessage({\n        messageId: messageId,\n        action: action,\n        data: data\n      });\n    })\n  }\n\n  exports.defineWorkerModule = defineWorkerModule;\n  exports.stringifyFunction = stringifyFunction;\n  exports.terminateWorker = terminateWorker;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXdvcmtlci11dGlscy9kaXN0L3Ryb2lrYS13b3JrZXItdXRpbHMudW1kLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ29IO0FBQ3RILENBQUMsNkJBQTZCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsMkJBQTJCO0FBQzNCLG1EQUFtRDs7QUFFbkQ7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxvRUFBb0U7QUFDekgsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRkFBcUY7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdDQUFnQztBQUMvRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsOENBQThDLGFBQW9CLGFBQWEsRUFBQyxDQUFDO0FBQ2pGO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBOEM7QUFDM0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELG1CQUFtQjtBQUN2RSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy90cm9pa2Etd29ya2VyLXV0aWxzL2Rpc3QvdHJvaWthLXdvcmtlci11dGlscy51bWQuanM/MjAyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnRyb2lrYV93b3JrZXJfdXRpbHMgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBNYWluIGNvbnRlbnQgZm9yIHRoZSB3b3JrZXIgdGhhdCBoYW5kbGVzIHRoZSBsb2FkaW5nIGFuZCBleGVjdXRpb24gb2ZcbiAgICogbW9kdWxlcyB3aXRoaW4gaXQuXG4gICAqL1xuICBmdW5jdGlvbiB3b3JrZXJCb290c3RyYXAoKSB7XG4gICAgdmFyIG1vZHVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gSGFuZGxlIG1lc3NhZ2VzIGZvciByZWdpc3RlcmluZyBhIG1vZHVsZVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlKHJlZiwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBpZCA9IHJlZi5pZDtcbiAgICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG4gICAgICB2YXIgZGVwZW5kZW5jaWVzID0gcmVmLmRlcGVuZGVuY2llczsgaWYgKCBkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCApIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgdmFyIGluaXQgPSByZWYuaW5pdDsgaWYgKCBpbml0ID09PSB2b2lkIDAgKSBpbml0ID0gZnVuY3Rpb24oKXt9O1xuICAgICAgdmFyIGdldFRyYW5zZmVyYWJsZXMgPSByZWYuZ2V0VHJhbnNmZXJhYmxlczsgaWYgKCBnZXRUcmFuc2ZlcmFibGVzID09PSB2b2lkIDAgKSBnZXRUcmFuc2ZlcmFibGVzID0gbnVsbDtcblxuICAgICAgLy8gT25seSByZWdpc3RlciBvbmNlXG4gICAgICBpZiAobW9kdWxlc1tpZF0pIHsgcmV0dXJuIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgYW55IGRlcGVuZGVuY2llcyBhcmUgbW9kdWxlcywgZW5zdXJlIHRoZXkncmUgcmVnaXN0ZXJlZCBhbmQgZ3JhYiB0aGVpciB2YWx1ZVxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICBpZiAoZGVwICYmIGRlcC5pc1dvcmtlck1vZHVsZSkge1xuICAgICAgICAgICAgcmVnaXN0ZXJNb2R1bGUoZGVwLCBmdW5jdGlvbiAoZGVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChkZXBSZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikgeyB0aHJvdyBkZXBSZXN1bHQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZXAgPSBtb2R1bGVzW2RlcC5pZF0udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVoeWRyYXRlIGZ1bmN0aW9uc1xuICAgICAgICBpbml0ID0gcmVoeWRyYXRlKChcIjxcIiArIG5hbWUgKyBcIj4uaW5pdFwiKSwgaW5pdCk7XG4gICAgICAgIGlmIChnZXRUcmFuc2ZlcmFibGVzKSB7XG4gICAgICAgICAgZ2V0VHJhbnNmZXJhYmxlcyA9IHJlaHlkcmF0ZSgoXCI8XCIgKyBuYW1lICsgXCI+LmdldFRyYW5zZmVyYWJsZXNcIiksIGdldFRyYW5zZmVyYWJsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbW9kdWxlIGFuZCBzdG9yZSBpdHMgdmFsdWVcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsdWUgPSBpbml0LmFwcGx5KHZvaWQgMCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCd3b3JrZXIgbW9kdWxlIGluaXQgZnVuY3Rpb24gZmFpbGVkIHRvIHJlaHlkcmF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIG1vZHVsZXNbaWRdID0ge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZ2V0VHJhbnNmZXJhYmxlczogZ2V0VHJhbnNmZXJhYmxlc1xuICAgICAgICB9O1xuICAgICAgICBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBpZiAoIShlcnIgJiYgZXJyLm5vTG9nKSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBtZXNzYWdlcyBmb3IgY2FsbGluZyBhIHJlZ2lzdGVyZWQgbW9kdWxlJ3MgcmVzdWx0IGZ1bmN0aW9uXG4gICAgZnVuY3Rpb24gY2FsbE1vZHVsZShyZWYsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmVmJDE7XG5cbiAgICAgIHZhciBpZCA9IHJlZi5pZDtcbiAgICAgIHZhciBhcmdzID0gcmVmLmFyZ3M7XG4gICAgICBpZiAoIW1vZHVsZXNbaWRdIHx8IHR5cGVvZiBtb2R1bGVzW2lkXS52YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoKFwiV29ya2VyIG1vZHVsZSBcIiArIGlkICsgXCI6IG5vdCBmb3VuZCBvciBpdHMgJ2luaXQnIGRpZCBub3QgcmV0dXJuIGEgZnVuY3Rpb25cIikpKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAocmVmJDEgPSBtb2R1bGVzW2lkXSkudmFsdWUuYXBwbHkocmVmJDEsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlc3VsdC50aGVuKGhhbmRsZVJlc3VsdCwgZnVuY3Rpb24gKHJlaikgeyByZXR1cm4gY2FsbGJhY2socmVqIGluc3RhbmNlb2YgRXJyb3IgPyByZWogOiBuZXcgRXJyb3IoJycgKyByZWopKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHR4ID0gbW9kdWxlc1tpZF0uZ2V0VHJhbnNmZXJhYmxlcyAmJiBtb2R1bGVzW2lkXS5nZXRUcmFuc2ZlcmFibGVzKHJlc3VsdCk7XG4gICAgICAgICAgaWYgKCF0eCB8fCAhQXJyYXkuaXNBcnJheSh0eCkgfHwgIXR4Lmxlbmd0aCkge1xuICAgICAgICAgICAgdHggPSB1bmRlZmluZWQ7IC8vcG9zdE1lc3NhZ2UgaXMgdmVyeSBwaWNreSBhYm91dCBub3QgcGFzc2luZyBudWxsIG9yIGVtcHR5IHRyYW5zZmVyYWJsZXNcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0LCB0eCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWh5ZHJhdGUobmFtZSwgc3RyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgc2VsZi50cm9pa2FEZWZpbmUgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gcmVzdWx0ID0gcjsgfTtcbiAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgICBuZXcgQmxvYihcbiAgICAgICAgICBbKFwiLyoqIFwiICsgKG5hbWUucmVwbGFjZSgvXFwqL2csICcnKSkgKyBcIiAqKi9cXG5cXG50cm9pa2FEZWZpbmUoXFxuXCIgKyBzdHIgKyBcIlxcbilcIildLFxuICAgICAgICAgIHt0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBpbXBvcnRTY3JpcHRzKHVybCk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICBkZWxldGUgc2VsZi50cm9pa2FEZWZpbmU7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlciBmb3IgYWxsIG1lc3NhZ2VzIHdpdGhpbiB0aGUgd29ya2VyXG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciByZWYgPSBlLmRhdGE7XG4gICAgICB2YXIgbWVzc2FnZUlkID0gcmVmLm1lc3NhZ2VJZDtcbiAgICAgIHZhciBhY3Rpb24gPSByZWYuYWN0aW9uO1xuICAgICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE1vZHVsZSByZWdpc3RyYXRpb25cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JlZ2lzdGVyTW9kdWxlJykge1xuICAgICAgICAgIHJlZ2lzdGVyTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiB7aXNDYWxsYWJsZTogdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJ31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52b2NhdGlvblxuICAgICAgICBpZiAoYWN0aW9uID09PSAnY2FsbE1vZHVsZScpIHtcbiAgICAgICAgICBjYWxsTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQsIHRyYW5zZmVyYWJsZXMpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGVyci5zdGFja1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWxsYmFjayBmb3IgYGRlZmluZVdvcmtlck1vZHVsZWAgdGhhdCBiZWhhdmVzIGlkZW50aWNhbGx5IGJ1dCBydW5zIGluIHRoZSBtYWluXG4gICAqIHRocmVhZCwgZm9yIHdoZW4gdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgd2ViIHdvcmtlcnMgb3IgdGhleVxuICAgKiBhcmUgZGlzYWxsb3dlZCBkdWUgdG8gZS5nLiBDU1Agc2VjdXJpdHkgcmVzdHJpY3Rpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gZGVmaW5lTWFpblRocmVhZE1vZHVsZShvcHRpb25zKSB7XG4gICAgdmFyIG1vZHVsZUZ1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICByZXR1cm4gbW9kdWxlRnVuYy5fZ2V0SW5pdFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24gKGluaXRSZXN1bHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0UmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGluaXRSZXN1bHQuYXBwbHkodm9pZCAwLCBhcmdzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIG1vZHVsZSBmdW5jdGlvbiB3YXMgY2FsbGVkIGJ1dCBgaW5pdGAgZGlkIG5vdCByZXR1cm4gYSBjYWxsYWJsZSBmdW5jdGlvbicpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgICBtb2R1bGVGdW5jLl9nZXRJbml0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBXZSBjYW4gaWdub3JlIGdldFRyYW5zZmVyYWJsZXMgaW4gbWFpbiB0aHJlYWQuIFRPRE8gd29ya2VySWQ/XG4gICAgICB2YXIgZGVwZW5kZW5jaWVzID0gb3B0aW9ucy5kZXBlbmRlbmNpZXM7XG4gICAgICB2YXIgaW5pdCA9IG9wdGlvbnMuaW5pdDtcblxuICAgICAgLy8gUmVzb2x2ZSBkZXBlbmRlbmNpZXNcbiAgICAgIGRlcGVuZGVuY2llcyA9IEFycmF5LmlzQXJyYXkoZGVwZW5kZW5jaWVzKSA/IGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwICYmIGRlcC5fZ2V0SW5pdFJlc3VsdCA/IGRlcC5fZ2V0SW5pdFJlc3VsdCgpIDogZGVwOyB9XG4gICAgICApIDogW107XG5cbiAgICAgIC8vIEludm9rZSBpbml0IHdpdGggdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llc1xuICAgICAgdmFyIGluaXRQcm9taXNlID0gUHJvbWlzZS5hbGwoZGVwZW5kZW5jaWVzKS50aGVuKGZ1bmN0aW9uIChkZXBzKSB7XG4gICAgICAgIHJldHVybiBpbml0LmFwcGx5KG51bGwsIGRlcHMpXG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc29sdmVkIHByb21pc2UgZm9yIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgIG1vZHVsZUZ1bmMuX2dldEluaXRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbml0UHJvbWlzZTsgfTtcblxuICAgICAgcmV0dXJuIGluaXRQcm9taXNlXG4gICAgfTtcbiAgICByZXR1cm4gbW9kdWxlRnVuY1xuICB9XG5cbiAgdmFyIHN1cHBvcnRzV29ya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICAvLyBPbmx5IGF0dGVtcHQgd29ya2VyIGluaXRpYWxpemF0aW9uIGluIGJyb3dzZXJzOyBlbHNld2hlcmUgaXQgd291bGQganVzdCBiZVxuICAgIC8vIG5vaXNlIGUuZy4gbG9hZGluZyBpbnRvIGEgTm9kZSBlbnZpcm9ubWVudCBmb3IgU1NSLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVE9ETyBhZGRpdGlvbmFsIGNoZWNrcyBmb3IgdGhpbmdzIGxpa2UgaW1wb3J0U2NyaXB0cyB3aXRoaW4gdGhlIHdvcmtlcj9cbiAgICAgICAgLy8gIFdvdWxkIG5lZWQgdG8gYmUgYW4gYXN5bmMgY2hlY2suXG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKFxuICAgICAgICAgIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoWycnXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpXG4gICAgICAgICk7XG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIDsgZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAoXCJUcm9pa2EgY3JlYXRlV29ya2VyTW9kdWxlOiB3ZWIgd29ya2VycyBub3QgYWxsb3dlZDsgZmFsbGluZyBiYWNrIHRvIG1haW4gdGhyZWFkIGV4ZWN1dGlvbi4gQ2F1c2U6IFtcIiArIChlcnIubWVzc2FnZSkgKyBcIl1cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FjaGVkIHJlc3VsdFxuICAgIHN1cHBvcnRzV29ya2VycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1cHBvcnRlZDsgfTtcbiAgICByZXR1cm4gc3VwcG9ydGVkXG4gIH07XG5cbiAgdmFyIF93b3JrZXJNb2R1bGVJZCA9IDA7XG4gIHZhciBfbWVzc2FnZUlkID0gMDtcbiAgdmFyIF9hbGxvd0luaXRBc1N0cmluZyA9IGZhbHNlO1xuICB2YXIgd29ya2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciByZWdpc3RlcmVkTW9kdWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vd29ya2VySWQgLT4gU2V0PHVucmVnaXN0ZXJGbj5cbiAgdmFyIG9wZW5SZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblxuICAvKipcbiAgICogRGVmaW5lIGEgbW9kdWxlIG9mIGNvZGUgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdpdGggYSB3ZWIgd29ya2VyLiBUaGlzIHByb3ZpZGVzIGEgc2ltcGxlXG4gICAqIGludGVyZmFjZSBmb3IgbW92aW5nIGNodW5rcyBvZiBsb2dpYyBvZmYgdGhlIG1haW4gdGhyZWFkLCBhbmQgbWFuYWdpbmcgdGhlaXIgZGVwZW5kZW5jaWVzXG4gICAqIGFtb25nIG9uZSBhbm90aGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmluaXRcbiAgICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZGVwZW5kZW5jaWVzXVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5nZXRUcmFuc2ZlcmFibGVzXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLndvcmtlcklkXVxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5bKl0pOiB7dGhlbn19XG4gICAqL1xuICBmdW5jdGlvbiBkZWZpbmVXb3JrZXJNb2R1bGUob3B0aW9ucykge1xuICAgIGlmICgoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMuaW5pdCAhPT0gJ2Z1bmN0aW9uJykgJiYgIV9hbGxvd0luaXRBc1N0cmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBgb3B0aW9ucy5pbml0YCBmdW5jdGlvbicpXG4gICAgfVxuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBvcHRpb25zLmRlcGVuZGVuY2llcztcbiAgICB2YXIgaW5pdCA9IG9wdGlvbnMuaW5pdDtcbiAgICB2YXIgZ2V0VHJhbnNmZXJhYmxlcyA9IG9wdGlvbnMuZ2V0VHJhbnNmZXJhYmxlcztcbiAgICB2YXIgd29ya2VySWQgPSBvcHRpb25zLndvcmtlcklkO1xuXG4gICAgaWYgKCFzdXBwb3J0c1dvcmtlcnMoKSkge1xuICAgICAgcmV0dXJuIGRlZmluZU1haW5UaHJlYWRNb2R1bGUob3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAod29ya2VySWQgPT0gbnVsbCkge1xuICAgICAgd29ya2VySWQgPSAnI2RlZmF1bHQnO1xuICAgIH1cbiAgICB2YXIgaWQgPSBcIndvcmtlck1vZHVsZVwiICsgKCsrX3dvcmtlck1vZHVsZUlkKTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBpZDtcbiAgICB2YXIgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IG51bGw7XG5cbiAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMgJiYgZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAvLyBXcmFwIHJhdyBmdW5jdGlvbnMgYXMgd29ya2VyIG1vZHVsZXMgd2l0aCBubyBkZXBlbmRlbmNpZXNcbiAgICAgIGlmICh0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nICYmICFkZXAud29ya2VyTW9kdWxlRGF0YSkge1xuICAgICAgICBfYWxsb3dJbml0QXNTdHJpbmcgPSB0cnVlO1xuICAgICAgICBkZXAgPSBkZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgICAgICAgIHdvcmtlcklkOiB3b3JrZXJJZCxcbiAgICAgICAgICBuYW1lOiAoXCI8XCIgKyBuYW1lICsgXCI+IGZ1bmN0aW9uIGRlcGVuZGVuY3k6IFwiICsgKGRlcC5uYW1lKSksXG4gICAgICAgICAgaW5pdDogKFwiZnVuY3Rpb24oKXtyZXR1cm4gKFxcblwiICsgKHN0cmluZ2lmeUZ1bmN0aW9uKGRlcCkpICsgXCJcXG4pfVwiKVxuICAgICAgICB9KTtcbiAgICAgICAgX2FsbG93SW5pdEFzU3RyaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBHcmFiIHBvc3RhYmxlIGRhdGEgZm9yIHdvcmtlciBtb2R1bGVzXG4gICAgICBpZiAoZGVwICYmIGRlcC53b3JrZXJNb2R1bGVEYXRhKSB7XG4gICAgICAgIGRlcCA9IGRlcC53b3JrZXJNb2R1bGVEYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlcFxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbW9kdWxlRnVuYygpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAvLyBSZWdpc3RlciB0aGlzIG1vZHVsZSBpZiBuZWVkZWRcbiAgICAgIGlmICghcmVnaXN0cmF0aW9uUHJvbWlzZSkge1xuICAgICAgICByZWdpc3RyYXRpb25Qcm9taXNlID0gY2FsbFdvcmtlcih3b3JrZXJJZCwncmVnaXN0ZXJNb2R1bGUnLCBtb2R1bGVGdW5jLndvcmtlck1vZHVsZURhdGEpO1xuICAgICAgICB2YXIgdW5yZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWdpc3RyYXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICByZWdpc3RlcmVkTW9kdWxlc1t3b3JrZXJJZF0uZGVsZXRlKHVucmVnaXN0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIDsocmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdIHx8IChyZWdpc3RlcmVkTW9kdWxlc1t3b3JrZXJJZF0gPSBuZXcgU2V0KCkpKS5hZGQodW5yZWdpc3Rlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEludm9rZSB0aGUgbW9kdWxlLCByZXR1cm5pbmcgYSBwcm9taXNlXG4gICAgICByZXR1cm4gcmVnaXN0cmF0aW9uUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZWYuaXNDYWxsYWJsZTtcblxuICAgICAgICBpZiAoaXNDYWxsYWJsZSkge1xuICAgICAgICAgIHJldHVybiBjYWxsV29ya2VyKHdvcmtlcklkLCdjYWxsTW9kdWxlJywge2lkOiBpZCwgYXJnczogYXJnc30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgbW9kdWxlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYnV0IGBpbml0YCBkaWQgbm90IHJldHVybiBhIGNhbGxhYmxlIGZ1bmN0aW9uJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgbW9kdWxlRnVuYy53b3JrZXJNb2R1bGVEYXRhID0ge1xuICAgICAgaXNXb3JrZXJNb2R1bGU6IHRydWUsXG4gICAgICBpZDogaWQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMsXG4gICAgICBpbml0OiBzdHJpbmdpZnlGdW5jdGlvbihpbml0KSxcbiAgICAgIGdldFRyYW5zZmVyYWJsZXM6IGdldFRyYW5zZmVyYWJsZXMgJiYgc3RyaW5naWZ5RnVuY3Rpb24oZ2V0VHJhbnNmZXJhYmxlcylcbiAgICB9O1xuICAgIHJldHVybiBtb2R1bGVGdW5jXG4gIH1cblxuICAvKipcbiAgICogVGVybWluYXRlIGFuIGFjdGl2ZSBXb3JrZXIgYnkgYSB3b3JrZXJJZCB0aGF0IHdhcyBwYXNzZWQgdG8gZGVmaW5lV29ya2VyTW9kdWxlLlxuICAgKiBUaGlzIG9ubHkgdGVybWluYXRlcyB0aGUgV29ya2VyIGl0c2VsZjsgdGhlIHdvcmtlciBtb2R1bGUgd2lsbCByZW1haW4gYXZhaWxhYmxlXG4gICAqIGFuZCBpZiB5b3UgY2FsbCBpdCBhZ2FpbiBpdHMgV29ya2VyIHdpbGwgYmUgcmVzcGF3bmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd29ya2VySWRcbiAgICovXG4gIGZ1bmN0aW9uIHRlcm1pbmF0ZVdvcmtlcih3b3JrZXJJZCkge1xuICAgIC8vIFVucmVnaXN0ZXIgYWxsIG1vZHVsZXMgdGhhdCB3ZXJlIHJlZ2lzdGVyZWQgaW4gdGhhdCB3b3JrZXJcbiAgICBpZiAocmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdKSB7XG4gICAgICByZWdpc3RlcmVkTW9kdWxlc1t3b3JrZXJJZF0uZm9yRWFjaChmdW5jdGlvbiAodW5yZWdpc3Rlcikge1xuICAgICAgICB1bnJlZ2lzdGVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gVGVybWluYXRlIHRoZSBXb3JrZXIgb2JqZWN0XG4gICAgaWYgKHdvcmtlcnNbd29ya2VySWRdKSB7XG4gICAgICB3b3JrZXJzW3dvcmtlcklkXS50ZXJtaW5hdGUoKTtcbiAgICAgIGRlbGV0ZSB3b3JrZXJzW3dvcmtlcklkXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RyaW5naWZpZXMgYSBmdW5jdGlvbiBpbnRvIGEgZm9ybSB0aGF0IGNhbiBiZSBkZXNlcmlhbGl6ZWQgaW4gdGhlIHdvcmtlclxuICAgKiBAcGFyYW0gZm5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgLy8gSWYgaXQgd2FzIGRlZmluZWQgaW4gb2JqZWN0IG1ldGhvZC9wcm9wZXJ0eSBmb3JtYXQsIGl0IG5lZWRzIHRvIGJlIG1vZGlmaWVkXG4gICAgaWYgKCEvXmZ1bmN0aW9uLy50ZXN0KHN0cikgJiYgL15cXHcrXFxzKlxcKC8udGVzdChzdHIpKSB7XG4gICAgICBzdHIgPSAnZnVuY3Rpb24gJyArIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICB9XG5cblxuICBmdW5jdGlvbiBnZXRXb3JrZXIod29ya2VySWQpIHtcbiAgICB2YXIgd29ya2VyID0gd29ya2Vyc1t3b3JrZXJJZF07XG4gICAgaWYgKCF3b3JrZXIpIHtcbiAgICAgIC8vIEJvb3RzdHJhcCB0aGUgd29ya2VyJ3MgY29udGVudFxuICAgICAgdmFyIGJvb3RzdHJhcCA9IHN0cmluZ2lmeUZ1bmN0aW9uKHdvcmtlckJvb3RzdHJhcCk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgd29ya2VyIGZyb20gdGhlIGJvb3RzdHJhcCBmdW5jdGlvbiBjb250ZW50XG4gICAgICB3b3JrZXIgPSB3b3JrZXJzW3dvcmtlcklkXSA9IG5ldyBXb3JrZXIoXG4gICAgICAgIFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgICAgbmV3IEJsb2IoXG4gICAgICAgICAgICBbKFwiLyoqIFdvcmtlciBNb2R1bGUgQm9vdHN0cmFwOiBcIiArICh3b3JrZXJJZC5yZXBsYWNlKC9cXCovZywgJycpKSArIFwiICoqL1xcblxcbjsoXCIgKyBib290c3RyYXAgKyBcIikoKVwiKV0sXG4gICAgICAgICAgICB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgLy8gU2luZ2xlIGhhbmRsZXIgZm9yIHJlc3BvbnNlIG1lc3NhZ2VzIGZyb20gdGhlIHdvcmtlclxuICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IGUuZGF0YTtcbiAgICAgICAgdmFyIG1zZ0lkID0gcmVzcG9uc2UubWVzc2FnZUlkO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBvcGVuUmVxdWVzdHNbbXNnSWRdO1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXJNb2R1bGUgcmVzcG9uc2Ugd2l0aCBlbXB0eSBvciB1bmtub3duIG1lc3NhZ2VJZCcpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIG9wZW5SZXF1ZXN0c1ttc2dJZF07XG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJcbiAgfVxuXG4gIC8vIElzc3VlIGEgY2FsbCB0byB0aGUgd29ya2VyIHdpdGggYSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIHJlc3BvbnNlXG4gIGZ1bmN0aW9uIGNhbGxXb3JrZXIod29ya2VySWQsIGFjdGlvbiwgZGF0YSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbWVzc2FnZUlkID0gKytfbWVzc2FnZUlkO1xuICAgICAgb3BlblJlcXVlc3RzW21lc3NhZ2VJZF0gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigoXCJFcnJvciBpbiB3b3JrZXIgXCIgKyBhY3Rpb24gKyBcIiBjYWxsOiBcIiArIChyZXNwb25zZS5lcnJvcikpKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBnZXRXb3JrZXIod29ya2VySWQpLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9KVxuICB9XG5cbiAgZXhwb3J0cy5kZWZpbmVXb3JrZXJNb2R1bGUgPSBkZWZpbmVXb3JrZXJNb2R1bGU7XG4gIGV4cG9ydHMuc3RyaW5naWZ5RnVuY3Rpb24gPSBzdHJpbmdpZnlGdW5jdGlvbjtcbiAgZXhwb3J0cy50ZXJtaW5hdGVXb3JrZXIgPSB0ZXJtaW5hdGVXb3JrZXI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js\n");

/***/ })

};
;