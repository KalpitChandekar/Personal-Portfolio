/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-text";
exports.ids = ["vendor-chunks/troika-three-text"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.umd.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\"), __webpack_require__(/*! troika-worker-utils */ \"(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js\"), __webpack_require__(/*! webgl-sdf-generator */ \"(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.js\"), __webpack_require__(/*! bidi-js */ \"(ssr)/./node_modules/bidi-js/dist/bidi.js\"), __webpack_require__(/*! troika-three-utils */ \"(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js\")) :\n  0;\n}(this, (function (exports, three, troikaWorkerUtils, createSDFGenerator, bidiFactory, troikaThreeUtils) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var createSDFGenerator__default = /*#__PURE__*/_interopDefaultLegacy(createSDFGenerator);\n  var bidiFactory__default = /*#__PURE__*/_interopDefaultLegacy(bidiFactory);\n\n  /*!\n  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\n  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n  */\n  function typrFactory(){return \"undefined\"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if(\"ttcf\"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=[\"cmap\",\"head\",\"hhea\",\"maxp\",\"hmtx\",\"name\",\"OS/2\",\"post\",\"loca\",\"glyf\",\"kern\",\"CFF \",\"GDEF\",\"GPOS\",\"GSUB\",\"SVG \"],i={_data:r,_offset:n},h={},d=0;d<o;d++){var f=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[f]={offset:u,length:l};}for(d=0;d<s.length;d++){var v=s[d];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var d=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return d}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a=\"\",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a=\"\",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:\"undefined\"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var d=s.readUshort(r,t);t+=2;var f=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+d),i.featureList=e._lctf.readFeatureList(r,h+f),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=n.readUshort(r,t);t+=2;var f=e._lctf.readLookupTable(r,o+d,a);s.push(f);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,d=0;d<i;d++){var f=n.readUshort(r,t);t+=2;var u=a(r,h,o+f,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var d=a.readUshort(r,t);t+=2;for(h=0;h<d;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2;var f=e._lctf.readFeatureTable(r,n+d);f.tag=h.trim(),o.push(f);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+d);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.default=e._lctf.readLangSysTable(r,n+s));var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[d.trim()]=e._lctf.readLangSysTable(r,n+f);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var d=[];for(i=0;i<h.length-1;i++)d.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var f=d[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,f),f.CharStrings){t=f.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));f.CharStrings=v;}if(f.ROS){t=f.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),f.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),f.FDArray.push(p);}t+=c[c.length-1],t=f.FDSelect,f.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)f.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return f.Encoding&&(f.Encoding=e.CFF.readEncoding(r,f.Encoding,f.CharStrings.length)),f.charset&&(f.charset=e.CFF.readCharset(r,f.charset,f.CharStrings.length)),e.CFF._readFDict(r,f,l),f},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=[\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[\".notdef\"],o=r[t];if(t++,0!=o)throw \"error: unknown encoding format: \"+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[\".notdef\"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw \"error: format: \"+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var d=0;1==s?(d=r[t],t++):(d=n.readUshort(r,t),t+=2);for(i=0;i<=d;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw \"unsupported offset size: \"+s+\", count: \"+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,d=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(d=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(d=o-139,i=1),247<=o&&o<=250&&(d=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(d=256*-(o-251)-s-108,i=2),255==o&&(d=n.readInt(r,t+1)/65535,i=5),a.val=null!=d?d:\"o\"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;i<=20&&(f=i,d=1),12==i&&(f=100*i+h,d=2),19!=i&&20!=i||(f=i,d=2),21<=i&&i<=27&&(f=i,d=1),28==i&&(u=o.readShort(r,t+1),d=3),29<=i&&i<=31&&(f=i,d=1),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i&&(u=o.readInt(r,t+1)/65535,d=5),s.push(null!=u?u:\"o\"+f),t+=d;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;if(28==i&&(u=n.readShort(r,t+1),d=3),29==i&&(u=n.readInt(r,t+1),d=5),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i)throw u=n.readInt(r,t+1)/65535,d=5,\"unknown number\";if(30==i){var l=[];for(d=1;;){var v=r[t+d];d++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U=\"\",g=[0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(f=[\"version\",\"Notice\",\"FullName\",\"FamilyName\",\"Weight\",\"FontBBox\",\"BlueValues\",\"OtherBlues\",\"FamilyBlues\",\"FamilyOtherBlues\",\"StdHW\",\"StdVW\",\"escape\",\"UniqueID\",\"XUID\",\"charset\",\"Encoding\",\"CharStrings\",\"Private\",\"Subrs\",\"defaultWidthX\",\"nominalWidthX\"][i],d=1,12==i)f=[\"Copyright\",\"isFixedPitch\",\"ItalicAngle\",\"UnderlinePosition\",\"UnderlineThickness\",\"PaintType\",\"CharstringType\",\"FontMatrix\",\"StrokeWidth\",\"BlueScale\",\"BlueShift\",\"BlueFuzz\",\"StemSnapH\",\"StemSnapV\",\"ForceBold\",0,0,\"LanguageGroup\",\"ExpansionFactor\",\"initialRandomSeed\",\"SyntheticBase\",\"PostScript\",\"BaseFontName\",\"BaseFontBlend\",0,0,0,0,0,0,\"ROS\",\"CIDFontVersion\",\"CIDFontRevision\",\"CIDFontType\",\"CIDCount\",\"UIDBase\",\"FDArray\",\"FDSelect\",\"FontName\"][h],d=2;null!=f?(o[f]=1==s.length?s[0]:s,s=[]):s.push(u),t+=d;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var d=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l=\"p\"+d+\"e\"+f,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug(\"unknown format: \"+p,d,f,u),o.tables.push(c);}if(null!=o[l])throw \"multiple tables for one platform+encoding\";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var d=0;d<h;d++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),d=a.readUint(r,i+4),f=a.readUint(r,i+8);n.groups.push([h,d,f]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,\"glyf\",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var d=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<d;i++){var f=n[o];if(o++,s.flags.push(f),0!=(8&f)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(f),i++;}}s.xs=[];for(i=0;i<d;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<d;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<d;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GDEF={},e.GDEF.parse=function(r,t,a,n){var o=t;t+=4;var s=e._bin.readUshort(r,t);return {glyphClassDef:0===s?null:e._lctf.readClassDef(r,o+s)}},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var d=o.readUshort(r,a);a+=2,0!=d&&(i.pos=e.GPOS.readValueRecord(r,a,d));}else if(2==t&&i.fmt>=1&&i.fmt<=2){d=o.readUshort(r,a);a+=2;var f=o.readUshort(r,a);a+=2;var u=e._lctf.numOfOnes(d),l=e._lctf.numOfOnes(f);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=d&&(P=e.GPOS.readValueRecord(r,p,d),p+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*l),g.push({gid2:m,val1:P,val2:x});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var C=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var _=[];for(S=0;S<C;S++){var P=null,x=null;0!=d&&(P=e.GPOS.readValueRecord(r,a,d),a+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*l),_.push({val1:P,val2:x});}i.matrix.push(_);}}}else if(4==t&&1==i.fmt)i.markCoverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.baseCoverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.markArray=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.baseArray=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else if(6==t&&1==i.fmt)i.mark1Coverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.mark2Coverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.mark1Array=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.mark2Array=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw \"invalid extension substitution\";return e.GPOS.subt(r,n.ltype,s+w)}console.debug(\"unsupported GPOS table LookupType\",t,\"format\",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GPOS.readBaseArray=function(r,t,a){var n=e._bin,o=[],s=t,i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){for(var d=[],f=0;f<a;f++)d.push(e.GPOS.readAnchorRecord(r,s+n.readUshort(r,t))),t+=2;o.push(d);}return o},e.GPOS.readMarkArray=function(r,t){var a=e._bin,n=[],o=t,s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=e.GPOS.readAnchorRecord(r,a.readUshort(r,t+2)+o);h.markClass=a.readUshort(r,t),n.push(h),t+=4;}return n},e.GPOS.readAnchorRecord=function(r,t){var a=e._bin,n={};return n.fmt=a.readUshort(r,t),n.x=a.readShort(r,t+2),n.y=a.readShort(r,t+4),n},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&2!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||2==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var d=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,d),a+=2*i.newg.length;}}else if(2==t&&1==i.fmt){d=o.readUshort(r,a);a+=2,i.seqs=[];for(var f=0;f<d;f++){var u=o.readUshort(r,a)+s;a+=2;var l=o.readUshort(r,u);i.seqs.push(o.readUshorts(r,u+2,l));}}else if(4==t){i.vals=[];d=o.readUshort(r,a);a+=2;for(f=0;f<d;f++){var v=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+v));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var c=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+c),i.scset=[];var p=o.readUshort(r,a);a+=2;for(f=0;f<p;f++){var U=o.readUshort(r,a);a+=2,i.scset.push(0==U?null:e.GSUB.readSubClassSet(r,s+U));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(f=0;f<3;f++){d=o.readUshort(r,a);a+=2;for(var g=[],S=0;S<d;S++)g.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*S)));a+=2*d,0==f&&(i.backCvg=g),1==f&&(i.inptCvg=g),2==f&&(i.ahedCvg=g);}d=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,d);}}else {if(7==t&&1==i.fmt){var m=o.readUshort(r,a);a+=2;var b=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=m;else if(n.ltype!=m)throw \"invalid extension substitution\";return e.GSUB.subt(r,n.ltype,s+b)}console.debug(\"unsupported GSUB table LookupType\",t,\"format\",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=[\"backtrack\",\"input\",\"lookahead\"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,d=0;d<n.maxp.numGlyphs;d++)d<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},d=0;d<i;d++){t+=2;a=o.readUshort(r,t);t+=2;var f=o.readUshort(r,t);t+=2;var u=f>>>8;if(0!=(u&=15))throw \"unknown kern table format: \"+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var d=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var f=d>>>8;if(0!=(f&=15))throw \"unknown kern table format: \"+f;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var f=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(d),u.vals.push(f),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var d=0;d<h;d++)s.push(o.readUshort(r,t+(d<<1))<<1);if(1==i)for(d=0;d<h;d++)s.push(o.readUint(r,t+(d<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=[\"copyright\",\"fontFamily\",\"fontSubfamily\",\"ID\",\"fullName\",\"version\",\"postScriptName\",\"trademark\",\"manufacturer\",\"designer\",\"description\",\"urlVendor\",\"urlDesigner\",\"licence\",\"licenceURL\",\"---\",\"typoFamilyName\",\"typoSubfamilyName\",\"compatibleFull\",\"sampleText\",\"postScriptCID\",\"wwsFamilyName\",\"wwsSubfamilyName\",\"lightPalette\",\"darkPalette\"],d=t+=2,f=0;f<s;f++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=d+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw \"unknown encoding \"+l+\", platformID: \"+u;g=n.readASCII(r,m,p),console.debug(\"reading unknown MAC encoding \"+l+\" as ASCII\");}var b=\"p\"+u+\",\"+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return console.debug(\"returning name table with languageID \"+o[i]._lang),o[i]},e[\"OS/2\"]={},e[\"OS/2\"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e[\"OS/2\"].version0(r,t,o);else if(1==n)e[\"OS/2\"].version1(r,t,o);else if(2==n||3==n||4==n)e[\"OS/2\"].version2(r,t,o);else {if(5!=n)throw \"unknown OS/2 table version: \"+n;e[\"OS/2\"].version5(r,t,o);}return o},e[\"OS/2\"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e[\"OS/2\"].version1=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e[\"OS/2\"].version2=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e[\"OS/2\"].version5=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw \"no familiar platform and encoding!\";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw \"unknown cmap table format \"+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:(\"string\"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,d=1&r.flags[s],f=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(d){if(!f){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else f?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);d?f&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var d=o.crds[h],f=o.crds[h+1];a.crds.push(d*i.a+f*i.b+i.tx),a.crds.push(d*i.c+f*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var d=h.vals[i],f=0;f<d.length;f++){var u=d[f],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var C=b.substLookupRecords;for(f=0;f<C.length;f+=2)C[f],C[f+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var _=h.lookupRec;for(m=0;m<_.length;m+=2){U=_[m];var P=n[_[m+1]];e.U._applySubs(r,t+U,P,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,d=e.U.glyphToPath(r,i),f=0;f<d.crds.length;f+=2)n.crds.push(d.crds[f]+o),n.crds.push(d.crds[f+1]);a&&n.cmds.push(a);for(f=0;f<d.cmds.length;f++)n.cmds.push(d.cmds[f]);a&&n.cmds.push(\"X\"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push(\"M\"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push(\"L\"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push(\"C\"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push(\"Q\"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push(\"Z\");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,C=0,_={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,_);var P=_.val;if(u+=_.size,\"o1\"==P||\"o18\"==P)s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if(\"o3\"==P||\"o23\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if(\"o4\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),f&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),f=!0;else if(\"o5\"==P)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if(\"o6\"==P||\"o7\"==P)for(var x=s.length,I=\"o6\"==P,w=0;w<x;w++){var k=s.shift();I?l+=k:v+=k,I=!I,e.U.P.lineTo(o,l,v);}else if(\"o8\"==P||\"o24\"==P){x=s.length;for(var G=0;G+6<=x;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),G+=6;\"o24\"==P&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if(\"o11\"==P)break;if(\"o1234\"==P||\"o1235\"==P||\"o1236\"==P||\"o1237\"==P)\"o1234\"==P&&(p=v,U=(c=l+s.shift())+s.shift(),C=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1235\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1236\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),C=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1237\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v));else if(\"o14\"==P){if(s.length>0&&!h&&(d=s.shift()+a.nominalWidthX,h=!0),4==s.length){var O=s.shift(),T=s.shift(),D=s.shift(),B=s.shift(),A=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[A],t,a,n,o),t.x=O,t.y=T,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}f&&(e.U.P.closePath(o),f=!1);}else if(\"o19\"==P||\"o20\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if(\"o21\"==P)s.length>2&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o22\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o25\"==P){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if(\"o26\"==P)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o27\"==P)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o10\"==P||\"o29\"==P){var L=\"o10\"==P?n:a;if(0==s.length)console.debug(\"error: empty stack\");else {var W=s.pop(),M=L.Subrs[W+L.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open;}}else if(\"o30\"==P||\"o31\"==P){var V=s.length,E=(G=0,\"o31\"==P);for(G+=V-(x=-3&V);G<x;)E?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),x-G==5?(l=U+s.shift(),G++):l=U,E=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),x-G==5?(v=g+s.shift(),G++):v=g,E=!0),e.U.P.curveTo(o,c,p,U,g,l,v),G+=4;}else {if(\"o\"==(P+\"\").charAt(0))throw console.debug(\"Unknown operation: \"+P,r),P;s.push(P);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).Typr}\n\n  /*!\n  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n  (https://github.com/101arrowz/fflate) for use in Troika text rendering. \n  Original licenses apply: \n  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n  */\n  function woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).convert_streams}\n\n  /**\n   * A factory wrapper parsing a font file using Typr.\n   * Also adds support for WOFF files (not WOFF2).\n   */\n\n  /**\n   * @typedef ParsedFont\n   * @property {number} ascender\n   * @property {number} descender\n   * @property {number} xHeight\n   * @property {(number) => boolean} supportsCodePoint\n   * @property {(text:string, fontSize:number, letterSpacing:number, callback) => number} forEachGlyph\n   * @property {number} lineGap\n   * @property {number} capHeight\n   * @property {number} unitsPerEm\n   */\n\n  /**\n   * @typedef {(buffer: ArrayBuffer) => ParsedFont} FontParser\n   */\n\n  /**\n   * @returns {FontParser}\n   */\n  function parserFactory(Typr, woff2otf) {\n    const cmdArgLengths = {\n      M: 2,\n      L: 2,\n      Q: 4,\n      C: 6,\n      Z: 0\n    };\n\n    // {joinType: \"skip+step,...\"}\n    const joiningTypeRawData = {\"C\":\"18g,ca,368,1kz\",\"D\":\"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\"R\":\"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\"L\":\"x9u,jff,a,fd,jv\",\"T\":\"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"};\n\n    const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.\n      JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.\n      JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.\n      JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.\n      JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.\n      JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n\n    let joiningTypeMap;\n    function getCharJoiningType(ch) {\n      if (!joiningTypeMap) {\n        const m = {\n          R: JT_RIGHT,\n          L: JT_LEFT,\n          D: JT_DUAL,\n          C: JT_JOIN_CAUSING,\n          U: JT_NON_JOINING,\n          T: JT_TRANSPARENT\n        };\n        joiningTypeMap = new Map();\n        for (let type in joiningTypeRawData) {\n          let lastCode = 0;\n          joiningTypeRawData[type].split(',').forEach(range => {\n            let [skip, step] = range.split('+');\n            skip = parseInt(skip,36);\n            step = step ? parseInt(step, 36) : 0;\n            joiningTypeMap.set(lastCode += skip, m[type]);\n            for (let i = step; i--;) {\n              joiningTypeMap.set(++lastCode, m[type]);\n            }\n          });\n        }\n      }\n      return joiningTypeMap.get(ch) || JT_NON_JOINING\n    }\n\n    const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n    const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];\n\n    function detectJoiningForms(str) {\n      // This implements the algorithm described here:\n      // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n      const joiningForms = new Uint8Array(str.length);\n      let prevJoiningType = JT_NON_JOINING;\n      let prevForm = ISOL;\n      let prevIndex = -1;\n      for (let i = 0; i < str.length; i++) {\n        const code = str.codePointAt(i);\n        let joiningType = getCharJoiningType(code) | 0;\n        let form = ISOL;\n        if (joiningType & JT_TRANSPARENT) {\n          continue\n        }\n        if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n          if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n            form = FINA;\n            // isol->init, fina->medi\n            if (prevForm === ISOL || prevForm === FINA) {\n              joiningForms[prevIndex]++;\n            }\n          }\n          else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n            // medi->fina, init->isol\n            if (prevForm === INIT || prevForm === MEDI) {\n              joiningForms[prevIndex]--;\n            }\n          }\n        }\n        else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n          // medi->fina, init->isol\n          if (prevForm === INIT || prevForm === MEDI) {\n            joiningForms[prevIndex]--;\n          }\n        }\n        prevForm = joiningForms[i] = form;\n        prevJoiningType = joiningType;\n        prevIndex = i;\n        if (code > 0xffff) i++;\n      }\n      // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n      // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n      // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n      return joiningForms\n    }\n\n    function stringToGlyphs (font, str) {\n      const glyphIds = [];\n      for (let i = 0; i < str.length; i++) {\n        const cc = str.codePointAt(i);\n        if (cc > 0xffff) i++;\n        glyphIds.push(Typr.U.codeToGlyph(font, cc));\n      }\n\n      const gsub = font['GSUB'];\n      if (gsub) {\n        const {lookupList, featureList} = gsub;\n        let joiningForms;\n        const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;\n        const usedLookups = [];\n        featureList.forEach(feature => {\n          if (supportedFeatures.test(feature.tag)) {\n            for (let ti = 0; ti < feature.tab.length; ti++) {\n              if (usedLookups[feature.tab[ti]]) continue\n              usedLookups[feature.tab[ti]] = true;\n              const tab = lookupList[feature.tab[ti]];\n              const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n              if (isJoiningFeature && !joiningForms) { //lazy\n                joiningForms = detectJoiningForms(str);\n              }\n              for (let ci = 0; ci < glyphIds.length; ci++) {\n                if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                  Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n                }\n              }\n            }\n          }\n        });\n      }\n\n      return glyphIds\n    }\n\n    // Calculate advances and x/y offsets for each glyph, e.g. kerning and mark\n    // attachments. This is a more complete version of Typr.U.getPairAdjustment\n    // and should become an upstream replacement eventually.\n    function calcGlyphPositions(font, glyphIds) {\n      const positions = new Int16Array(glyphIds.length * 3); // [offsetX, offsetY, advanceX, ...]\n      let glyphIndex = 0;\n      for (; glyphIndex < glyphIds.length; glyphIndex++) {\n        const glyphId = glyphIds[glyphIndex];\n        if (glyphId === -1) continue;\n\n        positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId]; // populate advanceX in...advance.\n\n        const gpos = font.GPOS;\n        if (gpos) {\n          const llist = gpos.lookupList;\n          for (let i = 0; i < llist.length; i++) {\n            const lookup = llist[i];\n            for (let j = 0; j < lookup.tabs.length; j++) {\n              const tab = lookup.tabs[j];\n              // Single char placement\n              if (lookup.ltype === 1) {\n                const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);\n                if (ind !== -1 && tab.pos) {\n                  applyValueRecord(tab.pos, glyphIndex);\n                  break\n                }\n              }\n              // Pairs (kerning)\n              else if (lookup.ltype === 2) {\n                let adj = null;\n                let prevGlyphIndex = getPrevGlyphIndex();\n                if (prevGlyphIndex !== -1) {\n                  const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);\n                  if (coverageIndex !== -1) {\n                    if (tab.fmt === 1) {\n                      const right = tab.pairsets[coverageIndex];\n                      for (let k = 0; k < right.length; k++) {\n                        if (right[k].gid2 === glyphId) adj = right[k];\n                      }\n                    } else if (tab.fmt === 2) {\n                      const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);\n                      const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);\n                      adj = tab.matrix[c1][c2];\n                    }\n                    if (adj) {\n                      if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);\n                      if (adj.val2) applyValueRecord(adj.val2, glyphIndex);\n                      break\n                    }\n                  }\n                }\n              }\n              // Mark to base\n              else if (lookup.ltype === 4) {\n                const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);\n                if (markArrIndex !== -1) {\n                  const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);\n                  const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);\n                  if (baseArrIndex !== -1) {\n                    const markRecord = tab.markArray[markArrIndex];\n                    const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];\n                    positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];\n                    positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];\n                    break;\n                  }\n                }\n              }\n              // Mark to mark\n              else if (lookup.ltype === 6) {\n                const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);\n                if (mark1ArrIndex !== -1) {\n                  const prevGlyphIndex = getPrevGlyphIndex();\n                  if (prevGlyphIndex !== -1) {\n                    const prevGlyphId = glyphIds[prevGlyphIndex];\n                    if (getGlyphClass(font, prevGlyphId) === 3) { // only check mark glyphs\n                      const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);\n                      if (mark2ArrIndex !== -1) {\n                        const mark1Record = tab.mark1Array[mark1ArrIndex];\n                        const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];\n                        positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];\n                        positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        // Check kern table if no GPOS\n        else if (font.kern && !font.cff) {\n          const prevGlyphIndex = getPrevGlyphIndex();\n          if (prevGlyphIndex !== -1) {\n            const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);\n            if (ind1 !== -1) {\n              const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);\n              if (ind2 !== -1) {\n                positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];\n              }\n            }\n          }\n        }\n      }\n\n      return positions;\n\n      function getPrevGlyphIndex(filter) {\n        for (let i = glyphIndex - 1; i >=0; i--) {\n          if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {\n            return i\n          }\n        }\n        return -1;\n      }\n\n      function isBaseGlyph(glyphId) {\n        return getGlyphClass(font, glyphId) === 1;\n      }\n\n      function applyValueRecord(source, gi) {\n        for (let i = 0; i < 3; i++) {\n          positions[gi * 3 + i] += source[i] || 0;\n        }\n      }\n    }\n\n    function getGlyphClass(font, glyphId) {\n      const classDef = font.GDEF && font.GDEF.glyphClassDef;\n      return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;\n    }\n\n    function firstNum(...args) {\n      for (let i = 0; i < args.length; i++) {\n        if (typeof args[i] === 'number') {\n          return args[i]\n        }\n      }\n    }\n\n    /**\n     * @returns ParsedFont\n     */\n    function wrapFontObj(typrFont) {\n      const glyphMap = Object.create(null);\n\n      const os2 = typrFont['OS/2'];\n      const hhea = typrFont.hhea;\n      const unitsPerEm = typrFont.head.unitsPerEm;\n      const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n\n      /** @type ParsedFont */\n      const fontObj = {\n        unitsPerEm,\n        ascender,\n        descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n        capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n        xHeight: firstNum(os2 && os2.sxHeight, ascender),\n        lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n        supportsCodePoint(code) {\n          return Typr.U.codeToGlyph(typrFont, code) > 0\n        },\n        forEachGlyph(text, fontSize, letterSpacing, callback) {\n          let penX = 0;\n          const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n          const glyphIds = stringToGlyphs(typrFont, text);\n          let charIndex = 0;\n          const positions = calcGlyphPositions(typrFont, glyphIds);\n\n          glyphIds.forEach((glyphId, i) => {\n            // Typr returns a glyph index per string codepoint, with -1s in place of those that\n            // were omitted due to ligature substitution. So we can track original index in the\n            // string via simple increment, and skip everything else when seeing a -1.\n            if (glyphId !== -1) {\n              let glyphObj = glyphMap[glyphId];\n              if (!glyphObj) {\n                const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphId);\n\n                // Build path string\n                let path = '';\n                let crdsIdx = 0;\n                for (let i = 0, len = cmds.length; i < len; i++) {\n                  const numArgs = cmdArgLengths[cmds[i]];\n                  path += cmds[i];\n                  for (let j = 1; j <= numArgs; j++) {\n                    path += (j > 1 ? ',' : '') + crds[crdsIdx++];\n                  }\n                }\n\n                // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n                // normalize the two, so it's simplest just to iterate ourselves.\n                let xMin, yMin, xMax, yMax;\n                if (crds.length) {\n                  xMin = yMin = Infinity;\n                  xMax = yMax = -Infinity;\n                  for (let i = 0, len = crds.length; i < len; i += 2) {\n                    let x = crds[i];\n                    let y = crds[i + 1];\n                    if (x < xMin) xMin = x;\n                    if (y < yMin) yMin = y;\n                    if (x > xMax) xMax = x;\n                    if (y > yMax) yMax = y;\n                  }\n                } else {\n                  xMin = xMax = yMin = yMax = 0;\n                }\n\n                glyphObj = glyphMap[glyphId] = {\n                  index: glyphId,\n                  advanceWidth: typrFont.hmtx.aWidth[glyphId],\n                  xMin,\n                  yMin,\n                  xMax,\n                  yMax,\n                  path,\n                };\n              }\n\n              callback.call(\n                null,\n                glyphObj,\n                penX + positions[i * 3] * fontScale,\n                positions[i * 3 + 1] * fontScale,\n                charIndex\n              );\n\n              penX += positions[i * 3 + 2] * fontScale;\n              if (letterSpacing) {\n                penX += letterSpacing * fontSize;\n              }\n            }\n            charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n          });\n\n          return penX\n        }\n      };\n\n      return fontObj\n    }\n\n    /**\n     * @type FontParser\n     */\n    return function parse(buffer) {\n      // Look to see if we have a WOFF file and convert it if so:\n      const peek = new Uint8Array(buffer, 0, 4);\n      const tag = Typr._bin.readASCII(peek, 0, 4);\n      if (tag === 'wOFF') {\n        buffer = woff2otf(buffer);\n      } else if (tag === 'wOF2') {\n        throw new Error('woff2 fonts not supported')\n      }\n      return wrapFontObj(Typr.parse(buffer)[0])\n    }\n  }\n\n\n  const workerModule = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'Typr Font Parser',\n    dependencies: [typrFactory, woff2otfFactory, parserFactory],\n    init(typrFactory, woff2otfFactory, parserFactory) {\n      const Typr = typrFactory();\n      const woff2otf = woff2otfFactory();\n      return parserFactory(Typr, woff2otf)\n    }\n  });\n\n  /*!\n  Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)\n  for use in Troika text rendering. \n  Original MIT license applies\n  */\n  function unicodeFontResolverClientFactory(){return function(t){var n=function(){this.buckets=new Map;};n.prototype.add=function(t){var n=t>>5;this.buckets.set(n,(this.buckets.get(n)||0)|1<<(31&t));},n.prototype.has=function(t){var n=this.buckets.get(t>>5);return void 0!==n&&0!=(n&1<<(31&t))},n.prototype.serialize=function(){var t=[];return this.buckets.forEach((function(n,r){t.push((+r).toString(36)+\":\"+n.toString(36));})),t.join(\",\")},n.prototype.deserialize=function(t){var n=this;this.buckets.clear(),t.split(\",\").forEach((function(t){var r=t.split(\":\");n.buckets.set(parseInt(r[0],36),parseInt(r[1],36));}));};var r=Math.pow(2,8),e=r-1,o=~e;function a(t){var n=function(t){return t&o}(t).toString(16),e=function(t){return (t&o)+r-1}(t).toString(16);return \"codepoint-index/plane\"+(t>>16)+\"/\"+n+\"-\"+e+\".json\"}function i(t,n){var r=t&e,o=n.codePointAt(r/6|0);return 0!=((o=(o||48)-48)&1<<r%6)}function u(t,n){var r;(r=t,r.replace(/U\\+/gi,\"\").replace(/^,+|,+$/g,\"\").split(/,+/).map((function(t){return t.split(\"-\").map((function(t){return parseInt(t.trim(),16)}))}))).forEach((function(t){var r=t[0],e=t[1];void 0===e&&(e=r),n(r,e);}));}function c(t,n){u(t,(function(t,r){for(var e=t;e<=r;e++)n(e);}));}var s={},f={},l=new WeakMap,v=\"https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data\";function d(t){var r=l.get(t);return r||(r=new n,c(t.ranges,(function(t){return r.add(t)})),l.set(t,r)),r}var h,p=new Map;function g(t,n,r){return t[n]?n:t[r]?r:function(t){for(var n in t)return n}(t)}function w(t,n){var r=n;if(!t.includes(r)){r=1/0;for(var e=0;e<t.length;e++)Math.abs(t[e]-n)<Math.abs(r-n)&&(r=t[e]);}return r}function k(t){return h||(h=new Set,c(\"9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000\",(function(t){h.add(t);}))),h.has(t)}return t.CodePointSet=n,t.clearCache=function(){s={},f={};},t.getFontsForString=function(t,n){void 0===n&&(n={});var r,e=n.lang;void 0===e&&(e=/\\p{Script=Hangul}/u.test(r=t)?\"ko\":/\\p{Script=Hiragana}|\\p{Script=Katakana}/u.test(r)?\"ja\":\"en\");var o=n.category;void 0===o&&(o=\"sans-serif\");var u=n.style;void 0===u&&(u=\"normal\");var c=n.weight;void 0===c&&(c=400);var l=(n.dataUrl||v).replace(/\\/$/g,\"\"),h=new Map,y=new Uint8Array(t.length),b={},m={},A=new Array(t.length),S=new Map,j=!1;function M(t){var n=p.get(t);return n||(n=fetch(l+\"/\"+t).then((function(t){if(!t.ok)throw new Error(t.statusText);return t.json().then((function(t){if(!Array.isArray(t)||1!==t[0])throw new Error(\"Incorrect schema version; need 1, got \"+t[0]);return t[1]}))})).catch((function(n){if(l!==v)return j||(console.error('unicode-font-resolver: Failed loading from dataUrl \"'+l+'\", trying default CDN. '+n.message),j=!0),l=v,p.delete(t),M(t);throw n})),p.set(t,n)),n}for(var P=function(n){var r=t.codePointAt(n),e=a(r);A[n]=e,s[e]||S.has(e)||S.set(e,M(e).then((function(t){s[e]=t;}))),r>65535&&(n++,E=n);},E=0;E<t.length;E++)P(E);return Promise.all(S.values()).then((function(){S.clear();for(var n=function(n){var o=t.codePointAt(n),a=null,u=s[A[n]],c=void 0;for(var l in u){var v=m[l];if(void 0===v&&(v=m[l]=new RegExp(l).test(e||\"en\")),v){for(var d in c=l,u[l])if(i(o,u[l][d])){a=d;break}break}}if(!a)t:for(var h in u)if(h!==c)for(var p in u[h])if(i(o,u[h][p])){a=p;break t}a||(console.debug(\"No font coverage for U+\"+o.toString(16)),a=\"latin\"),A[n]=a,f[a]||S.has(a)||S.set(a,M(\"font-meta/\"+a+\".json\").then((function(t){f[a]=t;}))),o>65535&&(n++,r=n);},r=0;r<t.length;r++)n(r);return Promise.all(S.values())})).then((function(){for(var n,r=null,e=0;e<t.length;e++){var a=t.codePointAt(e);if(r&&(k(a)||d(r).has(a)))y[e]=y[e-1];else {r=f[A[e]];var i=b[r.id];if(!i){var s=r.typeforms,v=g(s,o,\"sans-serif\"),p=g(s[v],u,\"normal\"),m=w(null===(n=s[v])||void 0===n?void 0:n[p],c);i=b[r.id]=l+\"/font-files/\"+r.id+\"/\"+v+\".\"+p+\".\"+m+\".woff\";}var S=h.get(i);null==S&&(S=h.size,h.set(i,S)),y[e]=S;}a>65535&&(e++,y[e]=y[e-1]);}return {fontUrls:Array.from(h.keys()),chars:y}}))},Object.defineProperty(t,\"__esModule\",{value:!0}),t}({})}\n\n  /**\n   * @typedef {string | {src:string, label?:string, unicodeRange?:string, lang?:string}} UserFont\n   */\n\n  /**\n   * @typedef {ClientOptions} FontResolverOptions\n   * @property {Array<UserFont>|UserFont} [fonts]\n   * @property {'normal'|'italic'} [style]\n   * @property {'normal'|'bold'|number} [style]\n   * @property {string} [unicodeFontsURL]\n   */\n\n  /**\n   * @typedef {Object} FontResolverResult\n   * @property {Uint8Array} chars\n   * @property {Array<ParsedFont & {src:string}>} fonts\n   */\n\n  /**\n   * @typedef {function} FontResolver\n   * @param {string} text\n   * @param {(FontResolverResult) => void} callback\n   * @param {FontResolverOptions} [options]\n   */\n\n  /**\n   * Factory for the FontResolver function.\n   * @param {FontParser} fontParser\n   * @param {{getFontsForString: function, CodePointSet: function}} unicodeFontResolverClient\n   * @return {FontResolver}\n   */\n  function createFontResolver(fontParser, unicodeFontResolverClient) {\n    /**\n     * @type {Record<string, ParsedFont>}\n     */\n    const parsedFonts = Object.create(null);\n\n    /**\n     * @type {Record<string, Array<(ParsedFont) => void>>}\n     */\n    const loadingFonts = Object.create(null);\n\n    /**\n     * Load a given font url\n     */\n    function doLoadFont(url, callback) {\n      const onError = err => {\n        console.error(`Failure loading font ${url}`, err);\n      };\n      try {\n        const request = new XMLHttpRequest();\n        request.open('get', url, true);\n        request.responseType = 'arraybuffer';\n        request.onload = function () {\n          if (request.status >= 400) {\n            onError(new Error(request.statusText));\n          }\n          else if (request.status > 0) {\n            try {\n              const fontObj = fontParser(request.response);\n              fontObj.src = url;\n              callback(fontObj);\n            } catch (e) {\n              onError(e);\n            }\n          }\n        };\n        request.onerror = onError;\n        request.send();\n      } catch(err) {\n        onError(err);\n      }\n    }\n\n\n    /**\n     * Load a given font url if needed, invoking a callback when it's loaded. If already\n     * loaded, the callback will be called synchronously.\n     * @param {string} fontUrl\n     * @param {(font: ParsedFont) => void} callback\n     */\n    function loadFont(fontUrl, callback) {\n      let font = parsedFonts[fontUrl];\n      if (font) {\n        callback(font);\n      } else if (loadingFonts[fontUrl]) {\n        loadingFonts[fontUrl].push(callback);\n      } else {\n        loadingFonts[fontUrl] = [callback];\n        doLoadFont(fontUrl, fontObj => {\n          fontObj.src = fontUrl;\n          parsedFonts[fontUrl] = fontObj;\n          loadingFonts[fontUrl].forEach(cb => cb(fontObj));\n          delete loadingFonts[fontUrl];\n        });\n      }\n    }\n\n    /**\n     * For a given string of text, determine which fonts are required to fully render it and\n     * ensure those fonts are loaded.\n     */\n    return function (text, callback, {\n      lang,\n      fonts: userFonts = [],\n      style = 'normal',\n      weight = 'normal',\n      unicodeFontsURL\n    } = {}) {\n      const charResolutions = new Uint8Array(text.length);\n      const fontResolutions = [];\n      if (!text.length) {\n        allDone();\n      }\n\n      const fontIndices = new Map();\n      const fallbackRanges = []; // [[start, end], ...]\n\n      if (style !== 'italic') style = 'normal';\n      if (typeof weight !== 'number') {\n        weight = weight === 'bold' ? 700 : 400;\n      }\n\n      if (userFonts && !Array.isArray(userFonts)) {\n        userFonts = [userFonts];\n      }\n      userFonts = userFonts.slice()\n        // filter by language\n        .filter(def => !def.lang || def.lang.test(lang))\n        // switch order for easier iteration\n        .reverse();\n      if (userFonts.length) {\n        const UNKNOWN = 0;\n        const RESOLVED = 1;\n        const NEEDS_FALLBACK = 2;\n        let prevCharResult = UNKNOWN\n\n        ;(function resolveUserFonts (startIndex = 0) {\n          for (let i = startIndex, iLen = text.length; i < iLen; i++) {\n            const codePoint = text.codePointAt(i);\n            // Carry previous character's result forward if:\n            // - it resolved to a font that also covers this character\n            // - this character is whitespace\n            if (\n              (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint)) ||\n              /\\s/.test(text[i])\n            ) {\n              charResolutions[i] = charResolutions[i - 1];\n              if (prevCharResult === NEEDS_FALLBACK) {\n                fallbackRanges[fallbackRanges.length - 1][1] = i;\n              }\n            }  else {\n              for (let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++) {\n                if (j === jLen) {\n                  // none of the user fonts matched; needs fallback\n                  const range = prevCharResult === NEEDS_FALLBACK ?\n                    fallbackRanges[fallbackRanges.length - 1] :\n                    (fallbackRanges[fallbackRanges.length] = [i, i]);\n                  range[1] = i;\n                  prevCharResult = NEEDS_FALLBACK;\n                } else {\n                  charResolutions[i] = j;\n                  const { src, unicodeRange } = userFonts[j];\n                  // filter by optional explicit unicode ranges\n                  if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {\n                    const fontObj = parsedFonts[src];\n                    // font not yet loaded, load it and resume\n                    if (!fontObj) {\n                      loadFont(src, () => {\n                        resolveUserFonts(i);\n                      });\n                      return;\n                    }\n                    // if the font actually contains a glyph for this char, lock it in\n                    if (fontObj.supportsCodePoint(codePoint)) {\n                      let fontIndex = fontIndices.get(fontObj);\n                      if (typeof fontIndex !== 'number') {\n                        fontIndex = fontResolutions.length;\n                        fontResolutions.push(fontObj);\n                        fontIndices.set(fontObj, fontIndex);\n                      }\n                      charResolutions[i] = fontIndex;\n                      prevCharResult = RESOLVED;\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (codePoint > 0xffff && i + 1 < iLen) {\n              charResolutions[i + 1] = charResolutions[i];\n              i++;\n              if (prevCharResult === NEEDS_FALLBACK) {\n                fallbackRanges[fallbackRanges.length - 1][1] = i;\n              }\n            }\n          }\n          resolveFallbacks();\n        })();\n      } else {\n        fallbackRanges.push([0, text.length - 1]);\n        resolveFallbacks();\n      }\n\n      function resolveFallbacks() {\n        if (fallbackRanges.length) {\n          // Combine all fallback substrings into a single string for querying\n          const fallbackString = fallbackRanges.map(range => text.substring(range[0], range[1] + 1)).join('\\n');\n          unicodeFontResolverClient.getFontsForString(fallbackString, {\n            lang: lang || undefined,\n            style,\n            weight,\n            dataUrl: unicodeFontsURL\n          }).then(({fontUrls, chars}) => {\n            // Extract results and put them back in the main array\n            const fontIndexOffset = fontResolutions.length;\n            let charIdx = 0;\n            fallbackRanges.forEach(range => {\n              for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {\n                charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;\n              }\n              charIdx++; //skip segment separator\n            });\n\n            // Load and parse the fallback fonts - avoiding Promise here to prevent polyfills in the worker\n            let loadedCount = 0;\n            fontUrls.forEach((url, i) => {\n              loadFont(url, fontObj => {\n                fontResolutions[i + fontIndexOffset] = fontObj;\n                if (++loadedCount === fontUrls.length) {\n                  allDone();\n                }\n              });\n            });\n          });\n        } else {\n          allDone();\n        }\n      }\n\n      function allDone() {\n        callback({\n          chars: charResolutions,\n          fonts: fontResolutions\n        });\n      }\n\n      function isCodeInRanges(code, ranges) {\n        // todo optimize search - CodePointSet from unicode-font-resolver?\n        for (let k = 0; k < ranges.length; k++) {\n          const [start, end = start] = ranges[k];\n          if (start <= code && code <= end) {\n            return true\n          }\n        }\n        return false\n      }\n    }\n  }\n\n  const fontResolverWorkerModule = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'FontResolver',\n    dependencies: [\n      createFontResolver,\n      workerModule,\n      unicodeFontResolverClientFactory,\n    ],\n    init(createFontResolver, fontParser, unicodeFontResolverClientFactory) {\n      return createFontResolver(fontParser, unicodeFontResolverClientFactory());\n    }\n  });\n\n  /**\n   * @typedef {number|'left'|'center'|'right'} AnchorXValue\n   */\n  /**\n   * @typedef {number|'top'|'top-baseline'|'top-cap'|'top-ex'|'middle'|'bottom-baseline'|'bottom'} AnchorYValue\n   */\n\n  /**\n   * @typedef {object} TypesetParams\n   * @property {string} text\n   * @property {UserFont|UserFont[]} [font]\n   * @property {string} [lang]\n   * @property {number} [sdfGlyphSize=64]\n   * @property {number} [fontSize=1]\n   * @property {number|'normal'|'bold'} [fontWeight='normal']\n   * @property {'normal'|'italic'} [fontStyle='normal']\n   * @property {number} [letterSpacing=0]\n   * @property {'normal'|number} [lineHeight='normal']\n   * @property {number} [maxWidth]\n   * @property {'ltr'|'rtl'} [direction='ltr']\n   * @property {string} [textAlign='left']\n   * @property {number} [textIndent=0]\n   * @property {'normal'|'nowrap'} [whiteSpace='normal']\n   * @property {'normal'|'break-word'} [overflowWrap='normal']\n   * @property {AnchorXValue} [anchorX=0]\n   * @property {AnchorYValue} [anchorY=0]\n   * @property {boolean} [metricsOnly=false]\n   * @property {string} [unicodeFontsURL]\n   * @property {FontResolverResult} [preResolvedFonts]\n   * @property {boolean} [includeCaretPositions=false]\n   * @property {number} [chunkedBoundsSize=8192]\n   * @property {{[rangeStartIndex]: number}} [colorRanges]\n   */\n\n  /**\n   * @typedef {object} TypesetResult\n   * @property {Uint16Array} glyphIds id for each glyph, specific to that glyph's font\n   * @property {Uint8Array} glyphFontIndices index into fontData for each glyph\n   * @property {Float32Array} glyphPositions x,y of each glyph's origin in layout\n   * @property {{[font]: {[glyphId]: {path: string, pathBounds: number[]}}}} glyphData data about each glyph appearing in the text\n   * @property {TypesetFontData[]} fontData data about each font used in the text\n   * @property {Float32Array} [caretPositions] startX,endX,bottomY caret positions for each char\n   * @property {Uint8Array} [glyphColors] color for each glyph, if color ranges supplied\n   *         chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n   *         fontSize, //calculated em height\n   *         topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n   *         blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n   *           anchorXOffset,\n   *           anchorYOffset - totalHeight,\n   *           anchorXOffset + maxLineWidth,\n   *           anchorYOffset\n   *         ],\n   *         visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n   *         timings\n   */\n\n  /**\n   * @typedef {object} TypesetFontData\n   * @property src\n   * @property unitsPerEm\n   * @property ascender\n   * @property descender\n   * @property lineHeight\n   * @property capHeight\n   * @property xHeight\n   */\n\n  /**\n   * @typedef {function} TypesetterTypesetFunction - compute fonts and layout for some text.\n   * @param {TypesetParams} params\n   * @param {(TypesetResult) => void} callback - function called when typesetting is complete.\n   *    If the params included `preResolvedFonts`, this will be called synchronously.\n   */\n\n  /**\n   * @typedef {function} TypesetterMeasureFunction - compute width/height for some text.\n   * @param {TypesetParams} params\n   * @param {(width:number, height:number) => void} callback - function called when measurement is complete.\n   *    If the params included `preResolvedFonts`, this will be called synchronously.\n   */\n\n\n  /**\n   * Factory function that creates a self-contained environment for processing text typesetting requests.\n   *\n   * It is important that this function has no closure dependencies, so that it can be easily injected\n   * into the source for a Worker without requiring a build step or complex dependency loading. All its\n   * dependencies must be passed in at initialization.\n   *\n   * @param {FontResolver} resolveFonts - function to resolve a string to parsed fonts\n   * @param {object} bidi - the bidi.js implementation object\n   * @return {{typeset: TypesetterTypesetFunction, measure: TypesetterMeasureFunction}}\n   */\n  function createTypesetter(resolveFonts, bidi) {\n    const INF = Infinity;\n\n    // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n    // eslint-disable-next-line no-misleading-character-class\n    const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n\n    // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n    const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n\n    // Incomplete set of characters that allow line breaking after them\n    // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n    const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n\n    /**\n     * Load and parse all the necessary fonts to render a given string of text, then group\n     * them into consecutive runs of characters sharing a font.\n     */\n    function calculateFontRuns({text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL}, onDone) {\n      const onResolved = ({chars, fonts: parsedFonts}) => {\n        let curRun, prevVal;\n        const runs = [];\n        for (let i = 0; i < chars.length; i++) {\n          if (chars[i] !== prevVal) {\n            prevVal = chars[i];\n            runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]]});\n          } else {\n            curRun.end = i;\n          }\n        }\n        onDone(runs);\n      };\n      if (preResolvedFonts) {\n        onResolved(preResolvedFonts);\n      } else {\n        resolveFonts(\n          text,\n          onResolved,\n          { lang, fonts, style, weight, unicodeFontsURL }\n        );\n      }\n    }\n\n    /**\n     * Main entry point.\n     * Process a text string with given font and formatting parameters, and return all info\n     * necessary to render all its glyphs.\n     * @type TypesetterTypesetFunction\n     */\n    function typeset(\n      {\n        text='',\n        font,\n        lang,\n        sdfGlyphSize=64,\n        fontSize=400,\n        fontWeight=1,\n        fontStyle='normal',\n        letterSpacing=0,\n        lineHeight='normal',\n        maxWidth=INF,\n        direction,\n        textAlign='left',\n        textIndent=0,\n        whiteSpace='normal',\n        overflowWrap='normal',\n        anchorX = 0,\n        anchorY = 0,\n        metricsOnly=false,\n        unicodeFontsURL,\n        preResolvedFonts=null,\n        includeCaretPositions=false,\n        chunkedBoundsSize=8192,\n        colorRanges=null\n      },\n      callback\n    ) {\n      const mainStart = now();\n      const timings = {fontLoad: 0, typesetting: 0};\n\n      // Ensure newlines are normalized\n      if (text.indexOf('\\r') > -1) {\n        console.info('Typesetter: got text with \\\\r chars; normalizing to \\\\n');\n        text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      }\n\n      // Ensure we've got numbers not strings\n      fontSize = +fontSize;\n      letterSpacing = +letterSpacing;\n      maxWidth = +maxWidth;\n      lineHeight = lineHeight || 'normal';\n      textIndent = +textIndent;\n\n      calculateFontRuns({\n        text,\n        lang,\n        style: fontStyle,\n        weight: fontWeight,\n        fonts: typeof font === 'string' ? [{src: font}] : font,\n        unicodeFontsURL,\n        preResolvedFonts\n      }, runs => {\n        timings.fontLoad = now() - mainStart;\n        const hasMaxWidth = isFinite(maxWidth);\n        let glyphIds = null;\n        let glyphFontIndices = null;\n        let glyphPositions = null;\n        let glyphData = null;\n        let glyphColors = null;\n        let caretPositions = null;\n        let visibleBounds = null;\n        let chunkedBounds = null;\n        let maxLineWidth = 0;\n        let renderableGlyphCount = 0;\n        let canWrap = whiteSpace !== 'nowrap';\n        const metricsByFont = new Map(); // fontObj -> metrics\n        const typesetStart = now();\n\n        // Distribute glyphs into lines based on wrapping\n        let lineXOffset = textIndent;\n        let prevRunEndX = 0;\n        let currentLine = new TextLine();\n        const lines = [currentLine];\n        runs.forEach(run => {\n          const { fontObj } = run;\n          const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;\n\n          // Calculate metrics for each font used\n          let fontData = metricsByFont.get(fontObj);\n          if (!fontData) {\n            // Find conversion between native font units and fontSize units\n            const fontSizeMult = fontSize / unitsPerEm;\n\n            // Determine appropriate value for 'normal' line height based on the font's actual metrics\n            // This does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n            const calcLineHeight = lineHeight === 'normal' ?\n              (ascender - descender + lineGap) * fontSizeMult : lineHeight * fontSize;\n\n            // Determine line height and leading adjustments\n            const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult) / 2;\n            const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult);\n            const caretTop = (ascender + descender) / 2 * fontSizeMult + caretHeight / 2;\n            fontData = {\n              index: metricsByFont.size,\n              src: fontObj.src,\n              fontObj,\n              fontSizeMult,\n              unitsPerEm,\n              ascender: ascender * fontSizeMult,\n              descender: descender * fontSizeMult,\n              capHeight: capHeight * fontSizeMult,\n              xHeight: xHeight * fontSizeMult,\n              lineHeight: calcLineHeight,\n              baseline: -halfLeading - ascender * fontSizeMult, // baseline offset from top of line height\n              // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height\n              // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height\n              caretTop,\n              caretBottom: caretTop - caretHeight\n            };\n            metricsByFont.set(fontObj, fontData);\n          }\n          const { fontSizeMult } = fontData;\n\n          const runText = text.slice(run.start, run.end + 1);\n          let prevGlyphX, prevGlyphObj;\n          fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {\n            glyphX += prevRunEndX;\n            charIndex += run.start;\n            prevGlyphX = glyphX;\n            prevGlyphObj = glyphObj;\n            const char = text.charAt(charIndex);\n            const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n            const curLineCount = currentLine.count;\n            let nextLine;\n\n            // Calc isWhitespace and isEmpty once per glyphObj\n            if (!('isEmpty' in glyphObj)) {\n              glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n              glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n              glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n            }\n            if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n              renderableGlyphCount++;\n            }\n\n            // If a non-whitespace character overflows the max width, we need to soft-wrap\n            if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n              // If it's the first char after a whitespace, start a new line\n              if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n                nextLine = new TextLine();\n                lineXOffset = -glyphX;\n              } else {\n                // Back up looking for a whitespace character to wrap at\n                for (let i = curLineCount; i--;) {\n                  // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n                  if (i === 0 && overflowWrap === 'break-word') {\n                    nextLine = new TextLine();\n                    lineXOffset = -glyphX;\n                    break\n                  }\n                  // Found a soft break point; move all chars since it to a new line\n                  else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                    nextLine = currentLine.splitAt(i + 1);\n                    const adjustX = nextLine.glyphAt(0).x;\n                    lineXOffset -= adjustX;\n                    for (let j = nextLine.count; j--;) {\n                      nextLine.glyphAt(j).x -= adjustX;\n                    }\n                    break\n                  }\n                }\n              }\n              if (nextLine) {\n                currentLine.isSoftWrapped = true;\n                currentLine = nextLine;\n                lines.push(currentLine);\n                maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n              }\n            }\n\n            let fly = currentLine.glyphAt(currentLine.count);\n            fly.glyphObj = glyphObj;\n            fly.x = glyphX + lineXOffset;\n            fly.y = glyphY;\n            fly.width = glyphWidth;\n            fly.charIndex = charIndex;\n            fly.fontData = fontData;\n\n            // Handle hard line breaks\n            if (char === '\\n') {\n              currentLine = new TextLine();\n              lines.push(currentLine);\n              lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;\n            }\n          });\n          // At the end of a run we must capture the x position as the starting point for the next run\n          prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;\n        });\n\n        // Calculate width/height/baseline of each line (excluding trailing whitespace) and maximum block width\n        let totalHeight = 0;\n        lines.forEach(line => {\n          let isTrailingWhitespace = true;\n          for (let i = line.count; i--;) {\n            const glyphInfo = line.glyphAt(i);\n            // omit trailing whitespace from width calculation\n            if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {\n              line.width = glyphInfo.x + glyphInfo.width;\n              if (line.width > maxLineWidth) {\n                maxLineWidth = line.width;\n              }\n              isTrailingWhitespace = false;\n            }\n            // use the tallest line height, lowest baseline, and highest cap/ex\n            let {lineHeight, capHeight, xHeight, baseline} = glyphInfo.fontData;\n            if (lineHeight > line.lineHeight) line.lineHeight = lineHeight;\n            const baselineDiff = baseline - line.baseline;\n            if (baselineDiff < 0) { //shift all metrics down\n              line.baseline += baselineDiff;\n              line.cap += baselineDiff;\n              line.ex += baselineDiff;\n            }\n            // compare cap/ex based on new lowest baseline\n            line.cap = Math.max(line.cap, line.baseline + capHeight);\n            line.ex = Math.max(line.ex, line.baseline + xHeight);\n          }\n          line.baseline -= totalHeight;\n          line.cap -= totalHeight;\n          line.ex -= totalHeight;\n          totalHeight += line.lineHeight;\n        });\n\n        // Find overall position adjustments for anchoring\n        let anchorXOffset = 0;\n        let anchorYOffset = 0;\n        if (anchorX) {\n          if (typeof anchorX === 'number') {\n            anchorXOffset = -anchorX;\n          }\n          else if (typeof anchorX === 'string') {\n            anchorXOffset = -maxLineWidth * (\n              anchorX === 'left' ? 0 :\n              anchorX === 'center' ? 0.5 :\n              anchorX === 'right' ? 1 :\n              parsePercent(anchorX)\n            );\n          }\n        }\n        if (anchorY) {\n          if (typeof anchorY === 'number') {\n            anchorYOffset = -anchorY;\n          }\n          else if (typeof anchorY === 'string') {\n            anchorYOffset = anchorY === 'top' ? 0 :\n              anchorY === 'top-baseline' ? -lines[0].baseline :\n              anchorY === 'top-cap' ? -lines[0].cap :\n              anchorY === 'top-ex' ? -lines[0].ex :\n              anchorY === 'middle' ? totalHeight / 2 :\n              anchorY === 'bottom' ? totalHeight :\n              anchorY === 'bottom-baseline' ? -lines[lines.length - 1].baseline :\n              parsePercent(anchorY) * totalHeight;\n          }\n        }\n\n        if (!metricsOnly) {\n          // Resolve bidi levels\n          const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n\n          // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n          // collecting all renderable glyphs into a single collection.\n          glyphIds = new Uint16Array(renderableGlyphCount);\n          glyphFontIndices = new Uint8Array(renderableGlyphCount);\n          glyphPositions = new Float32Array(renderableGlyphCount * 2);\n          glyphData = {};\n          visibleBounds = [INF, INF, -INF, -INF];\n          chunkedBounds = [];\n          if (includeCaretPositions) {\n            caretPositions = new Float32Array(text.length * 4);\n          }\n          if (colorRanges) {\n            glyphColors = new Uint8Array(renderableGlyphCount * 3);\n          }\n          let renderableGlyphIndex = 0;\n          let prevCharIndex = -1;\n          let colorCharIndex = -1;\n          let chunk;\n          let currentColor;\n          lines.forEach((line, lineIndex) => {\n            let {count:lineGlyphCount, width:lineWidth} = line;\n\n            // Ignore empty lines\n            if (lineGlyphCount > 0) {\n              // Count trailing whitespaces, we want to ignore these for certain things\n              let trailingWhitespaceCount = 0;\n              for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {\n                trailingWhitespaceCount++;\n              }\n\n              // Apply horizontal alignment adjustments\n              let lineXOffset = 0;\n              let justifyAdjust = 0;\n              if (textAlign === 'center') {\n                lineXOffset = (maxLineWidth - lineWidth) / 2;\n              } else if (textAlign === 'right') {\n                lineXOffset = maxLineWidth - lineWidth;\n              } else if (textAlign === 'justify' && line.isSoftWrapped) {\n                // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n                let whitespaceCount = 0;\n                for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {\n                  if (line.glyphAt(i).glyphObj.isWhitespace) {\n                    whitespaceCount++;\n                  }\n                }\n                justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n              }\n              if (justifyAdjust || lineXOffset) {\n                let justifyOffset = 0;\n                for (let i = 0; i < lineGlyphCount; i++) {\n                  let glyphInfo = line.glyphAt(i);\n                  const glyphObj = glyphInfo.glyphObj;\n                  glyphInfo.x += lineXOffset + justifyOffset;\n                  // Expand non-trailing whitespaces for justify alignment\n                  if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                    justifyOffset += justifyAdjust;\n                    glyphInfo.width += justifyAdjust;\n                  }\n                }\n              }\n\n              // Perform bidi range flipping\n              const flips = bidi.getReorderSegments(\n                text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex\n              );\n              for (let fi = 0; fi < flips.length; fi++) {\n                const [start, end] = flips[fi];\n                // Map start/end string indices to indices in the line\n                let left = Infinity, right = -Infinity;\n                for (let i = 0; i < lineGlyphCount; i++) {\n                  if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters\n                    let startInLine = i, endInLine = i;\n                    for (; endInLine < lineGlyphCount; endInLine++) {\n                      let info = line.glyphAt(endInLine);\n                      if (info.charIndex > end) {\n                        break\n                      }\n                      if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width\n                        left = Math.min(left, info.x);\n                        right = Math.max(right, info.x + info.width);\n                      }\n                    }\n                    for (let j = startInLine; j < endInLine; j++) {\n                      const glyphInfo = line.glyphAt(j);\n                      glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                    }\n                    break\n                  }\n                }\n              }\n\n              // Assemble final data arrays\n              let glyphObj;\n              const setGlyphObj = g => glyphObj = g;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                const glyphInfo = line.glyphAt(i);\n                glyphObj = glyphInfo.glyphObj;\n                const glyphId = glyphObj.index;\n\n                // Replace mirrored characters in rtl\n                const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n                if (rtl) {\n                  const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                  if (mirrored) {\n                    glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                  }\n                }\n\n                // Add caret positions\n                if (includeCaretPositions) {\n                  const {charIndex, fontData} = glyphInfo;\n                  const caretLeft = glyphInfo.x + anchorXOffset;\n                  const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                  caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft; //start edge x\n                  caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                  caretPositions[charIndex * 4 + 2] = line.baseline + fontData.caretBottom + anchorYOffset; //common bottom y\n                  caretPositions[charIndex * 4 + 3] = line.baseline + fontData.caretTop + anchorYOffset; //common top y\n\n                  // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                  // positions for those missing char indices; currently this uses a best-guess by dividing\n                  // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                  // table to get better interior caret positions.\n                  const ligCount = charIndex - prevCharIndex;\n                  if (ligCount > 1) {\n                    fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                  }\n                  prevCharIndex = charIndex;\n                }\n\n                // Track current color range\n                if (colorRanges) {\n                  const {charIndex} = glyphInfo;\n                  while(charIndex > colorCharIndex) {\n                    colorCharIndex++;\n                    if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                      currentColor = colorRanges[colorCharIndex];\n                    }\n                  }\n                }\n\n                // Get atlas data for renderable glyphs\n                if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                  const idx = renderableGlyphIndex++;\n                  const {fontSizeMult, src: fontSrc, index: fontIndex} = glyphInfo.fontData;\n\n                  // Add this glyph's path data\n                  const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});\n                  if (!fontGlyphData[glyphId]) {\n                    fontGlyphData[glyphId] = {\n                      path: glyphObj.path,\n                      pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]\n                    };\n                  }\n\n                  // Determine final glyph position and add to glyphPositions array\n                  const glyphX = glyphInfo.x + anchorXOffset;\n                  const glyphY = glyphInfo.y + line.baseline + anchorYOffset;\n                  glyphPositions[idx * 2] = glyphX;\n                  glyphPositions[idx * 2 + 1] = glyphY;\n\n                  // Track total visible bounds\n                  const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                  const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                  const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                  const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                  if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                  if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                  if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                  if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n\n                  // Track bounding rects for each chunk of N glyphs\n                  if (idx % chunkedBoundsSize === 0) {\n                    chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};\n                    chunkedBounds.push(chunk);\n                  }\n                  chunk.end++;\n                  const chunkRect = chunk.rect;\n                  if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                  if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                  if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                  if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n\n                  // Add to glyph ids and font indices arrays\n                  glyphIds[idx] = glyphId;\n                  glyphFontIndices[idx] = fontIndex;\n\n                  // Add colors\n                  if (colorRanges) {\n                    const start = idx * 3;\n                    glyphColors[start] = currentColor >> 16 & 255;\n                    glyphColors[start + 1] = currentColor >> 8 & 255;\n                    glyphColors[start + 2] = currentColor & 255;\n                  }\n                }\n              }\n            }\n          });\n\n          // Fill in remaining caret positions in case the final character was a ligature\n          if (caretPositions) {\n            const ligCount = text.length - prevCharIndex;\n            if (ligCount > 1) {\n              fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n            }\n          }\n        }\n\n        // Assemble final data about each font used\n        const fontData = [];\n        metricsByFont.forEach(({index, src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight}) => {\n          fontData[index] = {src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight};\n        });\n\n        // Timing stats\n        timings.typesetting = now() - typesetStart;\n\n        callback({\n          glyphIds, //id for each glyph, specific to that glyph's font\n          glyphFontIndices, //index into fontData for each glyph\n          glyphPositions, //x,y of each glyph's origin in layout\n          glyphData, //dict holding data about each glyph appearing in the text\n          fontData, //data about each font used in the text\n          caretPositions, //startX,endX,bottomY caret positions for each char\n          // caretHeight, //height of cursor from bottom to top - todo per glyph?\n          glyphColors, //color for each glyph, if color ranges supplied\n          chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n          fontSize, //calculated em height\n          topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n          blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n            anchorXOffset,\n            anchorYOffset - totalHeight,\n            anchorXOffset + maxLineWidth,\n            anchorYOffset\n          ],\n          visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n          timings\n        });\n      });\n    }\n\n\n    /**\n     * For a given text string and font parameters, determine the resulting block dimensions\n     * after wrapping for the given maxWidth.\n     * @param args\n     * @param callback\n     */\n    function measure(args, callback) {\n      typeset({...args, metricsOnly: true}, (result) => {\n        const [x0, y0, x1, y1] = result.blockBounds;\n        callback({\n          width: x1 - x0,\n          height: y1 - y0\n        });\n      });\n    }\n\n    function parsePercent(str) {\n      let match = str.match(/^([\\d.]+)%$/);\n      let pct = match ? parseFloat(match[1]) : NaN;\n      return isNaN(pct) ? 0 : pct / 100\n    }\n\n    function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n      const ligStartX = caretPositions[ligStartIndex * 4];\n      const ligEndX = caretPositions[ligStartIndex * 4 + 1];\n      const ligBottom = caretPositions[ligStartIndex * 4 + 2];\n      const ligTop = caretPositions[ligStartIndex * 4 + 3];\n      const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n      for (let i = 0; i < ligCount; i++) {\n        const startIndex = (ligStartIndex + i) * 4;\n        caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n        caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n        caretPositions[startIndex + 2] = ligBottom;\n        caretPositions[startIndex + 3] = ligTop;\n      }\n    }\n\n    function now() {\n      return (self.performance || Date).now()\n    }\n\n    // Array-backed structure for a single line's glyphs data\n    function TextLine() {\n      this.data = [];\n    }\n    const textLineProps = ['glyphObj', 'x', 'y', 'width', 'charIndex', 'fontData'];\n    TextLine.prototype = {\n      width: 0,\n      lineHeight: 0,\n      baseline: 0,\n      cap: 0,\n      ex: 0,\n      isSoftWrapped: false,\n      get count() {\n        return Math.ceil(this.data.length / textLineProps.length)\n      },\n      glyphAt(i) {\n        let fly = TextLine.flyweight;\n        fly.data = this.data;\n        fly.index = i;\n        return fly\n      },\n      splitAt(i) {\n        let newLine = new TextLine();\n        newLine.data = this.data.splice(i * textLineProps.length);\n        return newLine\n      }\n    };\n    TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {\n      Object.defineProperty(obj, prop, {\n        get() {\n          return this.data[this.index * textLineProps.length + i]\n        },\n        set(val) {\n          this.data[this.index * textLineProps.length + i] = val;\n        }\n      });\n      return obj\n    }, {data: null, index: 0});\n\n\n    return {\n      typeset,\n      measure,\n    }\n  }\n\n  const now = () => (self.performance || Date).now();\n\n  const mainThreadGenerator = /*#__PURE__*/ createSDFGenerator__default['default']();\n\n  let warned;\n\n  /**\n   * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n   * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n   * generation when supported.\n   */\n  function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n    // Allow opt-out\n    if (!useWebGL) {\n      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n    }\n\n    // Attempt GPU-accelerated generation first\n    return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(\n      null,\n      err => {\n        // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n        if (!warned) {\n          console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n          warned = true;\n        }\n        return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n      }\n    )\n  }\n\n  const queue = [];\n  const chunkTimeBudget = 5; // ms\n  let timer = 0;\n\n  function nextChunk() {\n    const start = now();\n    while (queue.length && now() - start < chunkTimeBudget) {\n      queue.shift()();\n    }\n    timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n  }\n\n  /**\n   * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n   * macrotask chunks to allow render frames to execute in between.\n   */\n  const generateSDF_GL = (...args) => {\n    return new Promise((resolve, reject) => {\n      queue.push(() => {\n        const start = now();\n        try {\n          mainThreadGenerator.webgl.generateIntoCanvas(...args);\n          resolve({ timing: now() - start });\n        } catch (err) {\n          reject(err);\n        }\n      });\n      if (!timer) {\n        timer = setTimeout(nextChunk, 0);\n      }\n    })\n  };\n\n  const threadCount = 4; // how many workers to spawn\n  const idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\n  const threads = {};\n  let callNum = 0;\n\n  /**\n   * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n   */\n  function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n    const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);\n    let thread = threads[workerId];\n    if (!thread) {\n      thread = threads[workerId] = {\n        workerModule: troikaWorkerUtils.defineWorkerModule({\n          name: workerId,\n          workerId,\n          dependencies: [\n            createSDFGenerator__default['default'],\n            now\n          ],\n          init(_createSDFGenerator, now) {\n            const generate = _createSDFGenerator().javascript.generate;\n            return function (...args) {\n              const start = now();\n              const textureData = generate(...args);\n              return {\n                textureData,\n                timing: now() - start\n              }\n            }\n          },\n          getTransferables(result) {\n            return [result.textureData.buffer]\n          }\n        }),\n        requests: 0,\n        idleTimer: null\n      };\n    }\n\n    thread.requests++;\n    clearTimeout(thread.idleTimer);\n    return thread.workerModule(width, height, path, viewBox, distance, exponent)\n      .then(({ textureData, timing }) => {\n        // copy result data into the canvas\n        const start = now();\n        // expand single-channel data into rgba\n        const imageData = new Uint8Array(textureData.length * 4);\n        for (let i = 0; i < textureData.length; i++) {\n          imageData[i * 4 + channel] = textureData[i];\n        }\n        mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));\n        timing += now() - start;\n\n        // clean up workers after a while\n        if (--thread.requests === 0) {\n          thread.idleTimer = setTimeout(() => { troikaWorkerUtils.terminateWorker(workerId); }, idleTimeout);\n        }\n        return { timing }\n      })\n  }\n\n  function warmUpSDFCanvas(canvas) {\n    if (!canvas._warm) {\n      mainThreadGenerator.webgl.isSupported(canvas);\n      canvas._warm = true;\n    }\n  }\n\n  const resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\n\n  const CONFIG = {\n    defaultFontURL: null,\n    unicodeFontsURL: null,\n    sdfGlyphSize: 64,\n    sdfMargin: 1 / 16,\n    sdfExponent: 9,\n    textureWidth: 2048,\n  };\n  const tempColor = /*#__PURE__*/new three.Color();\n  let hasRequested = false;\n\n  function now$1() {\n    return (self.performance || Date).now()\n  }\n\n  /**\n   * Customizes the text builder configuration. This must be called prior to the first font processing\n   * request, and applies to all fonts.\n   *\n   * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n   *                 requests, in case none is specified or the specifiede font fails to load or parse.\n   *                 Defaults to \"Roboto Regular\" from Google Fonts.\n   * @param {String} config.unicodeFontsURL - A custom location for the fallback unicode-font-resolver\n   *                 data and font files, if you don't want to use the default CDN. See\n   *                 https://github.com/lojjic/unicode-font-resolver for details. It can also be\n   *                 configured per text instance, but this lets you do it once globally.\n   * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n   *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n   *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n   *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n   *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n   *                 to 64 which is generally a good balance of size and quality.\n   * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n   *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n   *                 the glyph's path, with lower precision further away. Defaults to 9.\n   * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n   *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n   *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n   *                 Defaults to 1/16th of the glyph size.\n   * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n   *                 2048 which is a safe maximum texture dimension according to the stats at\n   *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n   *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n   *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n   *                 increase the glyph size and/or have an extraordinary number of glyphs.\n   */\n  function configureTextBuilder(config) {\n    if (hasRequested) {\n      console.warn('configureTextBuilder called after first font request; will be ignored.');\n    } else {\n      assign(CONFIG, config);\n    }\n  }\n\n  /**\n   * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n   * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n   *\n   *   {\n   *     [sdfGlyphSize]: {\n   *       glyphCount: number,\n   *       sdfGlyphSize: number,\n   *       sdfTexture: Texture,\n   *       sdfCanvas: HTMLCanvasElement,\n   *       contextLost: boolean,\n   *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n   *     }\n   *   }\n   */\n  const atlases = Object.create(null);\n\n  /**\n   * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n   * @property {TypesetParams} parameters - The normalized input arguments to the render call.\n   * @property {Texture} sdfTexture - The SDF atlas texture.\n   * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n   * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n   * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n   * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n   * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n   * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n   *           four elements: the starting X, the ending X, the bottom Y, and the top Y for the caret.\n   * @property {number} [caretHeight] - An appropriate height for all selection carets.\n   * @property {number} ascender - The font's ascender metric.\n   * @property {number} descender - The font's descender metric.\n   * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n   * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n   * @property {number} lineHeight - The final computed lineHeight measurement.\n   * @property {number} topBaseline - The y position of the top line's baseline.\n   * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n   *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n   *           equivalent to the dimensions of a block-level text element in CSS.\n   * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n   *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n   * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n   *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n   * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n   *           generation, typesetting, etc.\n   * @frozen\n   */\n\n  /**\n   * @callback getTextRenderInfo~callback\n   * @param {TroikaTextRenderInfo} textRenderInfo\n   */\n\n  /**\n   * Main entry point for requesting the data needed to render a text string with given font parameters.\n   * This is an asynchronous call, performing most of the logic in a web worker thread.\n   * @param {TypesetParams} args\n   * @param {getTextRenderInfo~callback} callback\n   */\n  function getTextRenderInfo(args, callback) {\n    hasRequested = true;\n    args = assign({}, args);\n    const totalStart = now$1();\n\n    // Convert relative URL to absolute so it can be resolved in the worker, and add fallbacks.\n    // In the future we'll allow args.font to be a list with unicode ranges too.\n    const { defaultFontURL } = CONFIG;\n    const fonts = [];\n    if (defaultFontURL) {\n      fonts.push({label: 'default', src: toAbsoluteURL(defaultFontURL)});\n    }\n    if (args.font) {\n      fonts.push({label: 'user', src: toAbsoluteURL(args.font)});\n    }\n    args.font = fonts;\n\n    // Normalize text to a string\n    args.text = '' + args.text;\n\n    args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n    args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;\n\n    // Normalize colors\n    if (args.colorRanges != null) {\n      let colors = {};\n      for (let key in args.colorRanges) {\n        if (args.colorRanges.hasOwnProperty(key)) {\n          let val = args.colorRanges[key];\n          if (typeof val !== 'number') {\n            val = tempColor.set(val).getHex();\n          }\n          colors[key] = val;\n        }\n      }\n      args.colorRanges = colors;\n    }\n\n    Object.freeze(args);\n\n    // Init the atlas if needed\n    const {textureWidth, sdfExponent} = CONFIG;\n    const {sdfGlyphSize} = args;\n    const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);\n    let atlas = atlases[sdfGlyphSize];\n    if (!atlas) {\n      const canvas = document.createElement('canvas');\n      canvas.width = textureWidth;\n      canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n      atlas = atlases[sdfGlyphSize] = {\n        glyphCount: 0,\n        sdfGlyphSize,\n        sdfCanvas: canvas,\n        sdfTexture: new three.Texture(\n          canvas,\n          undefined,\n          undefined,\n          undefined,\n          three.LinearFilter,\n          three.LinearFilter\n        ),\n        contextLost: false,\n        glyphsByFont: new Map()\n      };\n      atlas.sdfTexture.generateMipmaps = false;\n      initContextLossHandling(atlas);\n    }\n\n    const {sdfTexture, sdfCanvas} = atlas;\n\n    // Issue request to the typesetting engine in the worker\n    typesetInWorker(args).then(result => {\n      const {glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings} = result;\n      const neededSDFs = [];\n      const glyphBounds = new Float32Array(glyphIds.length * 4);\n      let boundsIdx = 0;\n      let positionsIdx = 0;\n      const quadsStart = now$1();\n\n      const fontGlyphMaps = fontData.map(font => {\n        let map = atlas.glyphsByFont.get(font.src);\n        if (!map) {\n          atlas.glyphsByFont.set(font.src, map = new Map());\n        }\n        return map\n      });\n\n      glyphIds.forEach((glyphId, i) => {\n        const fontIndex = glyphFontIndices[i];\n        const {src: fontSrc, unitsPerEm} = fontData[fontIndex];\n        let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);\n\n        // If this is a glyphId not seen before, add it to the atlas\n        if (!glyphInfo) {\n          const {path, pathBounds} = result.glyphData[fontSrc][glyphId];\n\n          // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n          // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n          // useful interpolated values and will be ignored anyway.\n          const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])\n            / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n\n          const atlasIndex = atlas.glyphCount++;\n          const sdfViewBox = [\n            pathBounds[0] - fontUnitsMargin,\n            pathBounds[1] - fontUnitsMargin,\n            pathBounds[2] + fontUnitsMargin,\n            pathBounds[3] + fontUnitsMargin,\n          ];\n          fontGlyphMaps[fontIndex].set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));\n\n          // Collect those that need SDF generation\n          neededSDFs.push(glyphInfo);\n        }\n\n        // Calculate bounds for renderable quads\n        // TODO can we get this back off the main thread?\n        const {sdfViewBox} = glyphInfo;\n        const posX = glyphPositions[positionsIdx++];\n        const posY = glyphPositions[positionsIdx++];\n        const fontSizeMult = fontSize / unitsPerEm;\n        glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n        glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n        glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n        glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n\n        // Convert glyphId to SDF index for the shader\n        glyphIds[i] = glyphInfo.atlasIndex;\n      });\n      timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n\n      const sdfStart = now$1();\n      timings.sdf = {};\n\n      // Grow the texture height by power of 2 if needed\n      const currentHeight = sdfCanvas.height;\n      const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n      const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n      if (neededHeight > currentHeight) {\n        // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n        console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n        resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n        // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n        sdfTexture.dispose();\n      }\n\n      Promise.all(neededSDFs.map(glyphInfo =>\n        generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {\n          timings.sdf[glyphInfo.atlasIndex] = timing;\n        })\n      )).then(() => {\n        if (neededSDFs.length && !atlas.contextLost) {\n          safariPre15Workaround(atlas);\n          sdfTexture.needsUpdate = true;\n        }\n        timings.sdfTotal = now$1() - sdfStart;\n        timings.total = now$1() - totalStart;\n        // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n\n        // Invoke callback with the text layout arrays and updated texture\n        callback(Object.freeze({\n          parameters: args,\n          sdfTexture,\n          sdfGlyphSize,\n          sdfExponent,\n          glyphBounds,\n          glyphAtlasIndices: glyphIds,\n          glyphColors: result.glyphColors,\n          caretPositions: result.caretPositions,\n          chunkedBounds: result.chunkedBounds,\n          ascender: result.ascender,\n          descender: result.descender,\n          lineHeight: result.lineHeight,\n          capHeight: result.capHeight,\n          xHeight: result.xHeight,\n          topBaseline: result.topBaseline,\n          blockBounds: result.blockBounds,\n          visibleBounds: result.visibleBounds,\n          timings: result.timings,\n        }));\n      });\n    });\n\n    // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n    // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n    // a head start on that process before SDFs actually start getting processed.\n    Promise.resolve().then(() => {\n      if (!atlas.contextLost) {\n        warmUpSDFCanvas(sdfCanvas);\n      }\n    });\n  }\n\n  function generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {\n    if (contextLost) {\n      // If the context is lost there's nothing we can do, just quit silently and let it\n      // get regenerated when the context is restored\n      return Promise.resolve({timing: -1})\n    }\n    const {textureWidth, sdfExponent} = CONFIG;\n    const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n    const squareIndex = Math.floor(atlasIndex / 4);\n    const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n    const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n    const channel = atlasIndex % 4;\n    return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)\n  }\n\n  function initContextLossHandling(atlas) {\n    const canvas = atlas.sdfCanvas;\n\n    /*\n    // Begin context loss simulation\n    if (!window.WebGLDebugUtils) {\n      let script = document.getElementById('WebGLDebugUtilsScript')\n      if (!script) {\n        script = document.createElement('script')\n        script.id = 'WebGLDebugUtils'\n        document.head.appendChild(script)\n        script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n      }\n      script.addEventListener('load', () => {\n        initContextLossHandling(atlas)\n      })\n      return\n    }\n    window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n    canvas.loseContextInNCalls(500)\n    canvas.addEventListener('webglcontextrestored', (event) => {\n      canvas.loseContextInNCalls(5000)\n    })\n    // End context loss simulation\n    */\n\n    canvas.addEventListener('webglcontextlost', (event) => {\n      console.log('Context Lost', event);\n      event.preventDefault();\n      atlas.contextLost = true;\n    });\n    canvas.addEventListener('webglcontextrestored', (event) => {\n      console.log('Context Restored', event);\n      atlas.contextLost = false;\n      // Regenerate all glyphs into the restored canvas:\n      const promises = [];\n      atlas.glyphsByFont.forEach(glyphMap => {\n        glyphMap.forEach(glyph => {\n          promises.push(generateGlyphSDF(glyph, atlas, true));\n        });\n      });\n      Promise.all(promises).then(() => {\n        safariPre15Workaround(atlas);\n        atlas.sdfTexture.needsUpdate = true;\n      });\n    });\n  }\n\n  /**\n   * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n   * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n   * needed fonts and glyphs up front along with other assets.\n   *\n   * @param {object} options\n   * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n   *        be loaded.\n   * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n   *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n   *        to specify ligature sequences in addition to their individual characters to get all\n   *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n   * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n   *        specified `characters`.\n   * @param {function} callback - A function that will be called when the preloading is complete.\n   */\n  function preloadFont({font, characters, sdfGlyphSize}, callback) {\n    let text = Array.isArray(characters) ? characters.join('\\n') : '' + characters;\n    getTextRenderInfo({ font, sdfGlyphSize, text }, callback);\n  }\n\n\n  // Local assign impl so we don't have to import troika-core\n  function assign(toObj, fromObj) {\n    for (let key in fromObj) {\n      if (fromObj.hasOwnProperty(key)) {\n        toObj[key] = fromObj[key];\n      }\n    }\n    return toObj\n  }\n\n  // Utility for making URLs absolute\n  let linkEl;\n  function toAbsoluteURL(path) {\n    if (!linkEl) {\n      linkEl = typeof document === 'undefined' ? {} : document.createElement('a');\n    }\n    linkEl.href = path;\n    return linkEl.href\n  }\n\n  /**\n   * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n   * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n   * a slight performance cost.\n   */\n  function safariPre15Workaround(atlas) {\n    // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n    // have supported it for a long while so any false positives should be minimal.\n    if (typeof createImageBitmap !== 'function') {\n      console.info('Safari<15: applying SDF canvas workaround');\n      const {sdfCanvas, sdfTexture} = atlas;\n      const {width, height} = sdfCanvas;\n      const gl = atlas.sdfCanvas.getContext('webgl');\n      let pixels = sdfTexture.image.data;\n      if (!pixels || pixels.length !== width * height * 4) {\n        pixels = new Uint8Array(width * height * 4);\n        sdfTexture.image = {width, height, data: pixels};\n        sdfTexture.flipY = false;\n        sdfTexture.isDataTexture = true;\n      }\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    }\n  }\n\n  const typesetterWorkerModule = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'Typesetter',\n    dependencies: [\n      createTypesetter,\n      fontResolverWorkerModule,\n      bidiFactory__default['default'],\n    ],\n    init(createTypesetter, fontResolver, bidiFactory) {\n      return createTypesetter(fontResolver, bidiFactory())\n    }\n  });\n\n  const typesetInWorker = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'Typesetter',\n    dependencies: [\n      typesetterWorkerModule,\n    ],\n    init(typesetter) {\n      return function(args) {\n        return new Promise(resolve => {\n          typesetter.typeset(args, resolve);\n        })\n      }\n    },\n    getTransferables(result) {\n      // Mark array buffers as transferable to avoid cloning during postMessage\n      const transferables = [];\n      for (let p in result) {\n        if (result[p] && result[p].buffer) {\n          transferables.push(result[p].buffer);\n        }\n      }\n      return transferables\n    }\n  });\n\n  function dumpSDFTextures() {\n    Object.keys(atlases).forEach(size => {\n      const canvas = atlases[size].sdfCanvas;\n      const {width, height} = canvas;\n      console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n    });\n  }\n\n  const templateGeometries = {};\n\n  function getTemplateGeometry(detail) {\n    let geom = templateGeometries[detail];\n    if (!geom) {\n      // Geometry is two planes back-to-back, which will always be rendered FrontSide only but\n      // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.\n      // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials\n      // introduced by Three.js in r130 - see https://github.com/mrdoob/three.js/pull/21967\n      const front = new three.PlaneGeometry(1, 1, detail, detail);\n      const back = front.clone();\n      const frontAttrs = front.attributes;\n      const backAttrs = back.attributes;\n      const combined = new three.BufferGeometry();\n      const vertCount = frontAttrs.uv.count;\n      for (let i = 0; i < vertCount; i++) {\n        backAttrs.position.array[i * 3] *= -1; // flip position x\n        backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z\n      }\n      ['position', 'normal', 'uv'].forEach(name => {\n        combined.setAttribute(name, new three.Float32BufferAttribute(\n          [...frontAttrs[name].array, ...backAttrs[name].array],\n          frontAttrs[name].itemSize)\n        );\n      });\n      combined.setIndex([...front.index.array, ...back.index.array.map(n => n + vertCount)]);\n      combined.translate(0.5, 0.5, 0);\n      geom = templateGeometries[detail] = combined;\n    }\n    return geom\n  }\n\n  const glyphBoundsAttrName = 'aTroikaGlyphBounds';\n  const glyphIndexAttrName = 'aTroikaGlyphIndex';\n  const glyphColorAttrName = 'aTroikaGlyphColor';\n\n  /**\n  @class GlyphsGeometry\n\n  A specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\n  render the glyphs using GPU instancing of a single quad, rather than constructing a whole\n  geometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n    Where N = number of glyphs...\n\n    Instanced:\n    - position: 4 * 3\n    - index: 2 * 3\n    - normal: 4 * 3\n    - uv: 4 * 2\n    - glyph x/y bounds: N * 4\n    - glyph indices: N * 1\n    = 5N + 38\n\n    Non-instanced:\n    - position: N * 4 * 3\n    - index: N * 2 * 3\n    - normal: N * 4 * 3\n    - uv: N * 4 * 2\n    - glyph indices: N * 1\n    = 39N\n\n  A downside of this is the rare-but-possible lack of the instanced arrays extension,\n  which we could potentially work around with a fallback non-instanced implementation.\n\n  */\n  class GlyphsGeometry extends three.InstancedBufferGeometry {\n    constructor() {\n      super();\n\n      this.detail = 1;\n      this.curveRadius = 0;\n\n      // Define groups for rendering text outline as a separate pass; these will only\n      // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n      this.groups = [\n        {start: 0, count: Infinity, materialIndex: 0},\n        {start: 0, count: Infinity, materialIndex: 1}\n      ];\n\n      // Preallocate empty bounding objects\n      this.boundingSphere = new three.Sphere();\n      this.boundingBox = new three.Box3();\n    }\n\n    computeBoundingSphere () {\n      // No-op; we'll sync the boundingSphere proactively when needed.\n    }\n\n    computeBoundingBox() {\n      // No-op; we'll sync the boundingBox proactively when needed.\n    }\n\n    // Since our base geometry contains triangles for both front and back sides, we can emulate\n    // the \"side\" by restricting the draw range.\n    setSide(side) {\n      const verts = this.getIndex().count;\n      this.setDrawRange(side === three.BackSide ? verts / 2 : 0, side === three.DoubleSide ? verts : verts / 2);\n    }\n\n    set detail(detail) {\n      if (detail !== this._detail) {\n        this._detail = detail;\n        if (typeof detail !== 'number' || detail < 1) {\n          detail = 1;\n        }\n        let tpl = getTemplateGeometry(detail)\n        ;['position', 'normal', 'uv'].forEach(attr => {\n          this.attributes[attr] = tpl.attributes[attr].clone();\n        });\n        this.setIndex(tpl.getIndex().clone());\n      }\n    }\n    get detail() {\n      return this._detail\n    }\n\n    set curveRadius(r) {\n      if (r !== this._curveRadius) {\n        this._curveRadius = r;\n        this._updateBounds();\n      }\n    }\n    get curveRadius() {\n      return this._curveRadius\n    }\n\n    /**\n     * Update the geometry for a new set of glyphs.\n     * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n     *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n     * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n     *        the SDF atlas texture.\n     * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n     * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n     *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n     *        used with `applyClipRect` to choose an optimized `instanceCount`.\n     * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n     */\n    updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n      // Update the instance attributes\n      updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);\n      updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);\n      updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);\n      this._blockBounds = blockBounds;\n      this._chunkedBounds = chunkedBounds;\n      this.instanceCount = glyphAtlasIndices.length;\n      this._updateBounds();\n    }\n\n    _updateBounds() {\n      const bounds = this._blockBounds;\n      if (bounds) {\n        const { curveRadius, boundingBox: bbox } = this;\n        if (curveRadius) {\n          const { PI, floor, min, max, sin, cos } = Math;\n          const halfPi = PI / 2;\n          const twoPi = PI * 2;\n          const absR = Math.abs(curveRadius);\n          const leftAngle = bounds[0] / absR;\n          const rightAngle = bounds[2] / absR;\n          const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)\n            ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n          const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)\n            ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n          const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)\n            ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n          bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n          bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n        } else {\n          bbox.min.set(bounds[0], bounds[1], 0);\n          bbox.max.set(bounds[2], bounds[3], 0);\n        }\n        bbox.getBoundingSphere(this.boundingSphere);\n      }\n    }\n\n    /**\n     * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n     * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n     * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n     * be clipped anyway.\n     *\n     * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n     * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n     * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n     * but at the expense of much larger attribute buffers (see classdoc above.)\n     *\n     * @param {Vector4} clipRect\n     */\n    applyClipRect(clipRect) {\n      let count = this.getAttribute(glyphIndexAttrName).count;\n      let chunks = this._chunkedBounds;\n      if (chunks) {\n        for (let i = chunks.length; i--;) {\n          count = chunks[i].end;\n          let rect = chunks[i].rect;\n          // note: both rects are l-b-r-t\n          if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n            break\n          }\n        }\n      }\n      this.instanceCount = count;\n    }\n  }\n\n\n  function updateBufferAttr(geom, attrName, newArray, itemSize) {\n    const attr = geom.getAttribute(attrName);\n    if (newArray) {\n      // If length isn't changing, just update the attribute's array data\n      if (attr && attr.array.length === newArray.length) {\n        attr.array.set(newArray);\n        attr.needsUpdate = true;\n      } else {\n        geom.setAttribute(attrName, new three.InstancedBufferAttribute(newArray, itemSize));\n        // If the new attribute has a different size, we also have to (as of r117) manually clear the\n        // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n        // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n        // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n        // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n        // implies it should be supported. It's possible we need to\n        delete geom._maxInstanceCount; //for r117+, could be fragile\n        geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n      }\n    } else if (attr) {\n      geom.deleteAttribute(attrName);\n    }\n  }\n\n  // language=GLSL\n  const VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n\n  // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n  const VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n\n  // language=GLSL\n  const FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */}\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${''/*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */}\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${''/* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */}\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n\n  // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n  const FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n\n\n  /**\n   * Create a material for rendering text, derived from a baseMaterial\n   */\n  function createTextDerivedMaterial(baseMaterial) {\n    const textMaterial = troikaThreeUtils.createDerivedMaterial(baseMaterial, {\n      chained: true,\n      extensions: {\n        derivatives: true\n      },\n      uniforms: {\n        uTroikaSDFTexture: {value: null},\n        uTroikaSDFTextureSize: {value: new three.Vector2()},\n        uTroikaSDFGlyphSize: {value: 0},\n        uTroikaSDFExponent: {value: 0},\n        uTroikaTotalBounds: {value: new three.Vector4(0,0,0,0)},\n        uTroikaClipRect: {value: new three.Vector4(0,0,0,0)},\n        uTroikaDistanceOffset: {value: 0},\n        uTroikaOutlineOpacity: {value: 0},\n        uTroikaFillOpacity: {value: 1},\n        uTroikaPositionOffset: {value: new three.Vector2()},\n        uTroikaCurveRadius: {value: 0},\n        uTroikaBlurRadius: {value: 0},\n        uTroikaStrokeWidth: {value: 0},\n        uTroikaStrokeColor: {value: new three.Color()},\n        uTroikaStrokeOpacity: {value: 1},\n        uTroikaOrient: {value: new three.Matrix3()},\n        uTroikaUseGlyphColors: {value: true},\n        uTroikaSDFDebug: {value: false}\n      },\n      vertexDefs: VERTEX_DEFS,\n      vertexTransform: VERTEX_TRANSFORM,\n      fragmentDefs: FRAGMENT_DEFS,\n      fragmentColorTransform: FRAGMENT_TRANSFORM,\n      customRewriter({vertexShader, fragmentShader}) {\n        let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n        if (uDiffuseRE.test(fragmentShader)) {\n          // Replace all instances of `diffuse` with our varying\n          fragmentShader = fragmentShader\n            .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')\n            .replace(/\\bdiffuse\\b/g, 'vTroikaGlyphColor');\n          // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n          if (!uDiffuseRE.test(vertexShader)) {\n            vertexShader = vertexShader.replace(\n              troikaThreeUtils.voidMainRegExp,\n              'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n'\n            );\n          }\n        }\n        return { vertexShader, fragmentShader }\n      }\n    });\n\n    // Force transparency - TODO is this reasonable?\n    textMaterial.transparent = true;\n\n    Object.defineProperties(textMaterial, {\n      isTroikaTextMaterial: {value: true},\n\n      // WebGLShadowMap reverses the side of the shadow material by default, which fails\n      // for planes, so here we force the `shadowSide` to always match the main side.\n      shadowSide: {\n        get() {\n          return this.side\n        },\n        set() {\n          //no-op\n        }\n      }\n    });\n\n    return textMaterial\n  }\n\n  const defaultMaterial = /*#__PURE__*/ new three.MeshBasicMaterial({\n    color: 0xffffff,\n    side: three.DoubleSide,\n    transparent: true\n  });\n  const defaultStrokeColor = 0x808080;\n\n  const tempMat4 = /*#__PURE__*/ new three.Matrix4();\n  const tempVec3a = /*#__PURE__*/ new three.Vector3();\n  const tempVec3b = /*#__PURE__*/ new three.Vector3();\n  const tempArray = [];\n  const origin = /*#__PURE__*/ new three.Vector3();\n  const defaultOrient = '+x+y';\n\n  function first(o) {\n    return Array.isArray(o) ? o[0] : o\n  }\n\n  let getFlatRaycastMesh = () => {\n    const mesh = new three.Mesh(\n      new three.PlaneGeometry(1, 1),\n      defaultMaterial\n    );\n    getFlatRaycastMesh = () => mesh;\n    return mesh\n  };\n  let getCurvedRaycastMesh = () => {\n    const mesh = new three.Mesh(\n      new three.PlaneGeometry(1, 1, 32, 1),\n      defaultMaterial\n    );\n    getCurvedRaycastMesh = () => mesh;\n    return mesh\n  };\n\n  const syncStartEvent = { type: 'syncstart' };\n  const syncCompleteEvent = { type: 'synccomplete' };\n\n  const SYNCABLE_PROPS = [\n    'font',\n    'fontSize',\n    'fontStyle',\n    'fontWeight',\n    'lang',\n    'letterSpacing',\n    'lineHeight',\n    'maxWidth',\n    'overflowWrap',\n    'text',\n    'direction',\n    'textAlign',\n    'textIndent',\n    'whiteSpace',\n    'anchorX',\n    'anchorY',\n    'colorRanges',\n    'sdfGlyphSize'\n  ];\n\n  const COPYABLE_PROPS = SYNCABLE_PROPS.concat(\n    'material',\n    'color',\n    'depthOffset',\n    'clipRect',\n    'curveRadius',\n    'orientation',\n    'glyphGeometryDetail'\n  );\n\n  /**\n   * @class Text\n   *\n   * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n   * fields (SDF).\n   */\n  class Text extends three.Mesh {\n    constructor() {\n      const geometry = new GlyphsGeometry();\n      super(geometry, null);\n\n      // === Text layout properties: === //\n\n      /**\n       * @member {string} text\n       * The string of text to be rendered.\n       */\n      this.text = '';\n\n      /**\n       * @member {number|string} anchorX\n       * Defines the horizontal position in the text block that should line up with the local origin.\n       * Can be specified as a numeric x position in local units, a string percentage of the total\n       * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n       * or 'right'.\n       */\n      this.anchorX = 0;\n\n      /**\n       * @member {number|string} anchorY\n       * Defines the vertical position in the text block that should line up with the local origin.\n       * Can be specified as a numeric y position in local units (note: down is negative y), a string\n       * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n       * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n       */\n      this.anchorY = 0;\n\n      /**\n       * @member {number} curveRadius\n       * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n       * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n       * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n       * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n       *\n       * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n       * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n       */\n      this.curveRadius = 0;\n\n      /**\n       * @member {string} direction\n       * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n       * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n       */\n      this.direction = 'auto';\n\n      /**\n       * @member {string|null} font\n       * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n       * Defaults to Noto Sans.\n       */\n      this.font = null; //will use default from TextBuilder\n\n      this.unicodeFontsURL = null; //defaults to CDN\n\n      /**\n       * @member {number} fontSize\n       * The size at which to render the font in local units; corresponds to the em-box height\n       * of the chosen `font`.\n       */\n      this.fontSize = 0.1;\n\n      /**\n       * @member {number|'normal'|'bold'}\n       * The weight of the font. Currently only used for fallback Noto fonts.\n       */\n      this.fontWeight = 'normal';\n\n      /**\n       * @member {'normal'|'italic'}\n       * The style of the font. Currently only used for fallback Noto fonts.\n       */\n      this.fontStyle = 'normal';\n\n      /**\n       * @member {string|null} lang\n       * The language code of this text; can be used for explicitly selecting certain CJK fonts.\n       */\n      this.lang = null;\n\n        /**\n       * @member {number} letterSpacing\n       * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n       * numbers increase spacing and negative numbers decrease it.\n       */\n      this.letterSpacing = 0;\n\n      /**\n       * @member {number|string} lineHeight\n       * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n       * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n       */\n      this.lineHeight = 'normal';\n\n      /**\n       * @member {number} maxWidth\n       * The maximum width of the text block, above which text may start wrapping according to the\n       * `whiteSpace` and `overflowWrap` properties.\n       */\n      this.maxWidth = Infinity;\n\n      /**\n       * @member {string} overflowWrap\n       * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n       * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n       * Defaults to `'normal'`.\n       */\n      this.overflowWrap = 'normal';\n\n      /**\n       * @member {string} textAlign\n       * The horizontal alignment of each line of text within the overall text bounding box.\n       */\n      this.textAlign = 'left';\n\n      /**\n       * @member {number} textIndent\n       * Indentation for the first character of a line; see CSS `text-indent`.\n       */\n      this.textIndent = 0;\n\n      /**\n       * @member {string} whiteSpace\n       * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n       * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n       * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n       * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n       */\n      this.whiteSpace = 'normal';\n\n\n      // === Presentation properties: === //\n\n      /**\n       * @member {THREE.Material} material\n       * Defines a _base_ material to be used when rendering the text. This material will be\n       * automatically replaced with a material derived from it, that adds shader code to\n       * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n       * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n       * of the other mesh materials to gain other features like lighting, texture maps, etc.\n       *\n       * Also see the `color` shortcut property.\n       */\n      this.material = null;\n\n      /**\n       * @member {string|number|THREE.Color} color\n       * This is a shortcut for setting the `color` of the text's material. You can use this\n       * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n       * `material`, this color will only be used for this particuar Text instance, even if\n       * that same material instance is shared across multiple Text objects.\n       */\n      this.color = null;\n\n      /**\n       * @member {object|null} colorRanges\n       * WARNING: This API is experimental and may change.\n       * This allows more fine-grained control of colors for individual or ranges of characters,\n       * taking precedence over the material's `color`. Its format is an Object whose keys each\n       * define a starting character index for a range, and whose values are the color for each\n       * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n       * any of the strings accepted by `THREE.Color`.\n       */\n      this.colorRanges = null;\n\n      /**\n       * @member {number|string} outlineWidth\n       * WARNING: This API is experimental and may change.\n       * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n       * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n       * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n       */\n      this.outlineWidth = 0;\n\n      /**\n       * @member {string|number|THREE.Color} outlineColor\n       * WARNING: This API is experimental and may change.\n       * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n       * Defaults to black.\n       */\n      this.outlineColor = 0x000000;\n\n      /**\n       * @member {number} outlineOpacity\n       * WARNING: This API is experimental and may change.\n       * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n       * Defaults to `1`.\n       */\n      this.outlineOpacity = 1;\n\n      /**\n       * @member {number|string} outlineBlur\n       * WARNING: This API is experimental and may change.\n       * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n       * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n       * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.outlineBlur = 0;\n\n      /**\n       * @member {number|string} outlineOffsetX\n       * WARNING: This API is experimental and may change.\n       * A horizontal offset for the text outline.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n       * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.outlineOffsetX = 0;\n\n      /**\n       * @member {number|string} outlineOffsetY\n       * WARNING: This API is experimental and may change.\n       * A vertical offset for the text outline.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n       * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.outlineOffsetY = 0;\n\n      /**\n       * @member {number|string} strokeWidth\n       * WARNING: This API is experimental and may change.\n       * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n       * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.strokeWidth = 0;\n\n      /**\n       * @member {string|number|THREE.Color} strokeColor\n       * WARNING: This API is experimental and may change.\n       * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n       */\n      this.strokeColor = defaultStrokeColor;\n\n      /**\n       * @member {number} strokeOpacity\n       * WARNING: This API is experimental and may change.\n       * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n       */\n      this.strokeOpacity = 1;\n\n      /**\n       * @member {number} fillOpacity\n       * WARNING: This API is experimental and may change.\n       * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n       * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n       * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n       */\n      this.fillOpacity = 1;\n\n      /**\n       * @member {number} depthOffset\n       * This is a shortcut for setting the material's `polygonOffset` and related properties,\n       * which can be useful in preventing z-fighting when this text is laid on top of another\n       * plane in the scene. Positive numbers are further from the camera, negatives closer.\n       */\n      this.depthOffset = 0;\n\n      /**\n       * @member {Array<number>} clipRect\n       * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n       * pixels will be discarded. This can be used for example to clip overflowing text when\n       * `whiteSpace='nowrap'`.\n       */\n      this.clipRect = null;\n\n      /**\n       * @member {string} orientation\n       * Defines the axis plane on which the text should be laid out when the mesh has no extra\n       * rotation transform. It is specified as a string with two axes: the horizontal axis with\n       * positive pointing right, and the vertical axis with positive pointing up. By default this\n       * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n       * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n       * top toward negative z and facing positive y.\n       */\n      this.orientation = defaultOrient;\n\n      /**\n       * @member {number} glyphGeometryDetail\n       * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n       * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n       * vertex shader effects, for example.\n       */\n      this.glyphGeometryDetail = 1;\n\n      /**\n       * @member {number|null} sdfGlyphSize\n       * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n       * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n       * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n       * the sharpness of corners and preventing loss of very thin lines, at the expense of\n       * increased memory footprint and longer SDF generation time.\n       */\n      this.sdfGlyphSize = null;\n\n      /**\n       * @member {boolean} gpuAccelerateSDF\n       * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n       * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n       * executed in web workers when support isn't available. It should automatically detect support,\n       * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n       * version if you encounter issues with it.\n       */\n      this.gpuAccelerateSDF = true;\n\n      this.debugSDF = false;\n    }\n\n    /**\n     * Updates the text rendering according to the current text-related configuration properties.\n     * This is an async process, so you can pass in a callback function to be executed when it\n     * finishes.\n     * @param {function} [callback]\n     */\n    sync(callback) {\n      if (this._needsSync) {\n        this._needsSync = false;\n\n        // If there's another sync still in progress, queue\n        if (this._isSyncing) {\n          (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n        } else {\n          this._isSyncing = true;\n          this.dispatchEvent(syncStartEvent);\n\n          getTextRenderInfo({\n            text: this.text,\n            font: this.font,\n            lang: this.lang,\n            fontSize: this.fontSize || 0.1,\n            fontWeight: this.fontWeight || 'normal',\n            fontStyle: this.fontStyle || 'normal',\n            letterSpacing: this.letterSpacing || 0,\n            lineHeight: this.lineHeight || 'normal',\n            maxWidth: this.maxWidth,\n            direction: this.direction || 'auto',\n            textAlign: this.textAlign,\n            textIndent: this.textIndent,\n            whiteSpace: this.whiteSpace,\n            overflowWrap: this.overflowWrap,\n            anchorX: this.anchorX,\n            anchorY: this.anchorY,\n            colorRanges: this.colorRanges,\n            includeCaretPositions: true, //TODO parameterize\n            sdfGlyphSize: this.sdfGlyphSize,\n            gpuAccelerateSDF: this.gpuAccelerateSDF,\n            unicodeFontsURL: this.unicodeFontsURL,\n          }, textRenderInfo => {\n            this._isSyncing = false;\n\n            // Save result for later use in onBeforeRender\n            this._textRenderInfo = textRenderInfo;\n\n            // Update the geometry attributes\n            this.geometry.updateGlyphs(\n              textRenderInfo.glyphBounds,\n              textRenderInfo.glyphAtlasIndices,\n              textRenderInfo.blockBounds,\n              textRenderInfo.chunkedBounds,\n              textRenderInfo.glyphColors\n            );\n\n            // If we had extra sync requests queued up, kick it off\n            const queued = this._queuedSyncs;\n            if (queued) {\n              this._queuedSyncs = null;\n              this._needsSync = true;\n              this.sync(() => {\n                queued.forEach(fn => fn && fn());\n              });\n            }\n\n            this.dispatchEvent(syncCompleteEvent);\n            if (callback) {\n              callback();\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * Initiate a sync if needed - note it won't complete until next frame at the\n     * earliest so if possible it's a good idea to call sync() manually as soon as\n     * all the properties have been set.\n     * @override\n     */\n    onBeforeRender(renderer, scene, camera, geometry, material, group) {\n      this.sync();\n\n      // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n      if (material.isTroikaTextMaterial) {\n        this._prepareForRender(material);\n      }\n\n      // We need to force the material to FrontSide to avoid the double-draw-call performance hit\n      // introduced in Three.js r130: https://github.com/mrdoob/three.js/pull/21967 - The sidedness\n      // is instead applied via drawRange in the GlyphsGeometry.\n      material._hadOwnSide = material.hasOwnProperty('side');\n      this.geometry.setSide(material._actualSide = material.side);\n      material.side = three.FrontSide;\n    }\n\n    onAfterRender(renderer, scene, camera, geometry, material, group) {\n      // Restore original material side\n      if (material._hadOwnSide) {\n        material.side = material._actualSide;\n      } else {\n        delete material.side; // back to inheriting from base material\n      }\n    }\n\n    /**\n     * Shortcut to dispose the geometry specific to this instance.\n     * Note: we don't also dispose the derived material here because if anything else is\n     * sharing the same base material it will result in a pause next frame as the program\n     * is recompiled. Instead users can dispose the base material manually, like normal,\n     * and we'll also dispose the derived material at that time.\n     */\n    dispose() {\n      this.geometry.dispose();\n    }\n\n    /**\n     * @property {TroikaTextRenderInfo|null} textRenderInfo\n     * @readonly\n     * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n     * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n     * the asynchrous `sync()` process completes.\n     */\n    get textRenderInfo() {\n      return this._textRenderInfo || null\n    }\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n      let derivedMaterial = this._derivedMaterial;\n      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      // If text outline is configured, render it as a preliminary draw using Three's multi-material\n      // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n      // materials ensures the layers are always rendered consecutively in a consistent order.\n      // Each layer will trigger onBeforeRender with the appropriate material.\n      if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {\n        let outlineMaterial = derivedMaterial._outlineMtl;\n        if (!outlineMaterial) {\n          outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n            id: {value: derivedMaterial.id + 0.1}\n          });\n          outlineMaterial.isTextOutlineMaterial = true;\n          outlineMaterial.depthWrite = false;\n          outlineMaterial.map = null; //???\n          derivedMaterial.addEventListener('dispose', function onDispose() {\n            derivedMaterial.removeEventListener('dispose', onDispose);\n            outlineMaterial.dispose();\n          });\n        }\n        return [\n          outlineMaterial,\n          derivedMaterial\n        ]\n      } else {\n        return derivedMaterial\n      }\n    }\n    set material(baseMaterial) {\n      if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation\n        this._derivedMaterial = baseMaterial;\n        this._baseMaterial = baseMaterial.baseMaterial;\n      } else {\n        this._baseMaterial = baseMaterial;\n      }\n    }\n\n    get glyphGeometryDetail() {\n      return this.geometry.detail\n    }\n    set glyphGeometryDetail(detail) {\n      this.geometry.detail = detail;\n    }\n\n    get curveRadius() {\n      return this.geometry.curveRadius\n    }\n    set curveRadius(r) {\n      this.geometry.curveRadius = r;\n    }\n\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n      return first(this.material).getDepthMaterial()\n    }\n    get customDistanceMaterial() {\n      return first(this.material).getDistanceMaterial()\n    }\n\n    _prepareForRender(material) {\n      const isOutline = material.isTextOutlineMaterial;\n      const uniforms = material.uniforms;\n      const textInfo = this.textRenderInfo;\n      if (textInfo) {\n        const {sdfTexture, blockBounds} = textInfo;\n        uniforms.uTroikaSDFTexture.value = sdfTexture;\n        uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n        uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n        uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n        uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n        uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n\n        let distanceOffset = 0;\n        let blurRadius = 0;\n        let strokeWidth = 0;\n        let fillOpacity;\n        let strokeOpacity;\n        let strokeColor;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isOutline) {\n          let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;\n          distanceOffset = this._parsePercent(outlineWidth) || 0;\n          blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n          fillOpacity = outlineOpacity;\n          offsetX = this._parsePercent(outlineOffsetX) || 0;\n          offsetY = this._parsePercent(outlineOffsetY) || 0;\n        } else {\n          strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n          if (strokeWidth) {\n            strokeColor = this.strokeColor;\n            uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n            strokeOpacity = this.strokeOpacity;\n            if (strokeOpacity == null) strokeOpacity = 1;\n          }\n          fillOpacity = this.fillOpacity;\n        }\n\n        uniforms.uTroikaDistanceOffset.value = distanceOffset;\n        uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n        uniforms.uTroikaBlurRadius.value = blurRadius;\n        uniforms.uTroikaStrokeWidth.value = strokeWidth;\n        uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n        uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n        uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n\n        let clipRect = this.clipRect;\n        if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n          uniforms.uTroikaClipRect.value.fromArray(clipRect);\n        } else {\n          // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n          const pad = (this.fontSize || 0.1) * 100;\n          uniforms.uTroikaClipRect.value.set(\n            blockBounds[0] - pad,\n            blockBounds[1] - pad,\n            blockBounds[2] + pad,\n            blockBounds[3] + pad\n          );\n        }\n        this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n      }\n      uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n      material.polygonOffset = !!this.depthOffset;\n      material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n      // Shortcut for setting material color via `color` prop on the mesh; this is\n      // applied only to the derived material to avoid mutating a shared base material.\n      const color = isOutline ? (this.outlineColor || 0) : this.color;\n\n      if (color == null) {\n        delete material.color; //inherit from base\n      } else {\n        const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new three.Color());\n        if (color !== colorObj._input || typeof color === 'object') {\n          colorObj.set(colorObj._input = color);\n        }\n      }\n\n      // base orientation\n      let orient = this.orientation || defaultOrient;\n      if (orient !== material._orientation) {\n        let rotMat = uniforms.uTroikaOrient.value;\n        orient = orient.replace(/[^-+xyz]/g, '');\n        let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n        if (match) {\n          let [, hSign, hAxis, vSign, vAxis] = match;\n          tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;\n          tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;\n          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n          rotMat.setFromMatrix4(tempMat4);\n        } else {\n          rotMat.identity();\n        }\n        material._orientation = orient;\n      }\n    }\n\n    _parsePercent(value) {\n      if (typeof value === 'string') {\n        let match = value.match(/^(-?[\\d.]+)%$/);\n        let pct = match ? parseFloat(match[1]) : NaN;\n        value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n      }\n      return value\n    }\n\n    /**\n     * Translate a point in local space to an x/y in the text plane.\n     */\n    localPositionToTextCoords(position, target = new three.Vector2()) {\n      target.copy(position); //simple non-curved case is 1:1\n      const r = this.curveRadius;\n      if (r) { //flatten the curve\n        target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n      }\n      return target\n    }\n\n    /**\n     * Translate a point in world space to an x/y in the text plane.\n     */\n    worldPositionToTextCoords(position, target = new three.Vector2()) {\n      tempVec3a.copy(position);\n      return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)\n    }\n\n    /**\n     * @override Custom raycasting to test against the whole text block's max rectangular bounds\n     * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n     */\n    raycast(raycaster, intersects) {\n      const {textRenderInfo, curveRadius} = this;\n      if (textRenderInfo) {\n        const bounds = textRenderInfo.blockBounds;\n        const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n        const geom = raycastMesh.geometry;\n        const {position, uv} = geom.attributes;\n        for (let i = 0; i < uv.count; i++) {\n          let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));\n          const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));\n          let z = 0;\n          if (curveRadius) {\n            z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n            x = Math.sin(x / curveRadius) * curveRadius;\n          }\n          position.setXYZ(i, x, y, z);\n        }\n        geom.boundingSphere = this.geometry.boundingSphere;\n        geom.boundingBox = this.geometry.boundingBox;\n        raycastMesh.matrixWorld = this.matrixWorld;\n        raycastMesh.material.side = this.material.side;\n        tempArray.length = 0;\n        raycastMesh.raycast(raycaster, tempArray);\n        for (let i = 0; i < tempArray.length; i++) {\n          tempArray[i].object = this;\n          intersects.push(tempArray[i]);\n        }\n      }\n    }\n\n    copy(source) {\n      // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n      const geom = this.geometry;\n      super.copy(source);\n      this.geometry = geom;\n\n      COPYABLE_PROPS.forEach(prop => {\n        this[prop] = source[prop];\n      });\n      return this\n    }\n\n    clone() {\n      return new this.constructor().copy(this)\n    }\n  }\n\n\n  // Create setters for properties that affect text layout:\n  SYNCABLE_PROPS.forEach(prop => {\n    const privateKey = '_private_' + prop;\n    Object.defineProperty(Text.prototype, prop, {\n      get() {\n        return this[privateKey]\n      },\n      set(value) {\n        if (value !== this[privateKey]) {\n          this[privateKey] = value;\n          this._needsSync = true;\n        }\n      }\n    });\n  });\n\n  //=== Utility functions for dealing with carets and selection ranges ===//\n\n  /**\n   * @typedef {object} TextCaret\n   * @property {number} x - x position of the caret\n   * @property {number} y - y position of the caret's bottom\n   * @property {number} height - height of the caret\n   * @property {number} charIndex - the index in the original input string of this caret's target\n   *   character; the caret will be for the position _before_ that character.\n   */\n\n  /**\n   * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n   * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n   * @param {number} x\n   * @param {number} y\n   * @return {TextCaret | null}\n   */\n  function getCaretAtPoint(textRenderInfo, x, y) {\n    let closestCaret = null;\n    const rows = groupCaretsByRow(textRenderInfo);\n\n    // Find nearest row by y first\n    let closestRow = null;\n    rows.forEach(row => {\n      if (!closestRow || Math.abs(y - (row.top + row.bottom) / 2) < Math.abs(y - (closestRow.top + closestRow.bottom) / 2)) {\n        closestRow = row;\n      }\n    });\n\n    // Then find closest caret by x within that row\n    closestRow.carets.forEach(caret => {\n      if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n        closestCaret = caret;\n      }\n    });\n    return closestCaret\n  }\n\n\n  const _rectsCache = new WeakMap();\n\n  /**\n   * Given start and end character indexes, return a list of rectangles covering all the\n   * characters within that selection.\n   * @param {TroikaTextRenderInfo} textRenderInfo\n   * @param {number} start - index of the first char in the selection\n   * @param {number} end - index of the first char after the selection\n   * @return {Array<{left, top, right, bottom}> | null}\n   */\n  function getSelectionRects(textRenderInfo, start, end) {\n    let rects;\n    if (textRenderInfo) {\n      // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n      let prevResult = _rectsCache.get(textRenderInfo);\n      if (prevResult && prevResult.start === start && prevResult.end === end) {\n        return prevResult.rects\n      }\n\n      const {caretPositions} = textRenderInfo;\n\n      // Normalize\n      if (end < start) {\n        const s = start;\n        start = end;\n        end = s;\n      }\n      start = Math.max(start, 0);\n      end = Math.min(end, caretPositions.length + 1);\n\n      // Build list of rects, expanding the current rect for all characters in a run and starting\n      // a new rect whenever reaching a new line or a new bidi direction\n      rects = [];\n      let currentRect = null;\n      for (let i = start; i < end; i++) {\n        const x1 = caretPositions[i * 4];\n        const x2 = caretPositions[i * 4 + 1];\n        const left = Math.min(x1, x2);\n        const right = Math.max(x1, x2);\n        const bottom = caretPositions[i * 4 + 2];\n        const top = caretPositions[i * 4 + 3];\n        if (!currentRect || bottom !== currentRect.bottom || top !== currentRect.top || left > currentRect.right || right < currentRect.left) {\n          currentRect = {\n            left: Infinity,\n            right: -Infinity,\n            bottom,\n            top,\n          };\n          rects.push(currentRect);\n        }\n        currentRect.left = Math.min(left, currentRect.left);\n        currentRect.right = Math.max(right, currentRect.right);\n      }\n\n      // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n      rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);\n      for (let i = rects.length - 1; i-- > 0;) {\n        const rectA = rects[i];\n        const rectB = rects[i + 1];\n        if (rectA.bottom === rectB.bottom && rectA.top === rectB.top && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n          rectB.left = Math.min(rectB.left, rectA.left);\n          rectB.right = Math.max(rectB.right, rectA.right);\n          rects.splice(i, 1);\n        }\n      }\n\n      _rectsCache.set(textRenderInfo, {start, end, rects});\n    }\n    return rects\n  }\n\n  const _caretsByRowCache = new WeakMap();\n\n  /**\n   * Group a set of carets by row of text, caching the result. A single row of text may contain carets of\n   * differing positions/heights if it has multiple fonts, and they may overlap slightly across rows, so this\n   * uses an assumption of \"at least overlapping by half\" to put them in the same row.\n   * @return Array<{bottom: number, top: number, carets: TextCaret[]}>\n   */\n  function groupCaretsByRow(textRenderInfo) {\n    // textRenderInfo is frozen so it's safe to cache based on it\n    let rows = _caretsByRowCache.get(textRenderInfo);\n    if (!rows) {\n      rows = [];\n      const {caretPositions} = textRenderInfo;\n      let curRow;\n\n      const visitCaret = (x, bottom, top, charIndex) => {\n        // new row if not overlapping by at least half\n        if (!curRow || (top < (curRow.top + curRow.bottom) / 2)) {\n          rows.push(curRow = {bottom, top, carets: []});\n        }\n        // expand vertical limits if necessary\n        if (top > curRow.top) curRow.top = top;\n        if (bottom < curRow.bottom) curRow.bottom = bottom;\n        curRow.carets.push({\n          x,\n          y: bottom,\n          height: top - bottom,\n          charIndex,\n        });\n      };\n\n      let i = 0;\n      for (; i < caretPositions.length; i += 4) {\n        visitCaret(caretPositions[i], caretPositions[i + 2], caretPositions[i + 3], i / 4);\n      }\n      // Add one more caret after the final char\n      visitCaret(caretPositions[i - 3], caretPositions[i - 2], caretPositions[i - 1], i / 4);\n    }\n    _caretsByRowCache.set(textRenderInfo, rows);\n    return rows\n  }\n\n  exports.GlyphsGeometry = GlyphsGeometry;\n  exports.Text = Text;\n  exports.configureTextBuilder = configureTextBuilder;\n  exports.createTextDerivedMaterial = createTextDerivedMaterial;\n  exports.dumpSDFTextures = dumpSDFTextures;\n  exports.fontResolverWorkerModule = fontResolverWorkerModule;\n  exports.getCaretAtPoint = getCaretAtPoint;\n  exports.getSelectionRects = getSelectionRects;\n  exports.getTextRenderInfo = getTextRenderInfo;\n  exports.preloadFont = preloadFont;\n  exports.typesetterWorkerModule = typesetterWorkerModule;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHlEQUFPLEdBQUcsbUJBQU8sQ0FBQyxxR0FBcUIsR0FBRyxtQkFBTyxDQUFDLGlHQUFxQixHQUFHLG1CQUFPLENBQUMsMERBQVMsR0FBRyxtQkFBTyxDQUFDLGtHQUFvQjtBQUNwTixFQUFFLENBQ21PO0FBQ3JPLENBQUMsMEdBQTBHOztBQUUzRyx1Q0FBdUMsNERBQTREOztBQUVuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrRSxPQUFPLGtCQUFrQixpQ0FBaUMsK0JBQStCLFFBQVEsOENBQThDLHNCQUFzQixLQUFLLGlCQUFpQixJQUFJLEtBQUssc0JBQXNCLCtCQUErQixTQUFTLDBCQUEwQix5QkFBeUIsaUJBQWlCLHNCQUFzQix3QkFBd0IsMEVBQTBFLCtIQUErSCxrQkFBa0IsS0FBSyxLQUFLLElBQUksS0FBSyx5QkFBeUIsMEJBQTBCLHNCQUFzQixLQUFLLHNCQUFzQixXQUFXLG9CQUFvQixRQUFRLFdBQVcsS0FBSyxXQUFXLG9FQUFvRSxTQUFTLDRCQUE0QixrREFBa0QsSUFBSSxLQUFLLHlCQUF5QiwwQkFBMEIsc0JBQXNCLDJDQUEyQyxXQUFXLFFBQVEsd0JBQXdCLGlEQUFpRCwyQkFBMkIsbUNBQW1DLHVCQUF1QixtQ0FBbUMsd0JBQXdCLGtDQUFrQyx5QkFBeUIsbUNBQW1DLDBCQUEwQixvQ0FBb0MsNkJBQTZCLGlCQUFpQixJQUFJLHVDQUF1QyxTQUFTLHdCQUF3QixvQ0FBb0MsMEJBQTBCLDhEQUE4RCwyQkFBMkIsaUJBQWlCLElBQUksbUNBQW1DLFNBQVMsNkJBQTZCLGlCQUFpQixJQUFJLEtBQUssdUJBQXVCLDJCQUEyQixTQUFTLDJHQUEyRyxtQkFBbUIsZ0VBQWdFLDJCQUEyQixpQkFBaUIs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBRUEsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQWlEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS10ZXh0L2Rpc3QvdHJvaWthLXRocmVlLXRleHQudW1kLmpzP2Y0ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCd0aHJlZScpLCByZXF1aXJlKCd0cm9pa2Etd29ya2VyLXV0aWxzJyksIHJlcXVpcmUoJ3dlYmdsLXNkZi1nZW5lcmF0b3InKSwgcmVxdWlyZSgnYmlkaS1qcycpLCByZXF1aXJlKCd0cm9pa2EtdGhyZWUtdXRpbHMnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3RocmVlJywgJ3Ryb2lrYS13b3JrZXItdXRpbHMnLCAnd2ViZ2wtc2RmLWdlbmVyYXRvcicsICdiaWRpLWpzJywgJ3Ryb2lrYS10aHJlZS11dGlscyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnRyb2lrYV90aHJlZV90ZXh0ID0ge30sIGdsb2JhbC5USFJFRSwgZ2xvYmFsLnRyb2lrYV93b3JrZXJfdXRpbHMsIGdsb2JhbC53ZWJnbF9zZGZfZ2VuZXJhdG9yLCBnbG9iYWwuYmlkaV9qcywgZ2xvYmFsLnRyb2lrYV90aHJlZV91dGlscykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIHRocmVlLCB0cm9pa2FXb3JrZXJVdGlscywgY3JlYXRlU0RGR2VuZXJhdG9yLCBiaWRpRmFjdG9yeSwgdHJvaWthVGhyZWVVdGlscykgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbiAgdmFyIGNyZWF0ZVNERkdlbmVyYXRvcl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koY3JlYXRlU0RGR2VuZXJhdG9yKTtcbiAgdmFyIGJpZGlGYWN0b3J5X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShiaWRpRmFjdG9yeSk7XG5cbiAgLyohXG4gIEN1c3RvbSBidWlsZCBvZiBUeXByLnRzIChodHRwczovL2dpdGh1Yi5jb20vZnJlZGxpNzQvVHlwci50cykgZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuXG4gIE9yaWdpbmFsIE1JVCBsaWNlbnNlIGFwcGxpZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mcmVkbGk3NC9UeXByLnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgKi9cbiAgZnVuY3Rpb24gdHlwckZhY3RvcnkoKXtyZXR1cm4gXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyYmKHNlbGYud2luZG93PXNlbGYpLGZ1bmN0aW9uKHIpe3ZhciBlPXtwYXJzZTpmdW5jdGlvbihyKXt2YXIgdD1lLl9iaW4sYT1uZXcgVWludDhBcnJheShyKTtpZihcInR0Y2ZcIj09dC5yZWFkQVNDSUkoYSwwLDQpKXt2YXIgbj00O3QucmVhZFVzaG9ydChhLG4pLG4rPTIsdC5yZWFkVXNob3J0KGEsbiksbis9Mjt2YXIgbz10LnJlYWRVaW50KGEsbik7bis9NDtmb3IodmFyIHM9W10saT0wO2k8bztpKyspe3ZhciBoPXQucmVhZFVpbnQoYSxuKTtuKz00LHMucHVzaChlLl9yZWFkRm9udChhLGgpKTt9cmV0dXJuIHN9cmV0dXJuIFtlLl9yZWFkRm9udChhLDApXX0sX3JlYWRGb250OmZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dDthLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9Mjtmb3IodmFyIHM9W1wiY21hcFwiLFwiaGVhZFwiLFwiaGhlYVwiLFwibWF4cFwiLFwiaG10eFwiLFwibmFtZVwiLFwiT1MvMlwiLFwicG9zdFwiLFwibG9jYVwiLFwiZ2x5ZlwiLFwia2VyblwiLFwiQ0ZGIFwiLFwiR0RFRlwiLFwiR1BPU1wiLFwiR1NVQlwiLFwiU1ZHIFwiXSxpPXtfZGF0YTpyLF9vZmZzZXQ6bn0saD17fSxkPTA7ZDxvO2QrKyl7dmFyIGY9YS5yZWFkQVNDSUkocix0LDQpO3QrPTQsYS5yZWFkVWludChyLHQpLHQrPTQ7dmFyIHU9YS5yZWFkVWludChyLHQpO3QrPTQ7dmFyIGw9YS5yZWFkVWludChyLHQpO3QrPTQsaFtmXT17b2Zmc2V0OnUsbGVuZ3RoOmx9O31mb3IoZD0wO2Q8cy5sZW5ndGg7ZCsrKXt2YXIgdj1zW2RdO2hbdl0mJihpW3YudHJpbSgpXT1lW3YudHJpbSgpXS5wYXJzZShyLGhbdl0ub2Zmc2V0LGhbdl0ubGVuZ3RoLGkpKTt9cmV0dXJuIGl9LF90YWJPZmZzZXQ6ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4sbz1uLnJlYWRVc2hvcnQocixhKzQpLHM9YSsxMixpPTA7aTxvO2krKyl7dmFyIGg9bi5yZWFkQVNDSUkocixzLDQpO3MrPTQsbi5yZWFkVWludChyLHMpLHMrPTQ7dmFyIGQ9bi5yZWFkVWludChyLHMpO2lmKHMrPTQsbi5yZWFkVWludChyLHMpLHMrPTQsaD09dClyZXR1cm4gZH1yZXR1cm4gMH19O2UuX2Jpbj17cmVhZEZpeGVkOmZ1bmN0aW9uKHIsZSl7cmV0dXJuIChyW2VdPDw4fHJbZSsxXSkrKHJbZSsyXTw8OHxyW2UrM10pLzY1NTQwfSxyZWFkRjJkb3QxNDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4ucmVhZFNob3J0KHIsdCkvMTYzODR9LHJlYWRJbnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDMyKHQpfSxyZWFkSW50ODpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50OCh0KX0scmVhZFNob3J0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQxNih0KX0scmVhZFVzaG9ydDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0VWludDE2KHQpfSxyZWFkVXNob3J0czpmdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPVtdLG89MDtvPGE7bysrKW4ucHVzaChlLl9iaW4ucmVhZFVzaG9ydChyLHQrMipvKSk7cmV0dXJuIG59LHJlYWRVaW50OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRVaW50MzIodCl9LHJlYWRVaW50NjQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gNDI5NDk2NzI5NiplLl9iaW4ucmVhZFVpbnQocix0KStlLl9iaW4ucmVhZFVpbnQocix0KzQpfSxyZWFkQVNDSUk6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1cIlwiLG49MDtuPHQ7bisrKWErPVN0cmluZy5mcm9tQ2hhckNvZGUocltlK25dKTtyZXR1cm4gYX0scmVhZFVuaWNvZGU6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1cIlwiLG49MDtuPHQ7bisrKXt2YXIgbz1yW2UrK108PDh8cltlKytdO2ErPVN0cmluZy5mcm9tQ2hhckNvZGUobyk7fXJldHVybiBhfSxfdGRlYzpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuVGV4dERlY29kZXI/bmV3IHdpbmRvdy5UZXh0RGVjb2RlcjpudWxsLHJlYWRVVEY4OmZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4uX3RkZWM7cmV0dXJuIG4mJjA9PXQmJmE9PXIubGVuZ3RoP24uZGVjb2RlKHIpOmUuX2Jpbi5yZWFkQVNDSUkocix0LGEpfSxyZWFkQnl0ZXM6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1bXSxuPTA7bjx0O24rKylhLnB1c2gocltlK25dKTtyZXR1cm4gYX0scmVhZEFTQ0lJQXJyYXk6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1bXSxuPTA7bjx0O24rKylhLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShyW2Urbl0pKTtyZXR1cm4gYX0sX3ZpZXc6ZnVuY3Rpb24ocil7cmV0dXJuIHIuX2RhdGFWaWV3fHwoci5fZGF0YVZpZXc9ci5idWZmZXI/bmV3IERhdGFWaWV3KHIuYnVmZmVyLHIuYnl0ZU9mZnNldCxyLmJ5dGVMZW5ndGgpOm5ldyBEYXRhVmlldyhuZXcgVWludDhBcnJheShyKS5idWZmZXIpKX19LGUuX2xjdGY9e30sZS5fbGN0Zi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuLG8pe3ZhciBzPWUuX2JpbixpPXt9LGg9dDtzLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIGQ9cy5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj1zLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PXMucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLGkuc2NyaXB0TGlzdD1lLl9sY3RmLnJlYWRTY3JpcHRMaXN0KHIsaCtkKSxpLmZlYXR1cmVMaXN0PWUuX2xjdGYucmVhZEZlYXR1cmVMaXN0KHIsaCtmKSxpLmxvb2t1cExpc3Q9ZS5fbGN0Zi5yZWFkTG9va3VwTGlzdChyLGgrdSxvKSxpfSxlLl9sY3RmLnJlYWRMb29rdXBMaXN0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz10LHM9W10saT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9ZS5fbGN0Zi5yZWFkTG9va3VwVGFibGUocixvK2QsYSk7cy5wdXNoKGYpO31yZXR1cm4gc30sZS5fbGN0Zi5yZWFkTG9va3VwVGFibGU9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXQscz17dGFiczpbXX07cy5sdHlwZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLHMuZmxhZz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBpPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPXMubHR5cGUsZD0wO2Q8aTtkKyspe3ZhciBmPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9YShyLGgsbytmLHMpO3MudGFicy5wdXNoKHUpO31yZXR1cm4gc30sZS5fbGN0Zi5udW1PZk9uZXM9ZnVuY3Rpb24ocil7Zm9yKHZhciBlPTAsdD0wO3Q8MzI7dCsrKTAhPShyPj4+dCYxKSYmZSsrO3JldHVybiBlfSxlLl9sY3RmLnJlYWRDbGFzc0RlZj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPVtdLG89YS5yZWFkVXNob3J0KHIsdCk7aWYodCs9MiwxPT1vKXt2YXIgcz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPTA7aDxpO2grKyluLnB1c2gocytoKSxuLnB1c2gocytoKSxuLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7fWlmKDI9PW8pe3ZhciBkPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKGg9MDtoPGQ7aCsrKW4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MixuLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTIsbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO31yZXR1cm4gbn0sZS5fbGN0Zi5nZXRJbnRlcnZhbD1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5sZW5ndGg7dCs9Myl7dmFyIGE9clt0XSxuPXJbdCsxXTtpZihyW3QrMl0sYTw9ZSYmZTw9bilyZXR1cm4gdH1yZXR1cm4gLTF9LGUuX2xjdGYucmVhZENvdmVyYWdlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mbXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MiwxPT1uLmZtdCYmKG4udGFiPWEucmVhZFVzaG9ydHMocix0LG8pKSwyPT1uLmZtdCYmKG4udGFiPWEucmVhZFVzaG9ydHMocix0LDMqbykpLG59LGUuX2xjdGYuY292ZXJhZ2VJbmRleD1mdW5jdGlvbihyLHQpe3ZhciBhPXIudGFiO2lmKDE9PXIuZm10KXJldHVybiBhLmluZGV4T2YodCk7aWYoMj09ci5mbXQpe3ZhciBuPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoYSx0KTtpZigtMSE9bilyZXR1cm4gYVtuKzJdKyh0LWFbbl0pfXJldHVybiAtMX0sZS5fbGN0Zi5yZWFkRmVhdHVyZUxpc3Q9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBkPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9ZS5fbGN0Zi5yZWFkRmVhdHVyZVRhYmxlKHIsbitkKTtmLnRhZz1oLnRyaW0oKSxvLnB1c2goZik7fXJldHVybiBvfSxlLl9sY3RmLnJlYWRGZWF0dXJlVGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLHM+MCYmKG8uZmVhdHVyZVBhcmFtcz1uK3MpO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby50YWI9W107Zm9yKHZhciBoPTA7aDxpO2grKylvLnRhYi5wdXNoKGEucmVhZFVzaG9ydChyLHQrMipoKSk7cmV0dXJuIG99LGUuX2xjdGYucmVhZFNjcmlwdExpc3Q9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBkPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsb1toLnRyaW0oKV09ZS5fbGN0Zi5yZWFkU2NyaXB0VGFibGUocixuK2QpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkU2NyaXB0VGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLHM+MCYmKG8uZGVmYXVsdD1lLl9sY3RmLnJlYWRMYW5nU3lzVGFibGUocixuK3MpKTt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe3ZhciBkPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBmPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsb1tkLnRyaW0oKV09ZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKHIsbitmKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZExhbmdTeXNUYWJsZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O2EucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZXFGZWF0dXJlPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsbi5mZWF0dXJlcz1hLnJlYWRVc2hvcnRzKHIsdCxvKSxufSxlLkNGRj17fSxlLkNGRi5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluOyhyPW5ldyBVaW50OEFycmF5KHIuYnVmZmVyLHQsYSkpW3Q9MF0sclsrK3RdLHJbKyt0XSxyWysrdF0sdCsrO3ZhciBvPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxvKTtmb3IodmFyIHM9W10saT0wO2k8by5sZW5ndGgtMTtpKyspcy5wdXNoKG4ucmVhZEFTQ0lJKHIsdCtvW2ldLG9baSsxXS1vW2ldKSk7dCs9b1tvLmxlbmd0aC0xXTt2YXIgaD1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsaCk7dmFyIGQ9W107Zm9yKGk9MDtpPGgubGVuZ3RoLTE7aSsrKWQucHVzaChlLkNGRi5yZWFkRGljdChyLHQraFtpXSx0K2hbaSsxXSkpO3QrPWhbaC5sZW5ndGgtMV07dmFyIGY9ZFswXSx1PVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCx1KTt2YXIgbD1bXTtmb3IoaT0wO2k8dS5sZW5ndGgtMTtpKyspbC5wdXNoKG4ucmVhZEFTQ0lJKHIsdCt1W2ldLHVbaSsxXS11W2ldKSk7aWYodCs9dVt1Lmxlbmd0aC0xXSxlLkNGRi5yZWFkU3VicnMocix0LGYpLGYuQ2hhclN0cmluZ3Mpe3Q9Zi5DaGFyU3RyaW5nczt1PVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCx1KTt2YXIgdj1bXTtmb3IoaT0wO2k8dS5sZW5ndGgtMTtpKyspdi5wdXNoKG4ucmVhZEJ5dGVzKHIsdCt1W2ldLHVbaSsxXS11W2ldKSk7Zi5DaGFyU3RyaW5ncz12O31pZihmLlJPUyl7dD1mLkZEQXJyYXk7dmFyIGM9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LGMpLGYuRkRBcnJheT1bXTtmb3IoaT0wO2k8Yy5sZW5ndGgtMTtpKyspe3ZhciBwPWUuQ0ZGLnJlYWREaWN0KHIsdCtjW2ldLHQrY1tpKzFdKTtlLkNGRi5fcmVhZEZEaWN0KHIscCxsKSxmLkZEQXJyYXkucHVzaChwKTt9dCs9Y1tjLmxlbmd0aC0xXSx0PWYuRkRTZWxlY3QsZi5GRFNlbGVjdD1bXTt2YXIgVT1yW3RdO2lmKHQrKywzIT1VKXRocm93IFU7dmFyIGc9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IoaT0wO2k8ZysxO2krKylmLkZEU2VsZWN0LnB1c2gobi5yZWFkVXNob3J0KHIsdCksclt0KzJdKSx0Kz0zO31yZXR1cm4gZi5FbmNvZGluZyYmKGYuRW5jb2Rpbmc9ZS5DRkYucmVhZEVuY29kaW5nKHIsZi5FbmNvZGluZyxmLkNoYXJTdHJpbmdzLmxlbmd0aCkpLGYuY2hhcnNldCYmKGYuY2hhcnNldD1lLkNGRi5yZWFkQ2hhcnNldChyLGYuY2hhcnNldCxmLkNoYXJTdHJpbmdzLmxlbmd0aCkpLGUuQ0ZGLl9yZWFkRkRpY3QocixmLGwpLGZ9LGUuQ0ZGLl9yZWFkRkRpY3Q9ZnVuY3Rpb24ocix0LGEpe3ZhciBuO2Zvcih2YXIgbyBpbiB0LlByaXZhdGUmJihuPXQuUHJpdmF0ZVsxXSx0LlByaXZhdGU9ZS5DRkYucmVhZERpY3QocixuLG4rdC5Qcml2YXRlWzBdKSx0LlByaXZhdGUuU3VicnMmJmUuQ0ZGLnJlYWRTdWJycyhyLG4rdC5Qcml2YXRlLlN1YnJzLHQuUHJpdmF0ZSkpLHQpLTEhPVtcIkZhbWlseU5hbWVcIixcIkZvbnROYW1lXCIsXCJGdWxsTmFtZVwiLFwiTm90aWNlXCIsXCJ2ZXJzaW9uXCIsXCJDb3B5cmlnaHRcIl0uaW5kZXhPZihvKSYmKHRbb109YVt0W29dLTQyNiszNV0pO30sZS5DRkYucmVhZFN1YnJzPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsbyk7dmFyIHMsaT1vLmxlbmd0aDtzPWk8MTI0MD8xMDc6aTwzMzkwMD8xMTMxOjMyNzY4LGEuQmlhcz1zLGEuU3VicnM9W107Zm9yKHZhciBoPTA7aDxvLmxlbmd0aC0xO2grKylhLlN1YnJzLnB1c2gobi5yZWFkQnl0ZXMocix0K29baF0sb1toKzFdLW9baF0pKTt9LGUuQ0ZGLnRhYmxlU0U9WzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMCwxMTEsMTEyLDExMywxMTQsMCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDAsMTIzLDAsMTI0LDEyNSwxMjYsMTI3LDEyOCwxMjksMTMwLDEzMSwwLDEzMiwxMzMsMCwxMzQsMTM1LDEzNiwxMzcsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxMzgsMCwxMzksMCwwLDAsMCwxNDAsMTQxLDE0MiwxNDMsMCwwLDAsMCwwLDE0NCwwLDAsMCwxNDUsMCwwLDE0NiwxNDcsMTQ4LDE0OSwwLDAsMCwwXSxlLkNGRi5nbHlwaEJ5VW5pY29kZT1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5jaGFyc2V0Lmxlbmd0aDt0KyspaWYoci5jaGFyc2V0W3RdPT1lKXJldHVybiB0O3JldHVybiAtMX0sZS5DRkYuZ2x5cGhCeVNFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHQ8MHx8dD4yNTU/LTE6ZS5DRkYuZ2x5cGhCeVVuaWNvZGUocixlLkNGRi50YWJsZVNFW3RdKX0sZS5DRkYucmVhZEVuY29kaW5nPWZ1bmN0aW9uKHIsdCxhKXtlLl9iaW47dmFyIG49W1wiLm5vdGRlZlwiXSxvPXJbdF07aWYodCsrLDAhPW8pdGhyb3cgXCJlcnJvcjogdW5rbm93biBlbmNvZGluZyBmb3JtYXQ6IFwiK287dmFyIHM9clt0XTt0Kys7Zm9yKHZhciBpPTA7aTxzO2krKyluLnB1c2goclt0K2ldKTtyZXR1cm4gbn0sZS5DRkYucmVhZENoYXJzZXQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtcIi5ub3RkZWZcIl0scz1yW3RdO2lmKHQrKywwPT1zKWZvcih2YXIgaT0wO2k8YTtpKyspe3ZhciBoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGgpO31lbHNlIHtpZigxIT1zJiYyIT1zKXRocm93IFwiZXJyb3I6IGZvcm1hdDogXCIrcztmb3IoO28ubGVuZ3RoPGE7KXtoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9MDsxPT1zPyhkPXJbdF0sdCsrKTooZD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yKTtmb3IoaT0wO2k8PWQ7aSsrKW8ucHVzaChoKSxoKys7fX1yZXR1cm4gb30sZS5DRkYucmVhZEluZGV4PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1uLnJlYWRVc2hvcnQocix0KSsxLHM9clt0Kz0yXTtpZih0KyssMT09cylmb3IodmFyIGk9MDtpPG87aSsrKWEucHVzaChyW3QraV0pO2Vsc2UgaWYoMj09cylmb3IoaT0wO2k8bztpKyspYS5wdXNoKG4ucmVhZFVzaG9ydChyLHQrMippKSk7ZWxzZSBpZigzPT1zKWZvcihpPTA7aTxvO2krKylhLnB1c2goMTY3NzcyMTUmbi5yZWFkVWludChyLHQrMyppLTEpKTtlbHNlIGlmKDEhPW8pdGhyb3cgXCJ1bnN1cHBvcnRlZCBvZmZzZXQgc2l6ZTogXCIrcytcIiwgY291bnQ6IFwiK287cmV0dXJuICh0Kz1vKnMpLTF9LGUuQ0ZGLmdldENoYXJTdHJpbmc9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXJbdF0scz1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGk9MSxoPW51bGwsZD1udWxsO288PTIwJiYoaD1vLGk9MSksMTI9PW8mJihoPTEwMCpvK3MsaT0yKSwyMTw9byYmbzw9MjcmJihoPW8saT0xKSwyOD09byYmKGQ9bi5yZWFkU2hvcnQocix0KzEpLGk9MyksMjk8PW8mJm88PTMxJiYoaD1vLGk9MSksMzI8PW8mJm88PTI0NiYmKGQ9by0xMzksaT0xKSwyNDc8PW8mJm88PTI1MCYmKGQ9MjU2KihvLTI0NykrcysxMDgsaT0yKSwyNTE8PW8mJm88PTI1NCYmKGQ9MjU2Ki0oby0yNTEpLXMtMTA4LGk9MiksMjU1PT1vJiYoZD1uLnJlYWRJbnQocix0KzEpLzY1NTM1LGk9NSksYS52YWw9bnVsbCE9ZD9kOlwib1wiK2gsYS5zaXplPWk7fSxlLkNGRi5yZWFkQ2hhclN0cmluZz1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPXQrYSxvPWUuX2JpbixzPVtdO3Q8bjspe3ZhciBpPXJbdF0saD1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGQ9MSxmPW51bGwsdT1udWxsO2k8PTIwJiYoZj1pLGQ9MSksMTI9PWkmJihmPTEwMCppK2gsZD0yKSwxOSE9aSYmMjAhPWl8fChmPWksZD0yKSwyMTw9aSYmaTw9MjcmJihmPWksZD0xKSwyOD09aSYmKHU9by5yZWFkU2hvcnQocix0KzEpLGQ9MyksMjk8PWkmJmk8PTMxJiYoZj1pLGQ9MSksMzI8PWkmJmk8PTI0NiYmKHU9aS0xMzksZD0xKSwyNDc8PWkmJmk8PTI1MCYmKHU9MjU2KihpLTI0NykraCsxMDgsZD0yKSwyNTE8PWkmJmk8PTI1NCYmKHU9MjU2Ki0oaS0yNTEpLWgtMTA4LGQ9MiksMjU1PT1pJiYodT1vLnJlYWRJbnQocix0KzEpLzY1NTM1LGQ9NSkscy5wdXNoKG51bGwhPXU/dTpcIm9cIitmKSx0Kz1kO31yZXR1cm4gc30sZS5DRkYucmVhZERpY3Q9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4sbz17fSxzPVtdO3Q8YTspe3ZhciBpPXJbdF0saD1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGQ9MSxmPW51bGwsdT1udWxsO2lmKDI4PT1pJiYodT1uLnJlYWRTaG9ydChyLHQrMSksZD0zKSwyOT09aSYmKHU9bi5yZWFkSW50KHIsdCsxKSxkPTUpLDMyPD1pJiZpPD0yNDYmJih1PWktMTM5LGQ9MSksMjQ3PD1pJiZpPD0yNTAmJih1PTI1NiooaS0yNDcpK2grMTA4LGQ9MiksMjUxPD1pJiZpPD0yNTQmJih1PTI1NiotKGktMjUxKS1oLTEwOCxkPTIpLDI1NT09aSl0aHJvdyB1PW4ucmVhZEludChyLHQrMSkvNjU1MzUsZD01LFwidW5rbm93biBudW1iZXJcIjtpZigzMD09aSl7dmFyIGw9W107Zm9yKGQ9MTs7KXt2YXIgdj1yW3QrZF07ZCsrO3ZhciBjPXY+PjQscD0xNSZ2O2lmKDE1IT1jJiZsLnB1c2goYyksMTUhPXAmJmwucHVzaChwKSwxNT09cClicmVha31mb3IodmFyIFU9XCJcIixnPVswLDEsMiwzLDQsNSw2LDcsOCw5LFwiLlwiLFwiZVwiLFwiZS1cIixcInJlc2VydmVkXCIsXCItXCIsXCJlbmRPZk51bWJlclwiXSxTPTA7UzxsLmxlbmd0aDtTKyspVSs9Z1tsW1NdXTt1PXBhcnNlRmxvYXQoVSk7fWlmKGk8PTIxKWlmKGY9W1widmVyc2lvblwiLFwiTm90aWNlXCIsXCJGdWxsTmFtZVwiLFwiRmFtaWx5TmFtZVwiLFwiV2VpZ2h0XCIsXCJGb250QkJveFwiLFwiQmx1ZVZhbHVlc1wiLFwiT3RoZXJCbHVlc1wiLFwiRmFtaWx5Qmx1ZXNcIixcIkZhbWlseU90aGVyQmx1ZXNcIixcIlN0ZEhXXCIsXCJTdGRWV1wiLFwiZXNjYXBlXCIsXCJVbmlxdWVJRFwiLFwiWFVJRFwiLFwiY2hhcnNldFwiLFwiRW5jb2RpbmdcIixcIkNoYXJTdHJpbmdzXCIsXCJQcml2YXRlXCIsXCJTdWJyc1wiLFwiZGVmYXVsdFdpZHRoWFwiLFwibm9taW5hbFdpZHRoWFwiXVtpXSxkPTEsMTI9PWkpZj1bXCJDb3B5cmlnaHRcIixcImlzRml4ZWRQaXRjaFwiLFwiSXRhbGljQW5nbGVcIixcIlVuZGVybGluZVBvc2l0aW9uXCIsXCJVbmRlcmxpbmVUaGlja25lc3NcIixcIlBhaW50VHlwZVwiLFwiQ2hhcnN0cmluZ1R5cGVcIixcIkZvbnRNYXRyaXhcIixcIlN0cm9rZVdpZHRoXCIsXCJCbHVlU2NhbGVcIixcIkJsdWVTaGlmdFwiLFwiQmx1ZUZ1enpcIixcIlN0ZW1TbmFwSFwiLFwiU3RlbVNuYXBWXCIsXCJGb3JjZUJvbGRcIiwwLDAsXCJMYW5ndWFnZUdyb3VwXCIsXCJFeHBhbnNpb25GYWN0b3JcIixcImluaXRpYWxSYW5kb21TZWVkXCIsXCJTeW50aGV0aWNCYXNlXCIsXCJQb3N0U2NyaXB0XCIsXCJCYXNlRm9udE5hbWVcIixcIkJhc2VGb250QmxlbmRcIiwwLDAsMCwwLDAsMCxcIlJPU1wiLFwiQ0lERm9udFZlcnNpb25cIixcIkNJREZvbnRSZXZpc2lvblwiLFwiQ0lERm9udFR5cGVcIixcIkNJRENvdW50XCIsXCJVSURCYXNlXCIsXCJGREFycmF5XCIsXCJGRFNlbGVjdFwiLFwiRm9udE5hbWVcIl1baF0sZD0yO251bGwhPWY/KG9bZl09MT09cy5sZW5ndGg/c1swXTpzLHM9W10pOnMucHVzaCh1KSx0Kz1kO31yZXR1cm4gb30sZS5jbWFwPXt9LGUuY21hcC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7cj1uZXcgVWludDhBcnJheShyLmJ1ZmZlcix0LGEpLHQ9MDt2YXIgbj1lLl9iaW4sbz17fTtuLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGk9W107by50YWJsZXM9W107Zm9yKHZhciBoPTA7aDxzO2grKyl7dmFyIGQ9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PW4ucmVhZFVpbnQocix0KTt0Kz00O3ZhciBsPVwicFwiK2QrXCJlXCIrZix2PWkuaW5kZXhPZih1KTtpZigtMT09dil7dmFyIGM7dj1vLnRhYmxlcy5sZW5ndGgsaS5wdXNoKHUpO3ZhciBwPW4ucmVhZFVzaG9ydChyLHUpOzA9PXA/Yz1lLmNtYXAucGFyc2UwKHIsdSk6ND09cD9jPWUuY21hcC5wYXJzZTQocix1KTo2PT1wP2M9ZS5jbWFwLnBhcnNlNihyLHUpOjEyPT1wP2M9ZS5jbWFwLnBhcnNlMTIocix1KTpjb25zb2xlLmRlYnVnKFwidW5rbm93biBmb3JtYXQ6IFwiK3AsZCxmLHUpLG8udGFibGVzLnB1c2goYyk7fWlmKG51bGwhPW9bbF0pdGhyb3cgXCJtdWx0aXBsZSB0YWJsZXMgZm9yIG9uZSBwbGF0Zm9ybStlbmNvZGluZ1wiO29bbF09djt9cmV0dXJuIG99LGUuY21hcC5wYXJzZTA9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixuLm1hcD1bXTtmb3IodmFyIHM9MDtzPG8tNjtzKyspbi5tYXAucHVzaChyW3Qrc10pO3JldHVybiBufSxlLmNtYXAucGFyc2U0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9O28uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGg9aS8yO28uc2VhcmNoUmFuZ2U9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLmVudHJ5U2VsZWN0b3I9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLnJhbmdlU2hpZnQ9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLmVuZENvdW50PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCx0Kz0yLG8uc3RhcnRDb3VudD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsby5pZERlbHRhPVtdO2Zvcih2YXIgZD0wO2Q8aDtkKyspby5pZERlbHRhLnB1c2goYS5yZWFkU2hvcnQocix0KSksdCs9Mjtmb3Ioby5pZFJhbmdlT2Zmc2V0PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCxvLmdseXBoSWRBcnJheT1bXTt0PG4rczspby5nbHlwaElkQXJyYXkucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gb30sZS5jbWFwLnBhcnNlNj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4uZmlyc3RDb2RlPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixuLmdseXBoSWRBcnJheT1bXTtmb3IodmFyIHM9MDtzPG87cysrKW4uZ2x5cGhJZEFycmF5LnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG59LGUuY21hcC5wYXJzZTEyPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mix0Kz0yLGEucmVhZFVpbnQocix0KSx0Kz00LGEucmVhZFVpbnQocix0KSx0Kz00O3ZhciBvPWEucmVhZFVpbnQocix0KTt0Kz00LG4uZ3JvdXBzPVtdO2Zvcih2YXIgcz0wO3M8bztzKyspe3ZhciBpPXQrMTIqcyxoPWEucmVhZFVpbnQocixpKzApLGQ9YS5yZWFkVWludChyLGkrNCksZj1hLnJlYWRVaW50KHIsaSs4KTtuLmdyb3Vwcy5wdXNoKFtoLGQsZl0pO31yZXR1cm4gbn0sZS5nbHlmPXt9LGUuZ2x5Zi5wYXJzZT1mdW5jdGlvbihyLGUsdCxhKXtmb3IodmFyIG49W10sbz0wO288YS5tYXhwLm51bUdseXBocztvKyspbi5wdXNoKG51bGwpO3JldHVybiBufSxlLmdseWYuX3BhcnNlR2x5Zj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXIuX2RhdGEsbz1lLl90YWJPZmZzZXQobixcImdseWZcIixyLl9vZmZzZXQpK3IubG9jYVt0XTtpZihyLmxvY2FbdF09PXIubG9jYVt0KzFdKXJldHVybiBudWxsO3ZhciBzPXt9O2lmKHMubm9jPWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNaW49YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueU1pbj1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWF4PWEucmVhZFNob3J0KG4sbyksbys9MixzLnlNYXg9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1pbj49cy54TWF4fHxzLnlNaW4+PXMueU1heClyZXR1cm4gbnVsbDtpZihzLm5vYz4wKXtzLmVuZFB0cz1bXTtmb3IodmFyIGk9MDtpPHMubm9jO2krKylzLmVuZFB0cy5wdXNoKGEucmVhZFVzaG9ydChuLG8pKSxvKz0yO3ZhciBoPWEucmVhZFVzaG9ydChuLG8pO2lmKG8rPTIsbi5sZW5ndGgtbzxoKXJldHVybiBudWxsO3MuaW5zdHJ1Y3Rpb25zPWEucmVhZEJ5dGVzKG4sbyxoKSxvKz1oO3ZhciBkPXMuZW5kUHRzW3Mubm9jLTFdKzE7cy5mbGFncz1bXTtmb3IoaT0wO2k8ZDtpKyspe3ZhciBmPW5bb107aWYobysrLHMuZmxhZ3MucHVzaChmKSwwIT0oOCZmKSl7dmFyIHU9bltvXTtvKys7Zm9yKHZhciBsPTA7bDx1O2wrKylzLmZsYWdzLnB1c2goZiksaSsrO319cy54cz1bXTtmb3IoaT0wO2k8ZDtpKyspe3ZhciB2PTAhPSgyJnMuZmxhZ3NbaV0pLGM9MCE9KDE2JnMuZmxhZ3NbaV0pO3Y/KHMueHMucHVzaChjP25bb106LW5bb10pLG8rKyk6Yz9zLnhzLnB1c2goMCk6KHMueHMucHVzaChhLnJlYWRTaG9ydChuLG8pKSxvKz0yKTt9cy55cz1bXTtmb3IoaT0wO2k8ZDtpKyspe3Y9MCE9KDQmcy5mbGFnc1tpXSksYz0wIT0oMzImcy5mbGFnc1tpXSk7dj8ocy55cy5wdXNoKGM/bltvXTotbltvXSksbysrKTpjP3MueXMucHVzaCgwKToocy55cy5wdXNoKGEucmVhZFNob3J0KG4sbykpLG8rPTIpO312YXIgcD0wLFU9MDtmb3IoaT0wO2k8ZDtpKyspcCs9cy54c1tpXSxVKz1zLnlzW2ldLHMueHNbaV09cCxzLnlzW2ldPVU7fWVsc2Uge3ZhciBnO3MucGFydHM9W107ZG97Zz1hLnJlYWRVc2hvcnQobixvKSxvKz0yO3ZhciBTPXttOnthOjEsYjowLGM6MCxkOjEsdHg6MCx0eTowfSxwMTotMSxwMjotMX07aWYocy5wYXJ0cy5wdXNoKFMpLFMuZ2x5cGhJbmRleD1hLnJlYWRVc2hvcnQobixvKSxvKz0yLDEmZyl7dmFyIG09YS5yZWFkU2hvcnQobixvKTtvKz0yO3ZhciBiPWEucmVhZFNob3J0KG4sbyk7bys9Mjt9ZWxzZSB7bT1hLnJlYWRJbnQ4KG4sbyk7bysrO2I9YS5yZWFkSW50OChuLG8pO28rKzt9MiZnPyhTLm0udHg9bSxTLm0udHk9Yik6KFMucDE9bSxTLnAyPWIpLDgmZz8oUy5tLmE9Uy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpOjY0Jmc/KFMubS5hPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKToxMjgmZyYmKFMubS5hPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5iPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5jPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKTt9d2hpbGUoMzImZyk7aWYoMjU2Jmcpe3ZhciB5PWEucmVhZFVzaG9ydChuLG8pO28rPTIscy5pbnN0cj1bXTtmb3IoaT0wO2k8eTtpKyspcy5pbnN0ci5wdXNoKG5bb10pLG8rKzt9fXJldHVybiBzfSxlLkdERUY9e30sZS5HREVGLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPXQ7dCs9NDt2YXIgcz1lLl9iaW4ucmVhZFVzaG9ydChyLHQpO3JldHVybiB7Z2x5cGhDbGFzc0RlZjowPT09cz9udWxsOmUuX2xjdGYucmVhZENsYXNzRGVmKHIsbytzKX19LGUuR1BPUz17fSxlLkdQT1MucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7cmV0dXJuIGUuX2xjdGYucGFyc2Uocix0LGEsbixlLkdQT1Muc3VidCl9LGUuR1BPUy5zdWJ0PWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPWEsaT17fTtpZihpLmZtdD1vLnJlYWRVc2hvcnQocixhKSxhKz0yLDE9PXR8fDI9PXR8fDM9PXR8fDc9PXR8fDg9PXQmJmkuZm10PD0yKXt2YXIgaD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixoK3MpO31pZigxPT10JiYxPT1pLmZtdCl7dmFyIGQ9by5yZWFkVXNob3J0KHIsYSk7YSs9MiwwIT1kJiYoaS5wb3M9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZCkpO31lbHNlIGlmKDI9PXQmJmkuZm10Pj0xJiZpLmZtdDw9Mil7ZD1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHU9ZS5fbGN0Zi5udW1PZk9uZXMoZCksbD1lLl9sY3RmLm51bU9mT25lcyhmKTtpZigxPT1pLmZtdCl7aS5wYWlyc2V0cz1bXTt2YXIgdj1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Zvcih2YXIgYz0wO2M8djtjKyspe3ZhciBwPXMrby5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgVT1vLnJlYWRVc2hvcnQocixwKTtwKz0yO2Zvcih2YXIgZz1bXSxTPTA7UzxVO1MrKyl7dmFyIG09by5yZWFkVXNob3J0KHIscCk7cCs9MiwwIT1kJiYoUD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIscCxkKSxwKz0yKnUpLDAhPWYmJih4PWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixwLGYpLHArPTIqbCksZy5wdXNoKHtnaWQyOm0sdmFsMTpQLHZhbDI6eH0pO31pLnBhaXJzZXRzLnB1c2goZyk7fX1pZigyPT1pLmZtdCl7dmFyIGI9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgeT1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBGPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIEM9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNsYXNzRGVmMT1lLl9sY3RmLnJlYWRDbGFzc0RlZihyLHMrYiksaS5jbGFzc0RlZjI9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK3kpLGkubWF0cml4PVtdO2ZvcihjPTA7YzxGO2MrKyl7dmFyIF89W107Zm9yKFM9MDtTPEM7UysrKXt2YXIgUD1udWxsLHg9bnVsbDswIT1kJiYoUD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSxkKSxhKz0yKnUpLDAhPWYmJih4PWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLGYpLGErPTIqbCksXy5wdXNoKHt2YWwxOlAsdmFsMjp4fSk7fWkubWF0cml4LnB1c2goXyk7fX19ZWxzZSBpZig0PT10JiYxPT1pLmZtdClpLm1hcmtDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGEpK3MpLGkuYmFzZUNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsby5yZWFkVXNob3J0KHIsYSsyKStzKSxpLm1hcmtDbGFzc0NvdW50PW8ucmVhZFVzaG9ydChyLGErNCksaS5tYXJrQXJyYXk9ZS5HUE9TLnJlYWRNYXJrQXJyYXkocixvLnJlYWRVc2hvcnQocixhKzYpK3MpLGkuYmFzZUFycmF5PWUuR1BPUy5yZWFkQmFzZUFycmF5KHIsby5yZWFkVXNob3J0KHIsYSs4KStzLGkubWFya0NsYXNzQ291bnQpO2Vsc2UgaWYoNj09dCYmMT09aS5mbXQpaS5tYXJrMUNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsby5yZWFkVXNob3J0KHIsYSkrcyksaS5tYXJrMkNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsby5yZWFkVXNob3J0KHIsYSsyKStzKSxpLm1hcmtDbGFzc0NvdW50PW8ucmVhZFVzaG9ydChyLGErNCksaS5tYXJrMUFycmF5PWUuR1BPUy5yZWFkTWFya0FycmF5KHIsby5yZWFkVXNob3J0KHIsYSs2KStzKSxpLm1hcmsyQXJyYXk9ZS5HUE9TLnJlYWRCYXNlQXJyYXkocixvLnJlYWRVc2hvcnQocixhKzgpK3MsaS5tYXJrQ2xhc3NDb3VudCk7ZWxzZSB7aWYoOT09dCYmMT09aS5mbXQpe3ZhciBJPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHc9by5yZWFkVWludChyLGEpO2lmKGErPTQsOT09bi5sdHlwZSluLmx0eXBlPUk7ZWxzZSBpZihuLmx0eXBlIT1JKXRocm93IFwiaW52YWxpZCBleHRlbnNpb24gc3Vic3RpdHV0aW9uXCI7cmV0dXJuIGUuR1BPUy5zdWJ0KHIsbi5sdHlwZSxzK3cpfWNvbnNvbGUuZGVidWcoXCJ1bnN1cHBvcnRlZCBHUE9TIHRhYmxlIExvb2t1cFR5cGVcIix0LFwiZm9ybWF0XCIsaS5mbXQpO31yZXR1cm4gaX0sZS5HUE9TLnJlYWRWYWx1ZVJlY29yZD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W107cmV0dXJuIG8ucHVzaCgxJmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz0xJmE/MjowLG8ucHVzaCgyJmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz0yJmE/MjowLG8ucHVzaCg0JmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz00JmE/MjowLG8ucHVzaCg4JmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz04JmE/MjowLG99LGUuR1BPUy5yZWFkQmFzZUFycmF5PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXSxzPXQsaT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe2Zvcih2YXIgZD1bXSxmPTA7ZjxhO2YrKylkLnB1c2goZS5HUE9TLnJlYWRBbmNob3JSZWNvcmQocixzK24ucmVhZFVzaG9ydChyLHQpKSksdCs9MjtvLnB1c2goZCk7fXJldHVybiBvfSxlLkdQT1MucmVhZE1hcmtBcnJheT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPVtdLG89dCxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9ZS5HUE9TLnJlYWRBbmNob3JSZWNvcmQocixhLnJlYWRVc2hvcnQocix0KzIpK28pO2gubWFya0NsYXNzPWEucmVhZFVzaG9ydChyLHQpLG4ucHVzaChoKSx0Kz00O31yZXR1cm4gbn0sZS5HUE9TLnJlYWRBbmNob3JSZWNvcmQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtyZXR1cm4gbi5mbXQ9YS5yZWFkVXNob3J0KHIsdCksbi54PWEucmVhZFNob3J0KHIsdCsyKSxuLnk9YS5yZWFkU2hvcnQocix0KzQpLG59LGUuR1NVQj17fSxlLkdTVUIucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7cmV0dXJuIGUuX2xjdGYucGFyc2Uocix0LGEsbixlLkdTVUIuc3VidCl9LGUuR1NVQi5zdWJ0PWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPWEsaT17fTtpZihpLmZtdD1vLnJlYWRVc2hvcnQocixhKSxhKz0yLDEhPXQmJjIhPXQmJjQhPXQmJjUhPXQmJjYhPXQpcmV0dXJuIG51bGw7aWYoMT09dHx8Mj09dHx8ND09dHx8NT09dCYmaS5mbXQ8PTJ8fDY9PXQmJmkuZm10PD0yKXt2YXIgaD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixzK2gpO31pZigxPT10JiZpLmZtdD49MSYmaS5mbXQ8PTIpe2lmKDE9PWkuZm10KWkuZGVsdGE9by5yZWFkU2hvcnQocixhKSxhKz0yO2Vsc2UgaWYoMj09aS5mbXQpe3ZhciBkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5uZXdnPW8ucmVhZFVzaG9ydHMocixhLGQpLGErPTIqaS5uZXdnLmxlbmd0aDt9fWVsc2UgaWYoMj09dCYmMT09aS5mbXQpe2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLnNlcXM9W107Zm9yKHZhciBmPTA7ZjxkO2YrKyl7dmFyIHU9by5yZWFkVXNob3J0KHIsYSkrczthKz0yO3ZhciBsPW8ucmVhZFVzaG9ydChyLHUpO2kuc2Vxcy5wdXNoKG8ucmVhZFVzaG9ydHMocix1KzIsbCkpO319ZWxzZSBpZig0PT10KXtpLnZhbHM9W107ZD1vLnJlYWRVc2hvcnQocixhKTthKz0yO2ZvcihmPTA7ZjxkO2YrKyl7dmFyIHY9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLnZhbHMucHVzaChlLkdTVUIucmVhZExpZ2F0dXJlU2V0KHIscyt2KSk7fX1lbHNlIGlmKDU9PXQmJjI9PWkuZm10KXtpZigyPT1pLmZtdCl7dmFyIGM9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNEZWY9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK2MpLGkuc2NzZXQ9W107dmFyIHA9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IoZj0wO2Y8cDtmKyspe3ZhciBVPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5zY3NldC5wdXNoKDA9PVU/bnVsbDplLkdTVUIucmVhZFN1YkNsYXNzU2V0KHIscytVKSk7fX19ZWxzZSBpZig2PT10JiYzPT1pLmZtdCl7aWYoMz09aS5mbXQpe2ZvcihmPTA7ZjwzO2YrKyl7ZD1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Zvcih2YXIgZz1bXSxTPTA7UzxkO1MrKylnLnB1c2goZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixzK28ucmVhZFVzaG9ydChyLGErMipTKSkpO2ErPTIqZCwwPT1mJiYoaS5iYWNrQ3ZnPWcpLDE9PWYmJihpLmlucHRDdmc9ZyksMj09ZiYmKGkuYWhlZEN2Zz1nKTt9ZD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkubG9va3VwUmVjPWUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzKHIsYSxkKTt9fWVsc2Uge2lmKDc9PXQmJjE9PWkuZm10KXt2YXIgbT1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBiPW8ucmVhZFVpbnQocixhKTtpZihhKz00LDk9PW4ubHR5cGUpbi5sdHlwZT1tO2Vsc2UgaWYobi5sdHlwZSE9bSl0aHJvdyBcImludmFsaWQgZXh0ZW5zaW9uIHN1YnN0aXR1dGlvblwiO3JldHVybiBlLkdTVUIuc3VidChyLG4ubHR5cGUscytiKX1jb25zb2xlLmRlYnVnKFwidW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSBMb29rdXBUeXBlXCIsdCxcImZvcm1hdFwiLGkuZm10KTt9cmV0dXJuIGl9LGUuR1NVQi5yZWFkU3ViQ2xhc3NTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4ucmVhZFVzaG9ydCxuPXQsbz1bXSxzPWEocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZFN1YkNsYXNzUnVsZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRTdWJDbGFzc1J1bGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4ucmVhZFVzaG9ydCxuPXt9LG89YShyLHQpLHM9YShyLHQrPTIpO3QrPTIsbi5pbnB1dD1bXTtmb3IodmFyIGk9MDtpPG8tMTtpKyspbi5pbnB1dC5wdXNoKGEocix0KSksdCs9MjtyZXR1cm4gbi5zdWJzdExvb2t1cFJlY29yZHM9ZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMocix0LHMpLG59LGUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLnJlYWRVc2hvcnQsbz1bXSxzPTA7czxhO3MrKylvLnB1c2gobihyLHQpLG4ocix0KzIpKSx0Kz00O3JldHVybiBvfSxlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGU9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGE9ZS5fYmluLG49e30sbz1bXCJiYWNrdHJhY2tcIixcImlucHV0XCIsXCJsb29rYWhlYWRcIl0scz0wO3M8by5sZW5ndGg7cysrKXt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLDE9PXMmJmktLSxuW29bc11dPWEucmVhZFVzaG9ydHMocix0LGkpLHQrPTIqbltvW3NdXS5sZW5ndGg7fWk9YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsbi5zdWJzdD1hLnJlYWRVc2hvcnRzKHIsdCwyKmkpLHQrPTIqbi5zdWJzdC5sZW5ndGgsbn0sZS5HU1VCLnJlYWRMaWdhdHVyZVNldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz1bXSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRMaWdhdHVyZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRMaWdhdHVyZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXtjaGFpbjpbXX07bi5uZ2x5cGg9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgcz0wO3M8by0xO3MrKyluLmNoYWluLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG59LGUuaGVhZD17fSxlLmhlYWQucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBuLnJlYWRGaXhlZChyLHQpLHQrPTQsby5mb250UmV2aXNpb249bi5yZWFkRml4ZWQocix0KSx0Kz00LG4ucmVhZFVpbnQocix0KSx0Kz00LG4ucmVhZFVpbnQocix0KSx0Kz00LG8uZmxhZ3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLnVuaXRzUGVyRW09bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmNyZWF0ZWQ9bi5yZWFkVWludDY0KHIsdCksdCs9OCxvLm1vZGlmaWVkPW4ucmVhZFVpbnQ2NChyLHQpLHQrPTgsby54TWluPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnlNaW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueE1heD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby55TWF4PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm1hY1N0eWxlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5sb3dlc3RSZWNQUEVNPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5mb250RGlyZWN0aW9uSGludD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5pbmRleFRvTG9jRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmdseXBoRGF0YUZvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsb30sZS5oaGVhPXt9LGUuaGhlYS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLmFzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmRlc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5saW5lR2FwPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmFkdmFuY2VXaWR0aE1heD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWluTGVmdFNpZGVCZWFyaW5nPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm1pblJpZ2h0U2lkZUJlYXJpbmc9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueE1heEV4dGVudD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldFNsb3BlUmlzZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldFNsb3BlUnVuPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0T2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9Mix0Kz04LG8ubWV0cmljRGF0YUZvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5udW1iZXJPZkhNZXRyaWNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsb30sZS5obXR4PXt9LGUuaG10eC5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXtmb3IodmFyIG89ZS5fYmluLHM9e2FXaWR0aDpbXSxsc0JlYXJpbmc6W119LGk9MCxoPTAsZD0wO2Q8bi5tYXhwLm51bUdseXBocztkKyspZDxuLmhoZWEubnVtYmVyT2ZITWV0cmljcyYmKGk9by5yZWFkVXNob3J0KHIsdCksdCs9MixoPW8ucmVhZFNob3J0KHIsdCksdCs9Mikscy5hV2lkdGgucHVzaChpKSxzLmxzQmVhcmluZy5wdXNoKGgpO3JldHVybiBzfSxlLmtlcm49e30sZS5rZXJuLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPW8ucmVhZFVzaG9ydChyLHQpO2lmKHQrPTIsMT09cylyZXR1cm4gZS5rZXJuLnBhcnNlVjEocix0LTIsYSxuKTt2YXIgaT1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD17Z2x5cGgxOltdLHJ2YWw6W119LGQ9MDtkPGk7ZCsrKXt0Kz0yO2E9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PWY+Pj44O2lmKDAhPSh1Jj0xNSkpdGhyb3cgXCJ1bmtub3duIGtlcm4gdGFibGUgZm9ybWF0OiBcIit1O3Q9ZS5rZXJuLnJlYWRGb3JtYXQwKHIsdCxoKTt9cmV0dXJuIGh9LGUua2Vybi5wYXJzZVYxPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbjtvLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIHM9by5yZWFkVWludChyLHQpO3QrPTQ7Zm9yKHZhciBpPXtnbHlwaDE6W10scnZhbDpbXX0saD0wO2g8cztoKyspe28ucmVhZFVpbnQocix0KSx0Kz00O3ZhciBkPW8ucmVhZFVzaG9ydChyLHQpO3QrPTIsby5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgZj1kPj4+ODtpZigwIT0oZiY9MTUpKXRocm93IFwidW5rbm93biBrZXJuIHRhYmxlIGZvcm1hdDogXCIrZjt0PWUua2Vybi5yZWFkRm9ybWF0MChyLHQsaSk7fXJldHVybiBpfSxlLmtlcm4ucmVhZEZvcm1hdDA9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPS0xLHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9bi5yZWFkU2hvcnQocix0KTt0Kz0yLGghPW8mJihhLmdseXBoMS5wdXNoKGgpLGEucnZhbC5wdXNoKHtnbHlwaDI6W10sdmFsczpbXX0pKTt2YXIgdT1hLnJ2YWxbYS5ydmFsLmxlbmd0aC0xXTt1LmdseXBoMi5wdXNoKGQpLHUudmFscy5wdXNoKGYpLG89aDt9cmV0dXJuIHR9LGUubG9jYT17fSxlLmxvY2EucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluLHM9W10saT1uLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdCxoPW4ubWF4cC5udW1HbHlwaHMrMTtpZigwPT1pKWZvcih2YXIgZD0wO2Q8aDtkKyspcy5wdXNoKG8ucmVhZFVzaG9ydChyLHQrKGQ8PDEpKTw8MSk7aWYoMT09aSlmb3IoZD0wO2Q8aDtkKyspcy5wdXNoKG8ucmVhZFVpbnQocix0KyhkPDwyKSkpO3JldHVybiBzfSxlLm1heHA9e30sZS5tYXhwLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fSxzPW4ucmVhZFVpbnQocix0KTtyZXR1cm4gdCs9NCxvLm51bUdseXBocz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLDY1NTM2PT1zJiYoby5tYXhQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbnRvdXJzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb3NpdGVQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvc2l0ZUNvbnRvdXJzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhab25lcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4VHdpbGlnaHRQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFN0b3JhZ2U9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heEZ1bmN0aW9uRGVmcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4SW5zdHJ1Y3Rpb25EZWZzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTdGFja0VsZW1lbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTaXplT2ZJbnN0cnVjdGlvbnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvbmVudEVsZW1lbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb25lbnREZXB0aD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yKSxvfSxlLm5hbWU9e30sZS5uYW1lLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtuLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5yZWFkVXNob3J0KHIsdCk7Zm9yKHZhciBpLGg9W1wiY29weXJpZ2h0XCIsXCJmb250RmFtaWx5XCIsXCJmb250U3ViZmFtaWx5XCIsXCJJRFwiLFwiZnVsbE5hbWVcIixcInZlcnNpb25cIixcInBvc3RTY3JpcHROYW1lXCIsXCJ0cmFkZW1hcmtcIixcIm1hbnVmYWN0dXJlclwiLFwiZGVzaWduZXJcIixcImRlc2NyaXB0aW9uXCIsXCJ1cmxWZW5kb3JcIixcInVybERlc2lnbmVyXCIsXCJsaWNlbmNlXCIsXCJsaWNlbmNlVVJMXCIsXCItLS1cIixcInR5cG9GYW1pbHlOYW1lXCIsXCJ0eXBvU3ViZmFtaWx5TmFtZVwiLFwiY29tcGF0aWJsZUZ1bGxcIixcInNhbXBsZVRleHRcIixcInBvc3RTY3JpcHRDSURcIixcInd3c0ZhbWlseU5hbWVcIixcInd3c1N1YmZhbWlseU5hbWVcIixcImxpZ2h0UGFsZXR0ZVwiLFwiZGFya1BhbGV0dGVcIl0sZD10Kz0yLGY9MDtmPHM7ZisrKXt2YXIgdT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBsPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgYz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBwPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIFU9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZyxTPWhbY10sbT1kKzEyKnMrVTtpZigwPT11KWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDM9PXUmJjA9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMD09bClnPW4ucmVhZEFTQ0lJKHIsbSxwKTtlbHNlIGlmKDE9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMz09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSB7aWYoMSE9dSl0aHJvdyBcInVua25vd24gZW5jb2RpbmcgXCIrbCtcIiwgcGxhdGZvcm1JRDogXCIrdTtnPW4ucmVhZEFTQ0lJKHIsbSxwKSxjb25zb2xlLmRlYnVnKFwicmVhZGluZyB1bmtub3duIE1BQyBlbmNvZGluZyBcIitsK1wiIGFzIEFTQ0lJXCIpO312YXIgYj1cInBcIit1K1wiLFwiK3YudG9TdHJpbmcoMTYpO251bGw9PW9bYl0mJihvW2JdPXt9KSxvW2JdW3ZvaWQgMCE9PVM/UzpjXT1nLG9bYl0uX2xhbmc9djt9Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMTAzMz09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYwPT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjMwODQ9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSlyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbyl7aT15O2JyZWFrfXJldHVybiBjb25zb2xlLmRlYnVnKFwicmV0dXJuaW5nIG5hbWUgdGFibGUgd2l0aCBsYW5ndWFnZUlEIFwiK29baV0uX2xhbmcpLG9baV19LGVbXCJPUy8yXCJdPXt9LGVbXCJPUy8yXCJdLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIG89e307aWYoMD09billW1wiT1MvMlwiXS52ZXJzaW9uMChyLHQsbyk7ZWxzZSBpZigxPT1uKWVbXCJPUy8yXCJdLnZlcnNpb24xKHIsdCxvKTtlbHNlIGlmKDI9PW58fDM9PW58fDQ9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjIocix0LG8pO2Vsc2Uge2lmKDUhPW4pdGhyb3cgXCJ1bmtub3duIE9TLzIgdGFibGUgdmVyc2lvbjogXCIrbjtlW1wiT1MvMlwiXS52ZXJzaW9uNShyLHQsbyk7fXJldHVybiBvfSxlW1wiT1MvMlwiXS52ZXJzaW9uMD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiBhLnhBdmdDaGFyV2lkdGg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNXZWlnaHRDbGFzcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNXaWR0aENsYXNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5mc1R5cGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRYU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WVNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFhPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFlPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WVNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRZT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdHJpa2VvdXRTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdHJpa2VvdXRQb3NpdGlvbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zRmFtaWx5Q2xhc3M9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEucGFub3NlPW4ucmVhZEJ5dGVzKHIsdCwxMCksdCs9MTAsYS51bFVuaWNvZGVSYW5nZTE9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTI9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTM9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTQ9bi5yZWFkVWludChyLHQpLHQrPTQsYS5hY2hWZW5kSUQ9W24ucmVhZEludDgocix0KSxuLnJlYWRJbnQ4KHIsdCsxKSxuLnJlYWRJbnQ4KHIsdCsyKSxuLnJlYWRJbnQ4KHIsdCszKV0sdCs9NCxhLmZzU2VsZWN0aW9uPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0ZpcnN0Q2hhckluZGV4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0xhc3RDaGFySW5kZXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnNUeXBvQXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc1R5cG9EZXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc1R5cG9MaW5lR2FwPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzV2luQXNjZW50PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1dpbkRlc2NlbnQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZVtcIk9TLzJcIl0udmVyc2lvbjE9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMChyLHQsYSksYS51bENvZGVQYWdlUmFuZ2UxPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxDb2RlUGFnZVJhbmdlMj1uLnJlYWRVaW50KHIsdCksdCs9NH0sZVtcIk9TLzJcIl0udmVyc2lvbjI9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMShyLHQsYSksYS5zeEhlaWdodD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zQ2FwSGVpZ2h0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzRGVmYXVsdD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNCcmVhaz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNNYXhDb250ZXh0PW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGVbXCJPUy8yXCJdLnZlcnNpb241PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjIocix0LGEpLGEudXNMb3dlck9wdGljYWxQb2ludFNpemU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzVXBwZXJPcHRpY2FsUG9pbnRTaXplPW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGUucG9zdD17fSxlLnBvc3QucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBvLnZlcnNpb249bi5yZWFkRml4ZWQocix0KSx0Kz00LG8uaXRhbGljQW5nbGU9bi5yZWFkRml4ZWQocix0KSx0Kz00LG8udW5kZXJsaW5lUG9zaXRpb249bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8udW5kZXJsaW5lVGhpY2tuZXNzPW4ucmVhZFNob3J0KHIsdCksdCs9MixvfSxudWxsPT1lJiYoZT17fSksbnVsbD09ZS5VJiYoZS5VPXt9KSxlLlUuY29kZVRvR2x5cGg9ZnVuY3Rpb24ocixlKXt2YXIgdD1yLmNtYXAsYT0tMTtpZihudWxsIT10LnAwZTQ/YT10LnAwZTQ6bnVsbCE9dC5wM2UxP2E9dC5wM2UxOm51bGwhPXQucDFlMD9hPXQucDFlMDpudWxsIT10LnAwZTMmJihhPXQucDBlMyksLTE9PWEpdGhyb3cgXCJubyBmYW1pbGlhciBwbGF0Zm9ybSBhbmQgZW5jb2RpbmchXCI7dmFyIG49dC50YWJsZXNbYV07aWYoMD09bi5mb3JtYXQpcmV0dXJuIGU+PW4ubWFwLmxlbmd0aD8wOm4ubWFwW2VdO2lmKDQ9PW4uZm9ybWF0KXtmb3IodmFyIG89LTEscz0wO3M8bi5lbmRDb3VudC5sZW5ndGg7cysrKWlmKGU8PW4uZW5kQ291bnRbc10pe289czticmVha31pZigtMT09bylyZXR1cm4gMDtpZihuLnN0YXJ0Q291bnRbb10+ZSlyZXR1cm4gMDtyZXR1cm4gNjU1MzUmKDAhPW4uaWRSYW5nZU9mZnNldFtvXT9uLmdseXBoSWRBcnJheVtlLW4uc3RhcnRDb3VudFtvXSsobi5pZFJhbmdlT2Zmc2V0W29dPj4xKS0obi5pZFJhbmdlT2Zmc2V0Lmxlbmd0aC1vKV06ZStuLmlkRGVsdGFbb10pfWlmKDEyPT1uLmZvcm1hdCl7aWYoZT5uLmdyb3Vwc1tuLmdyb3Vwcy5sZW5ndGgtMV1bMV0pcmV0dXJuIDA7Zm9yKHM9MDtzPG4uZ3JvdXBzLmxlbmd0aDtzKyspe3ZhciBpPW4uZ3JvdXBzW3NdO2lmKGlbMF08PWUmJmU8PWlbMV0pcmV0dXJuIGlbMl0rKGUtaVswXSl9cmV0dXJuIDB9dGhyb3cgXCJ1bmtub3duIGNtYXAgdGFibGUgZm9ybWF0IFwiK24uZm9ybWF0fSxlLlUuZ2x5cGhUb1BhdGg9ZnVuY3Rpb24ocix0KXt2YXIgYT17Y21kczpbXSxjcmRzOltdfTtpZihyLlNWRyYmci5TVkcuZW50cmllc1t0XSl7dmFyIG49ci5TVkcuZW50cmllc1t0XTtyZXR1cm4gbnVsbD09bj9hOihcInN0cmluZ1wiPT10eXBlb2YgbiYmKG49ZS5TVkcudG9QYXRoKG4pLHIuU1ZHLmVudHJpZXNbdF09biksbil9aWYoci5DRkYpe3ZhciBvPXt4OjAseTowLHN0YWNrOltdLG5TdGVtczowLGhhdmVXaWR0aDohMSx3aWR0aDpyLkNGRi5Qcml2YXRlP3IuQ0ZGLlByaXZhdGUuZGVmYXVsdFdpZHRoWDowLG9wZW46ITF9LHM9ci5DRkYsaT1yLkNGRi5Qcml2YXRlO2lmKHMuUk9TKXtmb3IodmFyIGg9MDtzLkZEU2VsZWN0W2grMl08PXQ7KWgrPTI7aT1zLkZEQXJyYXlbcy5GRFNlbGVjdFtoKzFdXS5Qcml2YXRlO31lLlUuX2RyYXdDRkYoci5DRkYuQ2hhclN0cmluZ3NbdF0sbyxzLGksYSk7fWVsc2Ugci5nbHlmJiZlLlUuX2RyYXdHbHlmKHQscixhKTtyZXR1cm4gYX0sZS5VLl9kcmF3R2x5Zj1mdW5jdGlvbihyLHQsYSl7dmFyIG49dC5nbHlmW3JdO251bGw9PW4mJihuPXQuZ2x5ZltyXT1lLmdseWYuX3BhcnNlR2x5Zih0LHIpKSxudWxsIT1uJiYobi5ub2M+LTE/ZS5VLl9zaW1wbGVHbHlwaChuLGEpOmUuVS5fY29tcG9HbHlwaChuLHQsYSkpO30sZS5VLl9zaW1wbGVHbHlwaD1mdW5jdGlvbihyLHQpe2Zvcih2YXIgYT0wO2E8ci5ub2M7YSsrKXtmb3IodmFyIG49MD09YT8wOnIuZW5kUHRzW2EtMV0rMSxvPXIuZW5kUHRzW2FdLHM9bjtzPD1vO3MrKyl7dmFyIGk9cz09bj9vOnMtMSxoPXM9PW8/bjpzKzEsZD0xJnIuZmxhZ3Nbc10sZj0xJnIuZmxhZ3NbaV0sdT0xJnIuZmxhZ3NbaF0sbD1yLnhzW3NdLHY9ci55c1tzXTtpZihzPT1uKWlmKGQpe2lmKCFmKXtlLlUuUC5tb3ZlVG8odCxsLHYpO2NvbnRpbnVlfWUuVS5QLm1vdmVUbyh0LHIueHNbaV0sci55c1tpXSk7fWVsc2UgZj9lLlUuUC5tb3ZlVG8odCxyLnhzW2ldLHIueXNbaV0pOmUuVS5QLm1vdmVUbyh0LChyLnhzW2ldK2wpLzIsKHIueXNbaV0rdikvMik7ZD9mJiZlLlUuUC5saW5lVG8odCxsLHYpOnU/ZS5VLlAucWN1cnZlVG8odCxsLHYsci54c1toXSxyLnlzW2hdKTplLlUuUC5xY3VydmVUbyh0LGwsdiwobCtyLnhzW2hdKS8yLCh2K3IueXNbaF0pLzIpO31lLlUuUC5jbG9zZVBhdGgodCk7fX0sZS5VLl9jb21wb0dseXBoPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49MDtuPHIucGFydHMubGVuZ3RoO24rKyl7dmFyIG89e2NtZHM6W10sY3JkczpbXX0scz1yLnBhcnRzW25dO2UuVS5fZHJhd0dseWYocy5nbHlwaEluZGV4LHQsbyk7Zm9yKHZhciBpPXMubSxoPTA7aDxvLmNyZHMubGVuZ3RoO2grPTIpe3ZhciBkPW8uY3Jkc1toXSxmPW8uY3Jkc1toKzFdO2EuY3Jkcy5wdXNoKGQqaS5hK2YqaS5iK2kudHgpLGEuY3Jkcy5wdXNoKGQqaS5jK2YqaS5kK2kudHkpO31mb3IoaD0wO2g8by5jbWRzLmxlbmd0aDtoKyspYS5jbWRzLnB1c2goby5jbWRzW2hdKTt9fSxlLlUuX2dldEdseXBoQ2xhc3M9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9sY3RmLmdldEludGVydmFsKHQscik7cmV0dXJuIC0xPT1hPzA6dFthKzJdfSxlLlUuX2FwcGx5U3Vicz1mdW5jdGlvbihyLHQsYSxuKXtmb3IodmFyIG89ci5sZW5ndGgtdC0xLHM9MDtzPGEudGFicy5sZW5ndGg7cysrKWlmKG51bGwhPWEudGFic1tzXSl7dmFyIGksaD1hLnRhYnNbc107aWYoIWguY292ZXJhZ2V8fC0xIT0oaT1lLl9sY3RmLmNvdmVyYWdlSW5kZXgoaC5jb3ZlcmFnZSxyW3RdKSkpaWYoMT09YS5sdHlwZSlyW3RdLDE9PWguZm10P3JbdF09clt0XStoLmRlbHRhOnJbdF09aC5uZXdnW2ldO2Vsc2UgaWYoND09YS5sdHlwZSlmb3IodmFyIGQ9aC52YWxzW2ldLGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIHU9ZFtmXSxsPXUuY2hhaW4ubGVuZ3RoO2lmKCEobD5vKSl7Zm9yKHZhciB2PSEwLGM9MCxwPTA7cDxsO3ArKyl7Zm9yKDstMT09clt0K2MrKDErcCldOyljKys7dS5jaGFpbltwXSE9clt0K2MrKDErcCldJiYodj0hMSk7fWlmKHYpe3JbdF09dS5uZ2x5cGg7Zm9yKHA9MDtwPGwrYztwKyspclt0K3ArMV09LTE7YnJlYWt9fX1lbHNlIGlmKDU9PWEubHR5cGUmJjI9PWguZm10KWZvcih2YXIgVT1lLl9sY3RmLmdldEludGVydmFsKGguY0RlZixyW3RdKSxnPWguY0RlZltVKzJdLFM9aC5zY3NldFtnXSxtPTA7bTxTLmxlbmd0aDttKyspe3ZhciBiPVNbbV0seT1iLmlucHV0O2lmKCEoeS5sZW5ndGg+bykpe2Zvcih2PSEwLHA9MDtwPHkubGVuZ3RoO3ArKyl7dmFyIEY9ZS5fbGN0Zi5nZXRJbnRlcnZhbChoLmNEZWYsclt0KzErcF0pO2lmKC0xPT1VJiZoLmNEZWZbRisyXSE9eVtwXSl7dj0hMTticmVha319aWYodil7dmFyIEM9Yi5zdWJzdExvb2t1cFJlY29yZHM7Zm9yKGY9MDtmPEMubGVuZ3RoO2YrPTIpQ1tmXSxDW2YrMV07fX19ZWxzZSBpZig2PT1hLmx0eXBlJiYzPT1oLmZtdCl7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguYmFja0N2Zyx0LWguYmFja0N2Zy5sZW5ndGgpKWNvbnRpbnVlO2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmlucHRDdmcsdCkpY29udGludWU7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguYWhlZEN2Zyx0K2guaW5wdEN2Zy5sZW5ndGgpKWNvbnRpbnVlO3ZhciBfPWgubG9va3VwUmVjO2ZvcihtPTA7bTxfLmxlbmd0aDttKz0yKXtVPV9bbV07dmFyIFA9bltfW20rMV1dO2UuVS5fYXBwbHlTdWJzKHIsdCtVLFAsbik7fX19fSxlLlUuX2dsc0NvdmVyZWQ9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXtpZigtMT09ZS5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRbbl0sclthK25dKSlyZXR1cm4gITF9cmV0dXJuICEwfSxlLlUuZ2x5cGhzVG9QYXRoPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49e2NtZHM6W10sY3JkczpbXX0sbz0wLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIGk9dFtzXTtpZigtMSE9aSl7Zm9yKHZhciBoPXM8dC5sZW5ndGgtMSYmLTEhPXRbcysxXT90W3MrMV06MCxkPWUuVS5nbHlwaFRvUGF0aChyLGkpLGY9MDtmPGQuY3Jkcy5sZW5ndGg7Zis9MiluLmNyZHMucHVzaChkLmNyZHNbZl0rbyksbi5jcmRzLnB1c2goZC5jcmRzW2YrMV0pO2EmJm4uY21kcy5wdXNoKGEpO2ZvcihmPTA7ZjxkLmNtZHMubGVuZ3RoO2YrKyluLmNtZHMucHVzaChkLmNtZHNbZl0pO2EmJm4uY21kcy5wdXNoKFwiWFwiKSxvKz1yLmhtdHguYVdpZHRoW2ldLHM8dC5sZW5ndGgtMSYmKG8rPWUuVS5nZXRQYWlyQWRqdXN0bWVudChyLGksaCkpO319cmV0dXJuIG59LGUuVS5QPXt9LGUuVS5QLm1vdmVUbz1mdW5jdGlvbihyLGUsdCl7ci5jbWRzLnB1c2goXCJNXCIpLHIuY3Jkcy5wdXNoKGUsdCk7fSxlLlUuUC5saW5lVG89ZnVuY3Rpb24ocixlLHQpe3IuY21kcy5wdXNoKFwiTFwiKSxyLmNyZHMucHVzaChlLHQpO30sZS5VLlAuY3VydmVUbz1mdW5jdGlvbihyLGUsdCxhLG4sbyxzKXtyLmNtZHMucHVzaChcIkNcIiksci5jcmRzLnB1c2goZSx0LGEsbixvLHMpO30sZS5VLlAucWN1cnZlVG89ZnVuY3Rpb24ocixlLHQsYSxuKXtyLmNtZHMucHVzaChcIlFcIiksci5jcmRzLnB1c2goZSx0LGEsbik7fSxlLlUuUC5jbG9zZVBhdGg9ZnVuY3Rpb24ocil7ci5jbWRzLnB1c2goXCJaXCIpO30sZS5VLl9kcmF3Q0ZGPWZ1bmN0aW9uKHIsdCxhLG4sbyl7Zm9yKHZhciBzPXQuc3RhY2ssaT10Lm5TdGVtcyxoPXQuaGF2ZVdpZHRoLGQ9dC53aWR0aCxmPXQub3Blbix1PTAsbD10Lngsdj10LnksYz0wLHA9MCxVPTAsZz0wLFM9MCxtPTAsYj0wLHk9MCxGPTAsQz0wLF89e3ZhbDowLHNpemU6MH07dTxyLmxlbmd0aDspe2UuQ0ZGLmdldENoYXJTdHJpbmcocix1LF8pO3ZhciBQPV8udmFsO2lmKHUrPV8uc2l6ZSxcIm8xXCI9PVB8fFwibzE4XCI9PVApcy5sZW5ndGglMiE9MCYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMDtlbHNlIGlmKFwibzNcIj09UHx8XCJvMjNcIj09UCl7cy5sZW5ndGglMiE9MCYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMDt9ZWxzZSBpZihcIm80XCI9PVApcy5sZW5ndGg+MSYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksZiYmZS5VLlAuY2xvc2VQYXRoKG8pLHYrPXMucG9wKCksZS5VLlAubW92ZVRvKG8sbCx2KSxmPSEwO2Vsc2UgaWYoXCJvNVwiPT1QKWZvcig7cy5sZW5ndGg+MDspbCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpO2Vsc2UgaWYoXCJvNlwiPT1QfHxcIm83XCI9PVApZm9yKHZhciB4PXMubGVuZ3RoLEk9XCJvNlwiPT1QLHc9MDt3PHg7dysrKXt2YXIgaz1zLnNoaWZ0KCk7ST9sKz1rOnYrPWssST0hSSxlLlUuUC5saW5lVG8obyxsLHYpO31lbHNlIGlmKFwibzhcIj09UHx8XCJvMjRcIj09UCl7eD1zLmxlbmd0aDtmb3IodmFyIEc9MDtHKzY8PXg7KWM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdiksRys9NjtcIm8yNFwiPT1QJiYobCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpKTt9ZWxzZSB7aWYoXCJvMTFcIj09UClicmVhaztpZihcIm8xMjM0XCI9PVB8fFwibzEyMzVcIj09UHx8XCJvMTIzNlwiPT1QfHxcIm8xMjM3XCI9PVApXCJvMTIzNFwiPT1QJiYocD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxDPWc9cCtzLnNoaWZ0KCksbT1nLHk9dixsPShiPShTPShGPVUrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzNVwiPT1QJiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxGPVUrcy5zaGlmdCgpLEM9ZytzLnNoaWZ0KCksUz1GK3Muc2hpZnQoKSxtPUMrcy5zaGlmdCgpLGI9UytzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxsPWIrcy5zaGlmdCgpLHY9eStzLnNoaWZ0KCkscy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzNlwiPT1QJiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksQz1nPXArcy5zaGlmdCgpLG09ZyxiPShTPShGPVUrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLGw9YitzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixDKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM3XCI9PVAmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLEY9VStzLnNoaWZ0KCksQz1nK3Muc2hpZnQoKSxTPUYrcy5zaGlmdCgpLG09QytzLnNoaWZ0KCksYj1TK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLE1hdGguYWJzKGItbCk+TWF0aC5hYnMoeS12KT9sPWIrcy5zaGlmdCgpOnY9eStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixDKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKTtlbHNlIGlmKFwibzE0XCI9PVApe2lmKHMubGVuZ3RoPjAmJiFoJiYoZD1zLnNoaWZ0KCkrYS5ub21pbmFsV2lkdGhYLGg9ITApLDQ9PXMubGVuZ3RoKXt2YXIgTz1zLnNoaWZ0KCksVD1zLnNoaWZ0KCksRD1zLnNoaWZ0KCksQj1zLnNoaWZ0KCksQT1lLkNGRi5nbHlwaEJ5U0UoYSxEKSxSPWUuQ0ZGLmdseXBoQnlTRShhLEIpO2UuVS5fZHJhd0NGRihhLkNoYXJTdHJpbmdzW0FdLHQsYSxuLG8pLHQueD1PLHQueT1ULGUuVS5fZHJhd0NGRihhLkNoYXJTdHJpbmdzW1JdLHQsYSxuLG8pO31mJiYoZS5VLlAuY2xvc2VQYXRoKG8pLGY9ITEpO31lbHNlIGlmKFwibzE5XCI9PVB8fFwibzIwXCI9PVApe3MubGVuZ3RoJTIhPTAmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITAsdSs9aSs3Pj4zO31lbHNlIGlmKFwibzIxXCI9PVApcy5sZW5ndGg+MiYmIWgmJihkPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksdis9cy5wb3AoKSxsKz1zLnBvcCgpLGYmJmUuVS5QLmNsb3NlUGF0aChvKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGY9ITA7ZWxzZSBpZihcIm8yMlwiPT1QKXMubGVuZ3RoPjEmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLGwrPXMucG9wKCksZiYmZS5VLlAuY2xvc2VQYXRoKG8pLGUuVS5QLm1vdmVUbyhvLGwsdiksZj0hMDtlbHNlIGlmKFwibzI1XCI9PVApe2Zvcig7cy5sZW5ndGg+NjspbCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpO2M9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7fWVsc2UgaWYoXCJvMjZcIj09UClmb3Iocy5sZW5ndGglMiYmKGwrPXMuc2hpZnQoKSk7cy5sZW5ndGg+MDspYz1sLHA9ditzLnNoaWZ0KCksbD1VPWMrcy5zaGlmdCgpLHY9KGc9cCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO2Vsc2UgaWYoXCJvMjdcIj09UClmb3Iocy5sZW5ndGglMiYmKHYrPXMuc2hpZnQoKSk7cy5sZW5ndGg+MDspcD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7ZWxzZSBpZihcIm8xMFwiPT1QfHxcIm8yOVwiPT1QKXt2YXIgTD1cIm8xMFwiPT1QP246YTtpZigwPT1zLmxlbmd0aCljb25zb2xlLmRlYnVnKFwiZXJyb3I6IGVtcHR5IHN0YWNrXCIpO2Vsc2Uge3ZhciBXPXMucG9wKCksTT1MLlN1YnJzW1crTC5CaWFzXTt0Lng9bCx0Lnk9dix0Lm5TdGVtcz1pLHQuaGF2ZVdpZHRoPWgsdC53aWR0aD1kLHQub3Blbj1mLGUuVS5fZHJhd0NGRihNLHQsYSxuLG8pLGw9dC54LHY9dC55LGk9dC5uU3RlbXMsaD10LmhhdmVXaWR0aCxkPXQud2lkdGgsZj10Lm9wZW47fX1lbHNlIGlmKFwibzMwXCI9PVB8fFwibzMxXCI9PVApe3ZhciBWPXMubGVuZ3RoLEU9KEc9MCxcIm8zMVwiPT1QKTtmb3IoRys9Vi0oeD0tMyZWKTtHPHg7KUU/KHA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksdj0oZz1wK3Muc2hpZnQoKSkrcy5zaGlmdCgpLHgtRz09NT8obD1VK3Muc2hpZnQoKSxHKyspOmw9VSxFPSExKTooYz1sLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCkseC1HPT01Pyh2PWcrcy5zaGlmdCgpLEcrKyk6dj1nLEU9ITApLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdiksRys9NDt9ZWxzZSB7aWYoXCJvXCI9PShQK1wiXCIpLmNoYXJBdCgwKSl0aHJvdyBjb25zb2xlLmRlYnVnKFwiVW5rbm93biBvcGVyYXRpb246IFwiK1AsciksUDtzLnB1c2goUCk7fX19dC54PWwsdC55PXYsdC5uU3RlbXM9aSx0LmhhdmVXaWR0aD1oLHQud2lkdGg9ZCx0Lm9wZW49Zjt9O3ZhciB0PWUsYT17VHlwcjp0fTtyZXR1cm4gci5UeXByPXQsci5kZWZhdWx0PWEsT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscn0oe30pLlR5cHJ9XG5cbiAgLyohXG4gIEN1c3RvbSBidW5kbGUgb2Ygd29mZjJvdGYgKGh0dHBzOi8vZ2l0aHViLmNvbS9hcnR5LW5hbWUvd29mZjJvdGYpIHdpdGggZmZsYXRlXG4gIChodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZSkgZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuIFxuICBPcmlnaW5hbCBsaWNlbnNlcyBhcHBseTogXG4gIC0gZmZsYXRlOiBodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZS9ibG9iL21hc3Rlci9MSUNFTlNFIChNSVQpXG4gIC0gd29mZjJvdGYuanM6IGh0dHBzOi8vZ2l0aHViLmNvbS9hcnR5LW5hbWUvd29mZjJvdGYvYmxvYi9tYXN0ZXIvd29mZjJvdGYuanMgKEFwYWNoZTIpXG4gICovXG4gIGZ1bmN0aW9uIHdvZmYyb3RmRmFjdG9yeSgpe3JldHVybiBmdW5jdGlvbihyKXt2YXIgZT1VaW50OEFycmF5LG49VWludDE2QXJyYXksdD1VaW50MzJBcnJheSxhPW5ldyBlKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxpPW5ldyBlKFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzLDAsMF0pLG89bmV3IGUoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxmPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciBhPW5ldyBuKDMxKSxpPTA7aTwzMTsrK2kpYVtpXT1lKz0xPDxyW2ktMV07dmFyIG89bmV3IHQoYVszMF0pO2ZvcihpPTE7aTwzMDsrK2kpZm9yKHZhciBmPWFbaV07ZjxhW2krMV07KytmKW9bZl09Zi1hW2ldPDw1fGk7cmV0dXJuIFthLG9dfSx1PWYoYSwyKSx2PXVbMF0scz11WzFdO3ZbMjhdPTI1OCxzWzI1OF09Mjg7Zm9yKHZhciBsPWYoaSwwKVswXSxjPW5ldyBuKDMyNzY4KSxnPTA7ZzwzMjc2ODsrK2cpe3ZhciBoPSg0MzY5MCZnKT4+PjF8KDIxODQ1JmcpPDwxO2g9KDYxNjgwJihoPSg1MjQyOCZoKT4+PjJ8KDEzMTA3JmgpPDwyKSk+Pj40fCgzODU1JmgpPDw0LGNbZ109KCg2NTI4MCZoKT4+Pjh8KDI1NSZoKTw8OCk+Pj4xO312YXIgdz1mdW5jdGlvbihyLGUsdCl7Zm9yKHZhciBhPXIubGVuZ3RoLGk9MCxvPW5ldyBuKGUpO2k8YTsrK2kpKytvW3JbaV0tMV07dmFyIGYsdT1uZXcgbihlKTtmb3IoaT0wO2k8ZTsrK2kpdVtpXT11W2ktMV0rb1tpLTFdPDwxO2lmKHQpe2Y9bmV3IG4oMTw8ZSk7dmFyIHY9MTUtZTtmb3IoaT0wO2k8YTsrK2kpaWYocltpXSlmb3IodmFyIHM9aTw8NHxyW2ldLGw9ZS1yW2ldLGc9dVtyW2ldLTFdKys8PGwsaD1nfCgxPDxsKS0xO2c8PWg7KytnKWZbY1tnXT4+PnZdPXM7fWVsc2UgZm9yKGY9bmV3IG4oYSksaT0wO2k8YTsrK2kpcltpXSYmKGZbaV09Y1t1W3JbaV0tMV0rK10+Pj4xNS1yW2ldKTtyZXR1cm4gZn0sZD1uZXcgZSgyODgpO2ZvcihnPTA7ZzwxNDQ7KytnKWRbZ109ODtmb3IoZz0xNDQ7ZzwyNTY7KytnKWRbZ109OTtmb3IoZz0yNTY7ZzwyODA7KytnKWRbZ109Nztmb3IoZz0yODA7ZzwyODg7KytnKWRbZ109ODt2YXIgbT1uZXcgZSgzMik7Zm9yKGc9MDtnPDMyOysrZyltW2ddPTU7dmFyIGI9dyhkLDksMSkscD13KG0sNSwxKSx5PWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT1yWzBdLG49MTtuPHIubGVuZ3RoOysrbilyW25dPmUmJihlPXJbbl0pO3JldHVybiBlfSxMPWZ1bmN0aW9uKHIsZSxuKXt2YXIgdD1lLzh8MDtyZXR1cm4gKHJbdF18clt0KzFdPDw4KT4+KDcmZSkmbn0sVT1mdW5jdGlvbihyLGUpe3ZhciBuPWUvOHwwO3JldHVybiAocltuXXxyW24rMV08PDh8cltuKzJdPDwxNik+Pig3JmUpfSxrPVtcInVuZXhwZWN0ZWQgRU9GXCIsXCJpbnZhbGlkIGJsb2NrIHR5cGVcIixcImludmFsaWQgbGVuZ3RoL2xpdGVyYWxcIixcImludmFsaWQgZGlzdGFuY2VcIixcInN0cmVhbSBmaW5pc2hlZFwiLFwibm8gc3RyZWFtIGhhbmRsZXJcIiwsXCJubyBjYWxsYmFja1wiLFwiaW52YWxpZCBVVEYtOCBkYXRhXCIsXCJleHRyYSBmaWVsZCB0b28gbG9uZ1wiLFwiZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5XCIsXCJmaWxlbmFtZSB0b28gbG9uZ1wiLFwic3RyZWFtIGZpbmlzaGluZ1wiLFwiaW52YWxpZCB6aXAgZGF0YVwiXSxUPWZ1bmN0aW9uKHIsZSxuKXt2YXIgdD1uZXcgRXJyb3IoZXx8a1tyXSk7aWYodC5jb2RlPXIsRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHQsVCksIW4pdGhyb3cgdDtyZXR1cm4gdH0sTz1mdW5jdGlvbihyLGYsdSl7dmFyIHM9ci5sZW5ndGg7aWYoIXN8fHUmJiF1LmwmJnM8NSlyZXR1cm4gZnx8bmV3IGUoMCk7dmFyIGM9IWZ8fHUsZz0hdXx8dS5pO3V8fCh1PXt9KSxmfHwoZj1uZXcgZSgzKnMpKTt2YXIgaCxkPWZ1bmN0aW9uKHIpe3ZhciBuPWYubGVuZ3RoO2lmKHI+bil7dmFyIHQ9bmV3IGUoTWF0aC5tYXgoMipuLHIpKTt0LnNldChmKSxmPXQ7fX0sbT11LmZ8fDAsaz11LnB8fDAsTz11LmJ8fDAsQT11LmwseD11LmQsRT11Lm0sRD11Lm4sTT04KnM7ZG97aWYoIUEpe3UuZj1tPUwocixrLDEpO3ZhciBTPUwocixrKzEsMyk7aWYoays9MywhUyl7dmFyIFY9clsoST0oKGg9aykvOHwwKSsoNyZoJiYxKSs0KS00XXxyW0ktM108PDgsXz1JK1Y7aWYoXz5zKXtnJiZUKDApO2JyZWFrfWMmJmQoTytWKSxmLnNldChyLnN1YmFycmF5KEksXyksTyksdS5iPU8rPVYsdS5wPWs9OCpfO2NvbnRpbnVlfWlmKDE9PVMpQT1iLHg9cCxFPTksRD01O2Vsc2UgaWYoMj09Uyl7dmFyIGo9TChyLGssMzEpKzI1Nyx6PUwocixrKzEwLDE1KSs0LEM9aitMKHIsays1LDMxKSsxO2srPTE0O2Zvcih2YXIgRj1uZXcgZShDKSxQPW5ldyBlKDE5KSxxPTA7cTx6OysrcSlQW29bcV1dPUwocixrKzMqcSw3KTtrKz0zKno7dmFyIEI9eShQKSxHPSgxPDxCKS0xLEg9dyhQLEIsMSk7Zm9yKHE9MDtxPEM7KXt2YXIgSSxKPUhbTChyLGssRyldO2lmKGsrPTE1JkosKEk9Sj4+PjQpPDE2KUZbcSsrXT1JO2Vsc2Uge3ZhciBLPTAsTj0wO2ZvcigxNj09ST8oTj0zK0wocixrLDMpLGsrPTIsSz1GW3EtMV0pOjE3PT1JPyhOPTMrTChyLGssNyksays9Myk6MTg9PUkmJihOPTExK0wocixrLDEyNyksays9Nyk7Ti0tOylGW3ErK109Szt9fXZhciBRPUYuc3ViYXJyYXkoMCxqKSxSPUYuc3ViYXJyYXkoaik7RT15KFEpLEQ9eShSKSxBPXcoUSxFLDEpLHg9dyhSLEQsMSk7fWVsc2UgVCgxKTtpZihrPk0pe2cmJlQoMCk7YnJlYWt9fWMmJmQoTysxMzEwNzIpO2Zvcih2YXIgVz0oMTw8RSktMSxYPSgxPDxEKS0xLFk9azs7WT1rKXt2YXIgWj0oSz1BW1UocixrKSZXXSk+Pj40O2lmKChrKz0xNSZLKT5NKXtnJiZUKDApO2JyZWFrfWlmKEt8fFQoMiksWjwyNTYpZltPKytdPVo7ZWxzZSB7aWYoMjU2PT1aKXtZPWssQT1udWxsO2JyZWFrfXZhciAkPVotMjU0O2lmKFo+MjY0KXt2YXIgcnI9YVtxPVotMjU3XTskPUwocixrLCgxPDxyciktMSkrdltxXSxrKz1ycjt9dmFyIGVyPXhbVShyLGspJlhdLG5yPWVyPj4+NDtlcnx8VCgzKSxrKz0xNSZlcjtSPWxbbnJdO2lmKG5yPjMpe3JyPWlbbnJdO1IrPVUocixrKSYoMTw8cnIpLTEsays9cnI7fWlmKGs+TSl7ZyYmVCgwKTticmVha31jJiZkKE8rMTMxMDcyKTtmb3IodmFyIHRyPU8rJDtPPHRyO08rPTQpZltPXT1mW08tUl0sZltPKzFdPWZbTysxLVJdLGZbTysyXT1mW08rMi1SXSxmW08rM109ZltPKzMtUl07Tz10cjt9fXUubD1BLHUucD1ZLHUuYj1PLEEmJihtPTEsdS5tPUUsdS5kPXgsdS5uPUQpO313aGlsZSghbSk7cmV0dXJuIE89PWYubGVuZ3RoP2Y6ZnVuY3Rpb24ocixhLGkpeyhudWxsPT1hfHxhPDApJiYoYT0wKSwobnVsbD09aXx8aT5yLmxlbmd0aCkmJihpPXIubGVuZ3RoKTt2YXIgbz1uZXcociBpbnN0YW5jZW9mIG4/bjpyIGluc3RhbmNlb2YgdD90OmUpKGktYSk7cmV0dXJuIG8uc2V0KHIuc3ViYXJyYXkoYSxpKSksb30oZiwwLE8pfSxBPW5ldyBlKDApO3ZhciB4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyO3RyeXt4LmRlY29kZShBLHtzdHJlYW06ITB9KSwxO31jYXRjaChyKXt9cmV0dXJuIHIuY29udmVydF9zdHJlYW1zPWZ1bmN0aW9uKHIpe3ZhciBlPW5ldyBEYXRhVmlldyhyKSxuPTA7ZnVuY3Rpb24gdCgpe3ZhciByPWUuZ2V0VWludDE2KG4pO3JldHVybiBuKz0yLHJ9ZnVuY3Rpb24gYSgpe3ZhciByPWUuZ2V0VWludDMyKG4pO3JldHVybiBuKz00LHJ9ZnVuY3Rpb24gaShyKXttLnNldFVpbnQxNihiLHIpLGIrPTI7fWZ1bmN0aW9uIG8ocil7bS5zZXRVaW50MzIoYixyKSxiKz00O31mb3IodmFyIGY9e3NpZ25hdHVyZTphKCksZmxhdm9yOmEoKSxsZW5ndGg6YSgpLG51bVRhYmxlczp0KCkscmVzZXJ2ZWQ6dCgpLHRvdGFsU2ZudFNpemU6YSgpLG1ham9yVmVyc2lvbjp0KCksbWlub3JWZXJzaW9uOnQoKSxtZXRhT2Zmc2V0OmEoKSxtZXRhTGVuZ3RoOmEoKSxtZXRhT3JpZ0xlbmd0aDphKCkscHJpdk9mZnNldDphKCkscHJpdkxlbmd0aDphKCl9LHU9MDtNYXRoLnBvdygyLHUpPD1mLm51bVRhYmxlczspdSsrO3UtLTtmb3IodmFyIHY9MTYqTWF0aC5wb3coMix1KSxzPTE2KmYubnVtVGFibGVzLXYsbD0xMixjPVtdLGc9MDtnPGYubnVtVGFibGVzO2crKyljLnB1c2goe3RhZzphKCksb2Zmc2V0OmEoKSxjb21wTGVuZ3RoOmEoKSxvcmlnTGVuZ3RoOmEoKSxvcmlnQ2hlY2tzdW06YSgpfSksbCs9MTY7dmFyIGgsdz1uZXcgVWludDhBcnJheSgxMisxNipjLmxlbmd0aCtjLnJlZHVjZSgoZnVuY3Rpb24ocixlKXtyZXR1cm4gcitlLm9yaWdMZW5ndGgrNH0pLDApKSxkPXcuYnVmZmVyLG09bmV3IERhdGFWaWV3KGQpLGI9MDtyZXR1cm4gbyhmLmZsYXZvciksaShmLm51bVRhYmxlcyksaSh2KSxpKHUpLGkocyksYy5mb3JFYWNoKChmdW5jdGlvbihyKXtvKHIudGFnKSxvKHIub3JpZ0NoZWNrc3VtKSxvKGwpLG8oci5vcmlnTGVuZ3RoKSxyLm91dE9mZnNldD1sLChsKz1yLm9yaWdMZW5ndGgpJTQhPTAmJihsKz00LWwlNCk7fSkpLGMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG4sdD1yLnNsaWNlKGUub2Zmc2V0LGUub2Zmc2V0K2UuY29tcExlbmd0aCk7aWYoZS5jb21wTGVuZ3RoIT1lLm9yaWdMZW5ndGgpe3ZhciBhPW5ldyBVaW50OEFycmF5KGUub3JpZ0xlbmd0aCk7bj1uZXcgVWludDhBcnJheSh0LDIpLE8obixhKTt9ZWxzZSBhPW5ldyBVaW50OEFycmF5KHQpO3cuc2V0KGEsZS5vdXRPZmZzZXQpO3ZhciBpPTA7KGw9ZS5vdXRPZmZzZXQrZS5vcmlnTGVuZ3RoKSU0IT0wJiYoaT00LWwlNCksdy5zZXQobmV3IFVpbnQ4QXJyYXkoaSkuYnVmZmVyLGUub3V0T2Zmc2V0K2Uub3JpZ0xlbmd0aCksaD1sK2k7fSkpLGQuc2xpY2UoMCxoKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscn0oe30pLmNvbnZlcnRfc3RyZWFtc31cblxuICAvKipcbiAgICogQSBmYWN0b3J5IHdyYXBwZXIgcGFyc2luZyBhIGZvbnQgZmlsZSB1c2luZyBUeXByLlxuICAgKiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgV09GRiBmaWxlcyAobm90IFdPRkYyKS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIFBhcnNlZEZvbnRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFzY2VuZGVyXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZXNjZW5kZXJcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhIZWlnaHRcbiAgICogQHByb3BlcnR5IHsobnVtYmVyKSA9PiBib29sZWFufSBzdXBwb3J0c0NvZGVQb2ludFxuICAgKiBAcHJvcGVydHkgeyh0ZXh0OnN0cmluZywgZm9udFNpemU6bnVtYmVyLCBsZXR0ZXJTcGFjaW5nOm51bWJlciwgY2FsbGJhY2spID0+IG51bWJlcn0gZm9yRWFjaEdseXBoXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lR2FwXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYXBIZWlnaHRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHVuaXRzUGVyRW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsoYnVmZmVyOiBBcnJheUJ1ZmZlcikgPT4gUGFyc2VkRm9udH0gRm9udFBhcnNlclxuICAgKi9cblxuICAvKipcbiAgICogQHJldHVybnMge0ZvbnRQYXJzZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZXJGYWN0b3J5KFR5cHIsIHdvZmYyb3RmKSB7XG4gICAgY29uc3QgY21kQXJnTGVuZ3RocyA9IHtcbiAgICAgIE06IDIsXG4gICAgICBMOiAyLFxuICAgICAgUTogNCxcbiAgICAgIEM6IDYsXG4gICAgICBaOiAwXG4gICAgfTtcblxuICAgIC8vIHtqb2luVHlwZTogXCJza2lwK3N0ZXAsLi4uXCJ9XG4gICAgY29uc3Qgam9pbmluZ1R5cGVSYXdEYXRhID0ge1wiQ1wiOlwiMThnLGNhLDM2OCwxa3pcIixcIkRcIjpcIjE3ayw2LDIsMis0LDUrYywyKzYsMisxLDEwKzEsOStmLGorMTEsMisxLGEsMiwyKzEsMTUrMiwzLGorMiw2KzMsMis4LDIsMiwyKzEsdythLDQrZSwzKzMsMiwzKzIsMys1LDIzK3csMmYrNCwzLDIrOSwyLGIsMiszLDMsMWsrOSw2KzEsMysxLDIrMiwyK2QsMzBnLHAreSwxLDErMWcsZit4LDIsc2QyKzFkLGpmMys0LGYrMywyKzQsMisyLGIrMyw0MiwyLDQrMiwyKzEsMiwzLHQrMSw5Zit3LDIsZWwrMiwyK2csZCsyLDJsLDIrMSw1LDMrMSwyKzEsMiwzLDYsMTZ3bSsxdlwiLFwiUlwiOlwiMTdtKzMsMiwyLDYrMyxtLDE1KzIsMisyLGgraCwxMywzKzgsMiwyLDMrMSwyLHArMSx4LDUrNCw1LGEsMiwyLDMsdSxjKzIsZysxLDUsMisxLDQrMSw1aiw2KzEsMixiLDIrMixmLDIrMSwxcysyLDIsMysxLDcsMWV6MCwyLDIrMSw0KzQsYiw0LDMsYiw0MiwyKzIsNCwzLDIrMSwyLG8rMyxhZSxlcCx4LDJvKzIsMysxLDMsNSsxLDZcIixcIkxcIjpcIng5dSxqZmYsYSxmZCxqdlwiLFwiVFwiOlwiNHQsZ2orMzMsN28rNCwxKzEsN2MrMTgsMiwyKzEsMisxLDIsMjErYSwyLDFiK2ssaCwydSs2LDMrNSwzKzEsMiszLHksMix2K3EsMmsrYSwxbis4LGEscCszLDIrOCwyKzIsMis0LDE4KzIsM2MrZSwyK3YsMWssMiw1KzcsNSw0KzYsYisxLHUsMW4sNSszLDksbCsxLHIsMysxLDFtLDUrMSw1KzEsMysyLDQsdisxLDQsYysxLDFtLDUrNCwyKzEsNSxsKzEsbis1LDIsMW4sMywyKzMsOSw4KzEsYysxLHYsMXEsZCwxZiw0LDFtKzIsNisyLDIrMyw4KzEsYysxLHUsMW4sMyw3LDYrMSxsKzEsdCsxLDFtKzEsNSszLDksbCsxLHUsMjEsOCsyLDIsMmosMys2LGQrNywyciwzKzgsYys1LDIzKzEscywyLDIsMWsrZCwyKzQsMisxLDYrYSwyK3osYSwydiszLDIrNSwyKzEsMysxLHErMSw1KzIsaCszLGUsMysxLDcsZyxqaysyLHFiKzIsdSsyLHUrMSx2KzEsMXQrMSwyKzYsOSwzK2EsYSwxYSsyLDNjKzEseiwzYisyLDUrMSxhLDcrMiw2NCsxLDMsMW4sMis2LDIsMiwzKzcsNys5LDMsMWQrZCwxLDErMSwxcyszLDFkLDIrNCwyLDYsMTUrOCxkKzEseCszLDMrMSwyKzIsMWwsMisxLDQsMisyLDFuKzcsMysxLDQ5KzIsMitjLDIrNiw1LDcsNCsxLDVqKzFsLDIrNCxlaywzKzEscis0LDFlKzQsNis1LDJwK2MsMSszLDEsMSsyLDErYiwyZGIrMiwzeSwycCt2LGZmKzMsMzArMSxuOXgsMSsyLDIrOSx4KzEsMjkrMSw3bCw0LDUscSsxLDYsNDgrMSxyK2gsZSwxMys3LHErYSwxYisyLDFkLDMrMywzKzEsMTQsMXcrNSwzKzEsMysxLGQsOSwxYywxZywyKzIsMysxLDYrMSwyLDE3KzEsOSw2biwzLDUsZm41LGtpK2YsaCtmLDVzLDZ5KzIsZWEsNmIsNDYrNCwxYWYrMiwyKzEsNiszLDE1KzIsNSw0bSsxLGZ5KzMsYXMrMSw0YSthLDR4LDFqK2UsMWwrMiwxZSszLDMrMSwxeSsyLDExKzQsMis3LDFyLGQrMSwxaCs4LGIrMywzLDJvKzIsMywyKzEsNyw0aCw0KzcsbSsxLDFtKzEsNCwxMis2LDQrNCw1Zys3LDMrMiwyLG8sMmQrNSwyLDUrMSwyKzEsNm4rMyw3KzEsMisxLHMrMSwyZSs3LDMsMisxLDJ6LDIsMys1LDIsMnUrMiwzKzMsMis0LDc4KzgsMisxLDc1KzEsMiw1LDQxKzMsMysxLDUseCs5LDE1KzUsMyszLDksYSs1LDMrMiwxYitjLDIrMSxiYis2LDIrNSwyLDJiK2wsMys2LDIrMSwyKzEsM2YrNSw0LDIrMSwyKzYsMiwyMSsxLDQsMiw5bysxLDQ3MCs4LGF0NCs0LDFvKzYsdDUsMXMrMywyYSxmNWwrMSwyKzMsNDNvKzIsYSs3LDErNywzKzYsdiszLDQ1KzIsMWowKzFpLDUrMWQsOSxmLG4rNCwyK2UsMTF0KzYsMitnLDMrNiwyKzEsMis0LDdhKzYsYzYrMywxNXQrNiwzMis2LDEsZ3phdSx2KzJuLDNsKzZuXCJ9O1xuXG4gICAgY29uc3QgSlRfTEVGVCA9IDEsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIsIGJ1dCBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIuXG4gICAgICBKVF9SSUdIVCA9IDIsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciwgYnV0IGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgICBKVF9EVUFMID0gNCwgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBqb2lucyB3aXRoIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyIGFuZCBqb2lucyB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3Rlci5cbiAgICAgIEpUX1RSQU5TUEFSRU5UID0gOCwgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgY2hhcmFjdGVyIGRvZXMgbm90IGpvaW4gd2l0aCBhZGphY2VudCBjaGFyYWN0ZXJzIGFuZCB0aGF0IHRoZSBjaGFyYWN0ZXIgbXVzdCBiZSBza2lwcGVkIG92ZXIgd2hlbiB0aGUgc2hhcGluZyBlbmdpbmUgaXMgZXZhbHVhdGluZyB0aGUgam9pbmluZyBwb3NpdGlvbnMgaW4gYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLiBXaGVuIGEgSlRfVFJBTlNQQVJFTlQgY2hhcmFjdGVyIGlzIGVuY291bnRlcmVkIGluIGEgc2VxdWVuY2UsIHRoZSBKT0lOSU5HX1RZUEUgb2YgdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIgcGFzc2VzIHRocm91Z2guIERpYWNyaXRpY2FsIG1hcmtzIGFyZSBmcmVxdWVudGx5IGFzc2lnbmVkIHRoaXMgdmFsdWUuXG4gICAgICBKVF9KT0lOX0NBVVNJTkcgPSAxNiwgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgY2hhcmFjdGVyIGZvcmNlcyB0aGUgdXNlIG9mIGpvaW5pbmcgZm9ybXMgd2l0aCB0aGUgcHJlY2VkaW5nIGFuZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMuIEthc2hpZGFzIGFuZCB0aGUgWmVybyBXaWR0aCBKb2luZXIgKFUrMjAwRCkgYXJlIGJvdGggSk9JTl9DQVVTSU5HIGNoYXJhY3RlcnMuXG4gICAgICBKVF9OT05fSk9JTklORyA9IDMyOyAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgcHJlY2VkaW5nIG9yIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLixcblxuICAgIGxldCBqb2luaW5nVHlwZU1hcDtcbiAgICBmdW5jdGlvbiBnZXRDaGFySm9pbmluZ1R5cGUoY2gpIHtcbiAgICAgIGlmICgham9pbmluZ1R5cGVNYXApIHtcbiAgICAgICAgY29uc3QgbSA9IHtcbiAgICAgICAgICBSOiBKVF9SSUdIVCxcbiAgICAgICAgICBMOiBKVF9MRUZULFxuICAgICAgICAgIEQ6IEpUX0RVQUwsXG4gICAgICAgICAgQzogSlRfSk9JTl9DQVVTSU5HLFxuICAgICAgICAgIFU6IEpUX05PTl9KT0lOSU5HLFxuICAgICAgICAgIFQ6IEpUX1RSQU5TUEFSRU5UXG4gICAgICAgIH07XG4gICAgICAgIGpvaW5pbmdUeXBlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIGpvaW5pbmdUeXBlUmF3RGF0YSkge1xuICAgICAgICAgIGxldCBsYXN0Q29kZSA9IDA7XG4gICAgICAgICAgam9pbmluZ1R5cGVSYXdEYXRhW3R5cGVdLnNwbGl0KCcsJykuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgW3NraXAsIHN0ZXBdID0gcmFuZ2Uuc3BsaXQoJysnKTtcbiAgICAgICAgICAgIHNraXAgPSBwYXJzZUludChza2lwLDM2KTtcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwID8gcGFyc2VJbnQoc3RlcCwgMzYpIDogMDtcbiAgICAgICAgICAgIGpvaW5pbmdUeXBlTWFwLnNldChsYXN0Q29kZSArPSBza2lwLCBtW3R5cGVdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGVwOyBpLS07KSB7XG4gICAgICAgICAgICAgIGpvaW5pbmdUeXBlTWFwLnNldCgrK2xhc3RDb2RlLCBtW3R5cGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGpvaW5pbmdUeXBlTWFwLmdldChjaCkgfHwgSlRfTk9OX0pPSU5JTkdcbiAgICB9XG5cbiAgICBjb25zdCBJU09MID0gMSwgSU5JVCA9IDIsIEZJTkEgPSAzLCBNRURJID0gNDtcbiAgICBjb25zdCBmb3Jtc1RvRmVhdHVyZXMgPSBbbnVsbCwgJ2lzb2wnLCAnaW5pdCcsICdmaW5hJywgJ21lZGknXTtcblxuICAgIGZ1bmN0aW9uIGRldGVjdEpvaW5pbmdGb3JtcyhzdHIpIHtcbiAgICAgIC8vIFRoaXMgaW1wbGVtZW50cyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL244d2lsbGlzL29wZW50eXBlLXNoYXBpbmctZG9jdW1lbnRzL2Jsb2IvbWFzdGVyL29wZW50eXBlLXNoYXBpbmctYXJhYmljLWdlbmVyYWwubWRcbiAgICAgIGNvbnN0IGpvaW5pbmdGb3JtcyA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgICAgbGV0IHByZXZKb2luaW5nVHlwZSA9IEpUX05PTl9KT0lOSU5HO1xuICAgICAgbGV0IHByZXZGb3JtID0gSVNPTDtcbiAgICAgIGxldCBwcmV2SW5kZXggPSAtMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICAgIGxldCBqb2luaW5nVHlwZSA9IGdldENoYXJKb2luaW5nVHlwZShjb2RlKSB8IDA7XG4gICAgICAgIGxldCBmb3JtID0gSVNPTDtcbiAgICAgICAgaWYgKGpvaW5pbmdUeXBlICYgSlRfVFJBTlNQQVJFTlQpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfTEVGVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgICAgaWYgKGpvaW5pbmdUeXBlICYgKEpUX1JJR0hUIHwgSlRfRFVBTCB8IEpUX0pPSU5fQ0FVU0lORykpIHtcbiAgICAgICAgICAgIGZvcm0gPSBGSU5BO1xuICAgICAgICAgICAgLy8gaXNvbC0+aW5pdCwgZmluYS0+bWVkaVxuICAgICAgICAgICAgaWYgKHByZXZGb3JtID09PSBJU09MIHx8IHByZXZGb3JtID09PSBGSU5BKSB7XG4gICAgICAgICAgICAgIGpvaW5pbmdGb3Jtc1twcmV2SW5kZXhdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGpvaW5pbmdUeXBlICYgKEpUX0xFRlQgfCBKVF9OT05fSk9JTklORykpIHtcbiAgICAgICAgICAgIC8vIG1lZGktPmZpbmEsIGluaXQtPmlzb2xcbiAgICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSU5JVCB8fCBwcmV2Rm9ybSA9PT0gTUVESSkge1xuICAgICAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfUklHSFQgfCBKVF9OT05fSk9JTklORykpIHtcbiAgICAgICAgICAvLyBtZWRpLT5maW5hLCBpbml0LT5pc29sXG4gICAgICAgICAgaWYgKHByZXZGb3JtID09PSBJTklUIHx8IHByZXZGb3JtID09PSBNRURJKSB7XG4gICAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2Rm9ybSA9IGpvaW5pbmdGb3Jtc1tpXSA9IGZvcm07XG4gICAgICAgIHByZXZKb2luaW5nVHlwZSA9IGpvaW5pbmdUeXBlO1xuICAgICAgICBwcmV2SW5kZXggPSBpO1xuICAgICAgICBpZiAoY29kZSA+IDB4ZmZmZikgaSsrO1xuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coc3RyLnNwbGl0KCcnKS5tYXAoY2ggPT4gY2guY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpKSlcbiAgICAgIC8vIGNvbnNvbGUubG9nKHN0ci5zcGxpdCgnJykubWFwKGNoID0+IGdldENoYXJKb2luaW5nVHlwZShjaC5jb2RlUG9pbnRBdCgwKSkpKVxuICAgICAgLy8gY29uc29sZS5sb2coQXJyYXkuZnJvbShqb2luaW5nRm9ybXMpLm1hcChmID0+IGZvcm1zVG9GZWF0dXJlc1tmXSB8fCAnbm9uZScpKVxuICAgICAgcmV0dXJuIGpvaW5pbmdGb3Jtc1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1RvR2x5cGhzIChmb250LCBzdHIpIHtcbiAgICAgIGNvbnN0IGdseXBoSWRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjYyA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgaWYgKGNjID4gMHhmZmZmKSBpKys7XG4gICAgICAgIGdseXBoSWRzLnB1c2goVHlwci5VLmNvZGVUb0dseXBoKGZvbnQsIGNjKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdzdWIgPSBmb250WydHU1VCJ107XG4gICAgICBpZiAoZ3N1Yikge1xuICAgICAgICBjb25zdCB7bG9va3VwTGlzdCwgZmVhdHVyZUxpc3R9ID0gZ3N1YjtcbiAgICAgICAgbGV0IGpvaW5pbmdGb3JtcztcbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkRmVhdHVyZXMgPSAvXihybGlnfGxpZ2F8bXNldHxpc29sfGluaXR8ZmluYXxtZWRpfGhhbGZ8cHJlc3xibHdzfGNjbXApJC87XG4gICAgICAgIGNvbnN0IHVzZWRMb29rdXBzID0gW107XG4gICAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZEZlYXR1cmVzLnRlc3QoZmVhdHVyZS50YWcpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0aSA9IDA7IHRpIDwgZmVhdHVyZS50YWIubGVuZ3RoOyB0aSsrKSB7XG4gICAgICAgICAgICAgIGlmICh1c2VkTG9va3Vwc1tmZWF0dXJlLnRhYlt0aV1dKSBjb250aW51ZVxuICAgICAgICAgICAgICB1c2VkTG9va3Vwc1tmZWF0dXJlLnRhYlt0aV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdGFiID0gbG9va3VwTGlzdFtmZWF0dXJlLnRhYlt0aV1dO1xuICAgICAgICAgICAgICBjb25zdCBpc0pvaW5pbmdGZWF0dXJlID0gL14oaXNvbHxpbml0fGZpbmF8bWVkaSkkLy50ZXN0KGZlYXR1cmUudGFnKTtcbiAgICAgICAgICAgICAgaWYgKGlzSm9pbmluZ0ZlYXR1cmUgJiYgIWpvaW5pbmdGb3JtcykgeyAvL2xhenlcbiAgICAgICAgICAgICAgICBqb2luaW5nRm9ybXMgPSBkZXRlY3RKb2luaW5nRm9ybXMoc3RyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgZ2x5cGhJZHMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luaW5nRm9ybXMgfHwgIWlzSm9pbmluZ0ZlYXR1cmUgfHwgZm9ybXNUb0ZlYXR1cmVzW2pvaW5pbmdGb3Jtc1tjaV1dID09PSBmZWF0dXJlLnRhZykge1xuICAgICAgICAgICAgICAgICAgVHlwci5VLl9hcHBseVN1YnMoZ2x5cGhJZHMsIGNpLCB0YWIsIGxvb2t1cExpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnbHlwaElkc1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBhZHZhbmNlcyBhbmQgeC95IG9mZnNldHMgZm9yIGVhY2ggZ2x5cGgsIGUuZy4ga2VybmluZyBhbmQgbWFya1xuICAgIC8vIGF0dGFjaG1lbnRzLiBUaGlzIGlzIGEgbW9yZSBjb21wbGV0ZSB2ZXJzaW9uIG9mIFR5cHIuVS5nZXRQYWlyQWRqdXN0bWVudFxuICAgIC8vIGFuZCBzaG91bGQgYmVjb21lIGFuIHVwc3RyZWFtIHJlcGxhY2VtZW50IGV2ZW50dWFsbHkuXG4gICAgZnVuY3Rpb24gY2FsY0dseXBoUG9zaXRpb25zKGZvbnQsIGdseXBoSWRzKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgSW50MTZBcnJheShnbHlwaElkcy5sZW5ndGggKiAzKTsgLy8gW29mZnNldFgsIG9mZnNldFksIGFkdmFuY2VYLCAuLi5dXG4gICAgICBsZXQgZ2x5cGhJbmRleCA9IDA7XG4gICAgICBmb3IgKDsgZ2x5cGhJbmRleCA8IGdseXBoSWRzLmxlbmd0aDsgZ2x5cGhJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGdseXBoSWQgPSBnbHlwaElkc1tnbHlwaEluZGV4XTtcbiAgICAgICAgaWYgKGdseXBoSWQgPT09IC0xKSBjb250aW51ZTtcblxuICAgICAgICBwb3NpdGlvbnNbZ2x5cGhJbmRleCAqIDMgKyAyXSA9IGZvbnQuaG10eC5hV2lkdGhbZ2x5cGhJZF07IC8vIHBvcHVsYXRlIGFkdmFuY2VYIGluLi4uYWR2YW5jZS5cblxuICAgICAgICBjb25zdCBncG9zID0gZm9udC5HUE9TO1xuICAgICAgICBpZiAoZ3Bvcykge1xuICAgICAgICAgIGNvbnN0IGxsaXN0ID0gZ3Bvcy5sb29rdXBMaXN0O1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IGxsaXN0W2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb29rdXAudGFicy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBjb25zdCB0YWIgPSBsb29rdXAudGFic1tqXTtcbiAgICAgICAgICAgICAgLy8gU2luZ2xlIGNoYXIgcGxhY2VtZW50XG4gICAgICAgICAgICAgIGlmIChsb29rdXAubHR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmQgPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLmNvdmVyYWdlLCBnbHlwaElkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kICE9PSAtMSAmJiB0YWIucG9zKSB7XG4gICAgICAgICAgICAgICAgICBhcHBseVZhbHVlUmVjb3JkKHRhYi5wb3MsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gUGFpcnMgKGtlcm5pbmcpXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGxvb2t1cC5sdHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBhZGogPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBwcmV2R2x5cGhJbmRleCA9IGdldFByZXZHbHlwaEluZGV4KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZHbHlwaEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY292ZXJhZ2VJbmRleCA9IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCh0YWIuY292ZXJhZ2UsIGdseXBoSWRzW3ByZXZHbHlwaEluZGV4XSk7XG4gICAgICAgICAgICAgICAgICBpZiAoY292ZXJhZ2VJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYi5mbXQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHRhYi5wYWlyc2V0c1tjb3ZlcmFnZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJpZ2h0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRba10uZ2lkMiA9PT0gZ2x5cGhJZCkgYWRqID0gcmlnaHRba107XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhYi5mbXQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjMSA9IFR5cHIuVS5fZ2V0R2x5cGhDbGFzcyhnbHlwaElkc1twcmV2R2x5cGhJbmRleF0sIHRhYi5jbGFzc0RlZjEpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGMyID0gVHlwci5VLl9nZXRHbHlwaENsYXNzKGdseXBoSWQsIHRhYi5jbGFzc0RlZjIpO1xuICAgICAgICAgICAgICAgICAgICAgIGFkaiA9IHRhYi5tYXRyaXhbYzFdW2MyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFkai52YWwxKSBhcHBseVZhbHVlUmVjb3JkKGFkai52YWwxLCBwcmV2R2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFkai52YWwyKSBhcHBseVZhbHVlUmVjb3JkKGFkai52YWwyLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIE1hcmsgdG8gYmFzZVxuICAgICAgICAgICAgICBlbHNlIGlmIChsb29rdXAubHR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrQXJySW5kZXggPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLm1hcmtDb3ZlcmFnZSwgZ2x5cGhJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtBcnJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VHbHlwaEluZGV4ID0gZ2V0UHJldkdseXBoSW5kZXgoaXNCYXNlR2x5cGgpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZUFyckluZGV4ID0gYmFzZUdseXBoSW5kZXggPT09IC0xID8gLTEgOiBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLmJhc2VDb3ZlcmFnZSwgZ2x5cGhJZHNbYmFzZUdseXBoSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgIGlmIChiYXNlQXJySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtSZWNvcmQgPSB0YWIubWFya0FycmF5W21hcmtBcnJJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VBbmNob3IgPSB0YWIuYmFzZUFycmF5W2Jhc2VBcnJJbmRleF1bbWFya1JlY29yZC5tYXJrQ2xhc3NdO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbZ2x5cGhJbmRleCAqIDNdID0gYmFzZUFuY2hvci54IC0gbWFya1JlY29yZC54ICsgcG9zaXRpb25zW2Jhc2VHbHlwaEluZGV4ICogM10gLSBwb3NpdGlvbnNbYmFzZUdseXBoSW5kZXggKiAzICsgMl07XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogMyArIDFdID0gYmFzZUFuY2hvci55IC0gbWFya1JlY29yZC55ICsgcG9zaXRpb25zW2Jhc2VHbHlwaEluZGV4ICogMyArIDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gTWFyayB0byBtYXJrXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGxvb2t1cC5sdHlwZSA9PT0gNikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsxQXJySW5kZXggPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLm1hcmsxQ292ZXJhZ2UsIGdseXBoSWQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrMUFyckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkdseXBoSW5kZXggPSBnZXRQcmV2R2x5cGhJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHByZXZHbHlwaEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2R2x5cGhJZCA9IGdseXBoSWRzW3ByZXZHbHlwaEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEdseXBoQ2xhc3MoZm9udCwgcHJldkdseXBoSWQpID09PSAzKSB7IC8vIG9ubHkgY2hlY2sgbWFyayBnbHlwaHNcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrMkFyckluZGV4ID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5tYXJrMkNvdmVyYWdlLCBwcmV2R2x5cGhJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmsyQXJySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrMVJlY29yZCA9IHRhYi5tYXJrMUFycmF5W21hcmsxQXJySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyazJBbmNob3IgPSB0YWIubWFyazJBcnJheVttYXJrMkFyckluZGV4XVttYXJrMVJlY29yZC5tYXJrQ2xhc3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzXSA9IG1hcmsyQW5jaG9yLnggLSBtYXJrMVJlY29yZC54ICsgcG9zaXRpb25zW3ByZXZHbHlwaEluZGV4ICogM10gLSBwb3NpdGlvbnNbcHJldkdseXBoSW5kZXggKiAzICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbZ2x5cGhJbmRleCAqIDMgKyAxXSA9IG1hcmsyQW5jaG9yLnkgLSBtYXJrMVJlY29yZC55ICsgcG9zaXRpb25zW3ByZXZHbHlwaEluZGV4ICogMyArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGtlcm4gdGFibGUgaWYgbm8gR1BPU1xuICAgICAgICBlbHNlIGlmIChmb250Lmtlcm4gJiYgIWZvbnQuY2ZmKSB7XG4gICAgICAgICAgY29uc3QgcHJldkdseXBoSW5kZXggPSBnZXRQcmV2R2x5cGhJbmRleCgpO1xuICAgICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZDEgPSBmb250Lmtlcm4uZ2x5cGgxLmluZGV4T2YoZ2x5cGhJZHNbcHJldkdseXBoSW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChpbmQxICE9PSAtMSkge1xuICAgICAgICAgICAgICBjb25zdCBpbmQyID0gZm9udC5rZXJuLnJ2YWxbaW5kMV0uZ2x5cGgyLmluZGV4T2YoZ2x5cGhJZCk7XG4gICAgICAgICAgICAgIGlmIChpbmQyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uc1twcmV2R2x5cGhJbmRleCAqIDMgKyAyXSArPSBmb250Lmtlcm4ucnZhbFtpbmQxXS52YWxzW2luZDJdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3NpdGlvbnM7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFByZXZHbHlwaEluZGV4KGZpbHRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gZ2x5cGhJbmRleCAtIDE7IGkgPj0wOyBpLS0pIHtcbiAgICAgICAgICBpZiAoZ2x5cGhJZHNbaV0gIT09IC0xICYmICghZmlsdGVyIHx8IGZpbHRlcihnbHlwaElkc1tpXSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQmFzZUdseXBoKGdseXBoSWQpIHtcbiAgICAgICAgcmV0dXJuIGdldEdseXBoQ2xhc3MoZm9udCwgZ2x5cGhJZCkgPT09IDE7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGx5VmFsdWVSZWNvcmQoc291cmNlLCBnaSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHBvc2l0aW9uc1tnaSAqIDMgKyBpXSArPSBzb3VyY2VbaV0gfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEdseXBoQ2xhc3MoZm9udCwgZ2x5cGhJZCkge1xuICAgICAgY29uc3QgY2xhc3NEZWYgPSBmb250LkdERUYgJiYgZm9udC5HREVGLmdseXBoQ2xhc3NEZWY7XG4gICAgICByZXR1cm4gY2xhc3NEZWYgPyBUeXByLlUuX2dldEdseXBoQ2xhc3MoZ2x5cGhJZCwgY2xhc3NEZWYpIDogMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXJzdE51bSguLi5hcmdzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBhcmdzW2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBQYXJzZWRGb250XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcEZvbnRPYmoodHlwckZvbnQpIHtcbiAgICAgIGNvbnN0IGdseXBoTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgY29uc3Qgb3MyID0gdHlwckZvbnRbJ09TLzInXTtcbiAgICAgIGNvbnN0IGhoZWEgPSB0eXByRm9udC5oaGVhO1xuICAgICAgY29uc3QgdW5pdHNQZXJFbSA9IHR5cHJGb250LmhlYWQudW5pdHNQZXJFbTtcbiAgICAgIGNvbnN0IGFzY2VuZGVyID0gZmlyc3ROdW0ob3MyICYmIG9zMi5zVHlwb0FzY2VuZGVyLCBoaGVhICYmIGhoZWEuYXNjZW5kZXIsIHVuaXRzUGVyRW0pO1xuXG4gICAgICAvKiogQHR5cGUgUGFyc2VkRm9udCAqL1xuICAgICAgY29uc3QgZm9udE9iaiA9IHtcbiAgICAgICAgdW5pdHNQZXJFbSxcbiAgICAgICAgYXNjZW5kZXIsXG4gICAgICAgIGRlc2NlbmRlcjogZmlyc3ROdW0ob3MyICYmIG9zMi5zVHlwb0Rlc2NlbmRlciwgaGhlYSAmJiBoaGVhLmRlc2NlbmRlciwgMCksXG4gICAgICAgIGNhcEhlaWdodDogZmlyc3ROdW0ob3MyICYmIG9zMi5zQ2FwSGVpZ2h0LCBhc2NlbmRlciksXG4gICAgICAgIHhIZWlnaHQ6IGZpcnN0TnVtKG9zMiAmJiBvczIuc3hIZWlnaHQsIGFzY2VuZGVyKSxcbiAgICAgICAgbGluZUdhcDogZmlyc3ROdW0ob3MyICYmIG9zMi5zVHlwb0xpbmVHYXAsIGhoZWEgJiYgaGhlYS5saW5lR2FwKSxcbiAgICAgICAgc3VwcG9ydHNDb2RlUG9pbnQoY29kZSkge1xuICAgICAgICAgIHJldHVybiBUeXByLlUuY29kZVRvR2x5cGgodHlwckZvbnQsIGNvZGUpID4gMFxuICAgICAgICB9LFxuICAgICAgICBmb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgbGV0IHBlblggPSAwO1xuICAgICAgICAgIGNvbnN0IGZvbnRTY2FsZSA9IDEgLyBmb250T2JqLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblxuICAgICAgICAgIGNvbnN0IGdseXBoSWRzID0gc3RyaW5nVG9HbHlwaHModHlwckZvbnQsIHRleHQpO1xuICAgICAgICAgIGxldCBjaGFySW5kZXggPSAwO1xuICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGNhbGNHbHlwaFBvc2l0aW9ucyh0eXByRm9udCwgZ2x5cGhJZHMpO1xuXG4gICAgICAgICAgZ2x5cGhJZHMuZm9yRWFjaCgoZ2x5cGhJZCwgaSkgPT4ge1xuICAgICAgICAgICAgLy8gVHlwciByZXR1cm5zIGEgZ2x5cGggaW5kZXggcGVyIHN0cmluZyBjb2RlcG9pbnQsIHdpdGggLTFzIGluIHBsYWNlIG9mIHRob3NlIHRoYXRcbiAgICAgICAgICAgIC8vIHdlcmUgb21pdHRlZCBkdWUgdG8gbGlnYXR1cmUgc3Vic3RpdHV0aW9uLiBTbyB3ZSBjYW4gdHJhY2sgb3JpZ2luYWwgaW5kZXggaW4gdGhlXG4gICAgICAgICAgICAvLyBzdHJpbmcgdmlhIHNpbXBsZSBpbmNyZW1lbnQsIGFuZCBza2lwIGV2ZXJ5dGhpbmcgZWxzZSB3aGVuIHNlZWluZyBhIC0xLlxuICAgICAgICAgICAgaWYgKGdseXBoSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGxldCBnbHlwaE9iaiA9IGdseXBoTWFwW2dseXBoSWRdO1xuICAgICAgICAgICAgICBpZiAoIWdseXBoT2JqKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge2NtZHMsIGNyZHN9ID0gVHlwci5VLmdseXBoVG9QYXRoKHR5cHJGb250LCBnbHlwaElkKTtcblxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHBhdGggc3RyaW5nXG4gICAgICAgICAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgICAgICAgICBsZXQgY3Jkc0lkeCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNtZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG51bUFyZ3MgPSBjbWRBcmdMZW5ndGhzW2NtZHNbaV1dO1xuICAgICAgICAgICAgICAgICAgcGF0aCArPSBjbWRzW2ldO1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPD0gbnVtQXJnczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gKGogPiAxID8gJywnIDogJycpICsgY3Jkc1tjcmRzSWR4KytdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgZXh0ZW50cyAtIEdseWYgZ2l2ZXMgdGhpcyBpbiBtZXRhZGF0YSBidXQgbm90IENGRiwgYW5kIFR5cHIgZG9lc24ndFxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgdHdvLCBzbyBpdCdzIHNpbXBsZXN0IGp1c3QgdG8gaXRlcmF0ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgbGV0IHhNaW4sIHlNaW4sIHhNYXgsIHlNYXg7XG4gICAgICAgICAgICAgICAgaWYgKGNyZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICB4TWluID0geU1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgeE1heCA9IHlNYXggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IGNyZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGxldCB5ID0gY3Jkc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgeE1pbikgeE1pbiA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5IDwgeU1pbikgeU1pbiA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID4geE1heCkgeE1heCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID4geU1heCkgeU1heCA9IHk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHhNaW4gPSB4TWF4ID0geU1pbiA9IHlNYXggPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdseXBoT2JqID0gZ2x5cGhNYXBbZ2x5cGhJZF0gPSB7XG4gICAgICAgICAgICAgICAgICBpbmRleDogZ2x5cGhJZCxcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2VXaWR0aDogdHlwckZvbnQuaG10eC5hV2lkdGhbZ2x5cGhJZF0sXG4gICAgICAgICAgICAgICAgICB4TWluLFxuICAgICAgICAgICAgICAgICAgeU1pbixcbiAgICAgICAgICAgICAgICAgIHhNYXgsXG4gICAgICAgICAgICAgICAgICB5TWF4LFxuICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGdseXBoT2JqLFxuICAgICAgICAgICAgICAgIHBlblggKyBwb3NpdGlvbnNbaSAqIDNdICogZm9udFNjYWxlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tpICogMyArIDFdICogZm9udFNjYWxlLFxuICAgICAgICAgICAgICAgIGNoYXJJbmRleFxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIHBlblggKz0gcG9zaXRpb25zW2kgKiAzICsgMl0gKiBmb250U2NhbGU7XG4gICAgICAgICAgICAgIGlmIChsZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgICAgICAgICAgcGVuWCArPSBsZXR0ZXJTcGFjaW5nICogZm9udFNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJJbmRleCArPSAodGV4dC5jb2RlUG9pbnRBdChjaGFySW5kZXgpID4gMHhmZmZmID8gMiA6IDEpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHBlblhcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZvbnRPYmpcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSBGb250UGFyc2VyXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhcnNlKGJ1ZmZlcikge1xuICAgICAgLy8gTG9vayB0byBzZWUgaWYgd2UgaGF2ZSBhIFdPRkYgZmlsZSBhbmQgY29udmVydCBpdCBpZiBzbzpcbiAgICAgIGNvbnN0IHBlZWsgPSBuZXcgVWludDhBcnJheShidWZmZXIsIDAsIDQpO1xuICAgICAgY29uc3QgdGFnID0gVHlwci5fYmluLnJlYWRBU0NJSShwZWVrLCAwLCA0KTtcbiAgICAgIGlmICh0YWcgPT09ICd3T0ZGJykge1xuICAgICAgICBidWZmZXIgPSB3b2ZmMm90ZihidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICd3T0YyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvZmYyIGZvbnRzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBGb250T2JqKFR5cHIucGFyc2UoYnVmZmVyKVswXSlcbiAgICB9XG4gIH1cblxuXG4gIGNvbnN0IHdvcmtlck1vZHVsZSA9IC8qI19fUFVSRV9fKi90cm9pa2FXb3JrZXJVdGlscy5kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgIG5hbWU6ICdUeXByIEZvbnQgUGFyc2VyJyxcbiAgICBkZXBlbmRlbmNpZXM6IFt0eXByRmFjdG9yeSwgd29mZjJvdGZGYWN0b3J5LCBwYXJzZXJGYWN0b3J5XSxcbiAgICBpbml0KHR5cHJGYWN0b3J5LCB3b2ZmMm90ZkZhY3RvcnksIHBhcnNlckZhY3RvcnkpIHtcbiAgICAgIGNvbnN0IFR5cHIgPSB0eXByRmFjdG9yeSgpO1xuICAgICAgY29uc3Qgd29mZjJvdGYgPSB3b2ZmMm90ZkZhY3RvcnkoKTtcbiAgICAgIHJldHVybiBwYXJzZXJGYWN0b3J5KFR5cHIsIHdvZmYyb3RmKVxuICAgIH1cbiAgfSk7XG5cbiAgLyohXG4gIEN1c3RvbSBidW5kbGUgb2YgQHVuaWNvZGUtZm9udC1yZXNvbHZlci9jbGllbnQgdjEuMC4yIChodHRwczovL2dpdGh1Yi5jb20vbG9qamljL3VuaWNvZGUtZm9udC1yZXNvbHZlcilcbiAgZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuIFxuICBPcmlnaW5hbCBNSVQgbGljZW5zZSBhcHBsaWVzXG4gICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRGYWN0b3J5KCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPWZ1bmN0aW9uKCl7dGhpcy5idWNrZXRzPW5ldyBNYXA7fTtuLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7dmFyIG49dD4+NTt0aGlzLmJ1Y2tldHMuc2V0KG4sKHRoaXMuYnVja2V0cy5nZXQobil8fDApfDE8PCgzMSZ0KSk7fSxuLnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5idWNrZXRzLmdldCh0Pj41KTtyZXR1cm4gdm9pZCAwIT09biYmMCE9KG4mMTw8KDMxJnQpKX0sbi5wcm90b3R5cGUuc2VyaWFsaXplPWZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHRoaXMuYnVja2V0cy5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3QucHVzaCgoK3IpLnRvU3RyaW5nKDM2KStcIjpcIituLnRvU3RyaW5nKDM2KSk7fSkpLHQuam9pbihcIixcIil9LG4ucHJvdG90eXBlLmRlc2VyaWFsaXplPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7dGhpcy5idWNrZXRzLmNsZWFyKCksdC5zcGxpdChcIixcIikuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9dC5zcGxpdChcIjpcIik7bi5idWNrZXRzLnNldChwYXJzZUludChyWzBdLDM2KSxwYXJzZUludChyWzFdLDM2KSk7fSkpO307dmFyIHI9TWF0aC5wb3coMiw4KSxlPXItMSxvPX5lO2Z1bmN0aW9uIGEodCl7dmFyIG49ZnVuY3Rpb24odCl7cmV0dXJuIHQmb30odCkudG9TdHJpbmcoMTYpLGU9ZnVuY3Rpb24odCl7cmV0dXJuICh0Jm8pK3ItMX0odCkudG9TdHJpbmcoMTYpO3JldHVybiBcImNvZGVwb2ludC1pbmRleC9wbGFuZVwiKyh0Pj4xNikrXCIvXCIrbitcIi1cIitlK1wiLmpzb25cIn1mdW5jdGlvbiBpKHQsbil7dmFyIHI9dCZlLG89bi5jb2RlUG9pbnRBdChyLzZ8MCk7cmV0dXJuIDAhPSgobz0ob3x8NDgpLTQ4KSYxPDxyJTYpfWZ1bmN0aW9uIHUodCxuKXt2YXIgcjsocj10LHIucmVwbGFjZSgvVVxcKy9naSxcIlwiKS5yZXBsYWNlKC9eLCt8LCskL2csXCJcIikuc3BsaXQoLywrLykubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGxpdChcIi1cIikubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gcGFyc2VJbnQodC50cmltKCksMTYpfSkpfSkpKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgcj10WzBdLGU9dFsxXTt2b2lkIDA9PT1lJiYoZT1yKSxuKHIsZSk7fSkpO31mdW5jdGlvbiBjKHQsbil7dSh0LChmdW5jdGlvbih0LHIpe2Zvcih2YXIgZT10O2U8PXI7ZSsrKW4oZSk7fSkpO312YXIgcz17fSxmPXt9LGw9bmV3IFdlYWtNYXAsdj1cImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9sb2pqaWMvdW5pY29kZS1mb250LXJlc29sdmVyQHYxLjAuMS9wYWNrYWdlcy9kYXRhXCI7ZnVuY3Rpb24gZCh0KXt2YXIgcj1sLmdldCh0KTtyZXR1cm4gcnx8KHI9bmV3IG4sYyh0LnJhbmdlcywoZnVuY3Rpb24odCl7cmV0dXJuIHIuYWRkKHQpfSkpLGwuc2V0KHQscikpLHJ9dmFyIGgscD1uZXcgTWFwO2Z1bmN0aW9uIGcodCxuLHIpe3JldHVybiB0W25dP246dFtyXT9yOmZ1bmN0aW9uKHQpe2Zvcih2YXIgbiBpbiB0KXJldHVybiBufSh0KX1mdW5jdGlvbiB3KHQsbil7dmFyIHI9bjtpZighdC5pbmNsdWRlcyhyKSl7cj0xLzA7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspTWF0aC5hYnModFtlXS1uKTxNYXRoLmFicyhyLW4pJiYocj10W2VdKTt9cmV0dXJuIHJ9ZnVuY3Rpb24gayh0KXtyZXR1cm4gaHx8KGg9bmV3IFNldCxjKFwiOS1ELDIwLDg1LEEwLDE2ODAsMjAwMC0yMDBBLDIwMjgtMjAyRiwyMDVGLDMwMDBcIiwoZnVuY3Rpb24odCl7aC5hZGQodCk7fSkpKSxoLmhhcyh0KX1yZXR1cm4gdC5Db2RlUG9pbnRTZXQ9bix0LmNsZWFyQ2FjaGU9ZnVuY3Rpb24oKXtzPXt9LGY9e307fSx0LmdldEZvbnRzRm9yU3RyaW5nPWZ1bmN0aW9uKHQsbil7dm9pZCAwPT09biYmKG49e30pO3ZhciByLGU9bi5sYW5nO3ZvaWQgMD09PWUmJihlPS9cXHB7U2NyaXB0PUhhbmd1bH0vdS50ZXN0KHI9dCk/XCJrb1wiOi9cXHB7U2NyaXB0PUhpcmFnYW5hfXxcXHB7U2NyaXB0PUthdGFrYW5hfS91LnRlc3Qocik/XCJqYVwiOlwiZW5cIik7dmFyIG89bi5jYXRlZ29yeTt2b2lkIDA9PT1vJiYobz1cInNhbnMtc2VyaWZcIik7dmFyIHU9bi5zdHlsZTt2b2lkIDA9PT11JiYodT1cIm5vcm1hbFwiKTt2YXIgYz1uLndlaWdodDt2b2lkIDA9PT1jJiYoYz00MDApO3ZhciBsPShuLmRhdGFVcmx8fHYpLnJlcGxhY2UoL1xcLyQvZyxcIlwiKSxoPW5ldyBNYXAseT1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCksYj17fSxtPXt9LEE9bmV3IEFycmF5KHQubGVuZ3RoKSxTPW5ldyBNYXAsaj0hMTtmdW5jdGlvbiBNKHQpe3ZhciBuPXAuZ2V0KHQpO3JldHVybiBufHwobj1mZXRjaChsK1wiL1wiK3QpLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93IG5ldyBFcnJvcih0LnN0YXR1c1RleHQpO3JldHVybiB0Lmpzb24oKS50aGVuKChmdW5jdGlvbih0KXtpZighQXJyYXkuaXNBcnJheSh0KXx8MSE9PXRbMF0pdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IHNjaGVtYSB2ZXJzaW9uOyBuZWVkIDEsIGdvdCBcIit0WzBdKTtyZXR1cm4gdFsxXX0pKX0pKS5jYXRjaCgoZnVuY3Rpb24obil7aWYobCE9PXYpcmV0dXJuIGp8fChjb25zb2xlLmVycm9yKCd1bmljb2RlLWZvbnQtcmVzb2x2ZXI6IEZhaWxlZCBsb2FkaW5nIGZyb20gZGF0YVVybCBcIicrbCsnXCIsIHRyeWluZyBkZWZhdWx0IENETi4gJytuLm1lc3NhZ2UpLGo9ITApLGw9dixwLmRlbGV0ZSh0KSxNKHQpO3Rocm93IG59KSkscC5zZXQodCxuKSksbn1mb3IodmFyIFA9ZnVuY3Rpb24obil7dmFyIHI9dC5jb2RlUG9pbnRBdChuKSxlPWEocik7QVtuXT1lLHNbZV18fFMuaGFzKGUpfHxTLnNldChlLE0oZSkudGhlbigoZnVuY3Rpb24odCl7c1tlXT10O30pKSkscj42NTUzNSYmKG4rKyxFPW4pO30sRT0wO0U8dC5sZW5ndGg7RSsrKVAoRSk7cmV0dXJuIFByb21pc2UuYWxsKFMudmFsdWVzKCkpLnRoZW4oKGZ1bmN0aW9uKCl7Uy5jbGVhcigpO2Zvcih2YXIgbj1mdW5jdGlvbihuKXt2YXIgbz10LmNvZGVQb2ludEF0KG4pLGE9bnVsbCx1PXNbQVtuXV0sYz12b2lkIDA7Zm9yKHZhciBsIGluIHUpe3ZhciB2PW1bbF07aWYodm9pZCAwPT09diYmKHY9bVtsXT1uZXcgUmVnRXhwKGwpLnRlc3QoZXx8XCJlblwiKSksdil7Zm9yKHZhciBkIGluIGM9bCx1W2xdKWlmKGkobyx1W2xdW2RdKSl7YT1kO2JyZWFrfWJyZWFrfX1pZighYSl0OmZvcih2YXIgaCBpbiB1KWlmKGghPT1jKWZvcih2YXIgcCBpbiB1W2hdKWlmKGkobyx1W2hdW3BdKSl7YT1wO2JyZWFrIHR9YXx8KGNvbnNvbGUuZGVidWcoXCJObyBmb250IGNvdmVyYWdlIGZvciBVK1wiK28udG9TdHJpbmcoMTYpKSxhPVwibGF0aW5cIiksQVtuXT1hLGZbYV18fFMuaGFzKGEpfHxTLnNldChhLE0oXCJmb250LW1ldGEvXCIrYStcIi5qc29uXCIpLnRoZW4oKGZ1bmN0aW9uKHQpe2ZbYV09dDt9KSkpLG8+NjU1MzUmJihuKysscj1uKTt9LHI9MDtyPHQubGVuZ3RoO3IrKyluKHIpO3JldHVybiBQcm9taXNlLmFsbChTLnZhbHVlcygpKX0pKS50aGVuKChmdW5jdGlvbigpe2Zvcih2YXIgbixyPW51bGwsZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgYT10LmNvZGVQb2ludEF0KGUpO2lmKHImJihrKGEpfHxkKHIpLmhhcyhhKSkpeVtlXT15W2UtMV07ZWxzZSB7cj1mW0FbZV1dO3ZhciBpPWJbci5pZF07aWYoIWkpe3ZhciBzPXIudHlwZWZvcm1zLHY9ZyhzLG8sXCJzYW5zLXNlcmlmXCIpLHA9ZyhzW3ZdLHUsXCJub3JtYWxcIiksbT13KG51bGw9PT0obj1zW3ZdKXx8dm9pZCAwPT09bj92b2lkIDA6bltwXSxjKTtpPWJbci5pZF09bCtcIi9mb250LWZpbGVzL1wiK3IuaWQrXCIvXCIrditcIi5cIitwK1wiLlwiK20rXCIud29mZlwiO312YXIgUz1oLmdldChpKTtudWxsPT1TJiYoUz1oLnNpemUsaC5zZXQoaSxTKSkseVtlXT1TO31hPjY1NTM1JiYoZSsrLHlbZV09eVtlLTFdKTt9cmV0dXJuIHtmb250VXJsczpBcnJheS5mcm9tKGgua2V5cygpKSxjaGFyczp5fX0pKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdH0oe30pfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7c3RyaW5nIHwge3NyYzpzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIHVuaWNvZGVSYW5nZT86c3RyaW5nLCBsYW5nPzpzdHJpbmd9fSBVc2VyRm9udFxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge0NsaWVudE9wdGlvbnN9IEZvbnRSZXNvbHZlck9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtBcnJheTxVc2VyRm9udD58VXNlckZvbnR9IFtmb250c11cbiAgICogQHByb3BlcnR5IHsnbm9ybWFsJ3wnaXRhbGljJ30gW3N0eWxlXVxuICAgKiBAcHJvcGVydHkgeydub3JtYWwnfCdib2xkJ3xudW1iZXJ9IFtzdHlsZV1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1bmljb2RlRm9udHNVUkxdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBGb250UmVzb2x2ZXJSZXN1bHRcbiAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBjaGFyc1xuICAgKiBAcHJvcGVydHkge0FycmF5PFBhcnNlZEZvbnQgJiB7c3JjOnN0cmluZ30+fSBmb250c1xuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge2Z1bmN0aW9ufSBGb250UmVzb2x2ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHsoRm9udFJlc29sdmVyUmVzdWx0KSA9PiB2b2lkfSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0ZvbnRSZXNvbHZlck9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cblxuICAvKipcbiAgICogRmFjdG9yeSBmb3IgdGhlIEZvbnRSZXNvbHZlciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtGb250UGFyc2VyfSBmb250UGFyc2VyXG4gICAqIEBwYXJhbSB7e2dldEZvbnRzRm9yU3RyaW5nOiBmdW5jdGlvbiwgQ29kZVBvaW50U2V0OiBmdW5jdGlvbn19IHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRcbiAgICogQHJldHVybiB7Rm9udFJlc29sdmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRm9udFJlc29sdmVyKGZvbnRQYXJzZXIsIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgUGFyc2VkRm9udD59XG4gICAgICovXG4gICAgY29uc3QgcGFyc2VkRm9udHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1JlY29yZDxzdHJpbmcsIEFycmF5PChQYXJzZWRGb250KSA9PiB2b2lkPj59XG4gICAgICovXG4gICAgY29uc3QgbG9hZGluZ0ZvbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgYSBnaXZlbiBmb250IHVybFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvTG9hZEZvbnQodXJsLCBjYWxsYmFjaykge1xuICAgICAgY29uc3Qgb25FcnJvciA9IGVyciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWx1cmUgbG9hZGluZyBmb250ICR7dXJsfWAsIGVycik7XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzID4gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgZm9udE9iaiA9IGZvbnRQYXJzZXIocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIGZvbnRPYmouc3JjID0gdXJsO1xuICAgICAgICAgICAgICBjYWxsYmFjayhmb250T2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IG9uRXJyb3I7XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsIGlmIG5lZWRlZCwgaW52b2tpbmcgYSBjYWxsYmFjayB3aGVuIGl0J3MgbG9hZGVkLiBJZiBhbHJlYWR5XG4gICAgICogbG9hZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udFVybFxuICAgICAqIEBwYXJhbSB7KGZvbnQ6IFBhcnNlZEZvbnQpID0+IHZvaWR9IGNhbGxiYWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZEZvbnQoZm9udFVybCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCBmb250ID0gcGFyc2VkRm9udHNbZm9udFVybF07XG4gICAgICBpZiAoZm9udCkge1xuICAgICAgICBjYWxsYmFjayhmb250KTtcbiAgICAgIH0gZWxzZSBpZiAobG9hZGluZ0ZvbnRzW2ZvbnRVcmxdKSB7XG4gICAgICAgIGxvYWRpbmdGb250c1tmb250VXJsXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRpbmdGb250c1tmb250VXJsXSA9IFtjYWxsYmFja107XG4gICAgICAgIGRvTG9hZEZvbnQoZm9udFVybCwgZm9udE9iaiA9PiB7XG4gICAgICAgICAgZm9udE9iai5zcmMgPSBmb250VXJsO1xuICAgICAgICAgIHBhcnNlZEZvbnRzW2ZvbnRVcmxdID0gZm9udE9iajtcbiAgICAgICAgICBsb2FkaW5nRm9udHNbZm9udFVybF0uZm9yRWFjaChjYiA9PiBjYihmb250T2JqKSk7XG4gICAgICAgICAgZGVsZXRlIGxvYWRpbmdGb250c1tmb250VXJsXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgZ2l2ZW4gc3RyaW5nIG9mIHRleHQsIGRldGVybWluZSB3aGljaCBmb250cyBhcmUgcmVxdWlyZWQgdG8gZnVsbHkgcmVuZGVyIGl0IGFuZFxuICAgICAqIGVuc3VyZSB0aG9zZSBmb250cyBhcmUgbG9hZGVkLlxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiAodGV4dCwgY2FsbGJhY2ssIHtcbiAgICAgIGxhbmcsXG4gICAgICBmb250czogdXNlckZvbnRzID0gW10sXG4gICAgICBzdHlsZSA9ICdub3JtYWwnLFxuICAgICAgd2VpZ2h0ID0gJ25vcm1hbCcsXG4gICAgICB1bmljb2RlRm9udHNVUkxcbiAgICB9ID0ge30pIHtcbiAgICAgIGNvbnN0IGNoYXJSZXNvbHV0aW9ucyA9IG5ldyBVaW50OEFycmF5KHRleHQubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGZvbnRSZXNvbHV0aW9ucyA9IFtdO1xuICAgICAgaWYgKCF0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBhbGxEb25lKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvbnRJbmRpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgZmFsbGJhY2tSYW5nZXMgPSBbXTsgLy8gW1tzdGFydCwgZW5kXSwgLi4uXVxuXG4gICAgICBpZiAoc3R5bGUgIT09ICdpdGFsaWMnKSBzdHlsZSA9ICdub3JtYWwnO1xuICAgICAgaWYgKHR5cGVvZiB3ZWlnaHQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHdlaWdodCA9IHdlaWdodCA9PT0gJ2JvbGQnID8gNzAwIDogNDAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodXNlckZvbnRzICYmICFBcnJheS5pc0FycmF5KHVzZXJGb250cykpIHtcbiAgICAgICAgdXNlckZvbnRzID0gW3VzZXJGb250c107XG4gICAgICB9XG4gICAgICB1c2VyRm9udHMgPSB1c2VyRm9udHMuc2xpY2UoKVxuICAgICAgICAvLyBmaWx0ZXIgYnkgbGFuZ3VhZ2VcbiAgICAgICAgLmZpbHRlcihkZWYgPT4gIWRlZi5sYW5nIHx8IGRlZi5sYW5nLnRlc3QobGFuZykpXG4gICAgICAgIC8vIHN3aXRjaCBvcmRlciBmb3IgZWFzaWVyIGl0ZXJhdGlvblxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgICAgaWYgKHVzZXJGb250cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgVU5LTk9XTiA9IDA7XG4gICAgICAgIGNvbnN0IFJFU09MVkVEID0gMTtcbiAgICAgICAgY29uc3QgTkVFRFNfRkFMTEJBQ0sgPSAyO1xuICAgICAgICBsZXQgcHJldkNoYXJSZXN1bHQgPSBVTktOT1dOXG5cbiAgICAgICAgOyhmdW5jdGlvbiByZXNvbHZlVXNlckZvbnRzIChzdGFydEluZGV4ID0gMCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4LCBpTGVuID0gdGV4dC5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IHRleHQuY29kZVBvaW50QXQoaSk7XG4gICAgICAgICAgICAvLyBDYXJyeSBwcmV2aW91cyBjaGFyYWN0ZXIncyByZXN1bHQgZm9yd2FyZCBpZjpcbiAgICAgICAgICAgIC8vIC0gaXQgcmVzb2x2ZWQgdG8gYSBmb250IHRoYXQgYWxzbyBjb3ZlcnMgdGhpcyBjaGFyYWN0ZXJcbiAgICAgICAgICAgIC8vIC0gdGhpcyBjaGFyYWN0ZXIgaXMgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAocHJldkNoYXJSZXN1bHQgPT09IFJFU09MVkVEICYmIGZvbnRSZXNvbHV0aW9uc1tjaGFyUmVzb2x1dGlvbnNbaSAtIDFdXS5zdXBwb3J0c0NvZGVQb2ludChjb2RlUG9pbnQpKSB8fFxuICAgICAgICAgICAgICAvXFxzLy50ZXN0KHRleHRbaV0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2ldID0gY2hhclJlc29sdXRpb25zW2kgLSAxXTtcbiAgICAgICAgICAgICAgaWYgKHByZXZDaGFyUmVzdWx0ID09PSBORUVEU19GQUxMQkFDSykge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrUmFuZ2VzW2ZhbGxiYWNrUmFuZ2VzLmxlbmd0aCAtIDFdWzFdID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSBjaGFyUmVzb2x1dGlvbnNbaV0sIGpMZW4gPSB1c2VyRm9udHMubGVuZ3RoOyBqIDw9IGpMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBqTGVuKSB7XG4gICAgICAgICAgICAgICAgICAvLyBub25lIG9mIHRoZSB1c2VyIGZvbnRzIG1hdGNoZWQ7IG5lZWRzIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHByZXZDaGFyUmVzdWx0ID09PSBORUVEU19GQUxMQkFDSyA/XG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUmFuZ2VzW2ZhbGxiYWNrUmFuZ2VzLmxlbmd0aCAtIDFdIDpcbiAgICAgICAgICAgICAgICAgICAgKGZhbGxiYWNrUmFuZ2VzW2ZhbGxiYWNrUmFuZ2VzLmxlbmd0aF0gPSBbaSwgaV0pO1xuICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gPSBpO1xuICAgICAgICAgICAgICAgICAgcHJldkNoYXJSZXN1bHQgPSBORUVEU19GQUxMQkFDSztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2ldID0gajtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3JjLCB1bmljb2RlUmFuZ2UgfSA9IHVzZXJGb250c1tqXTtcbiAgICAgICAgICAgICAgICAgIC8vIGZpbHRlciBieSBvcHRpb25hbCBleHBsaWNpdCB1bmljb2RlIHJhbmdlc1xuICAgICAgICAgICAgICAgICAgaWYgKCF1bmljb2RlUmFuZ2UgfHwgaXNDb2RlSW5SYW5nZXMoY29kZVBvaW50LCB1bmljb2RlUmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRPYmogPSBwYXJzZWRGb250c1tzcmNdO1xuICAgICAgICAgICAgICAgICAgICAvLyBmb250IG5vdCB5ZXQgbG9hZGVkLCBsb2FkIGl0IGFuZCByZXN1bWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb250T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9hZEZvbnQoc3JjLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlVXNlckZvbnRzKGkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZm9udCBhY3R1YWxseSBjb250YWlucyBhIGdseXBoIGZvciB0aGlzIGNoYXIsIGxvY2sgaXQgaW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbnRPYmouc3VwcG9ydHNDb2RlUG9pbnQoY29kZVBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBmb250SW5kZXggPSBmb250SW5kaWNlcy5nZXQoZm9udE9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb250SW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250SW5kZXggPSBmb250UmVzb2x1dGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFJlc29sdXRpb25zLnB1c2goZm9udE9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250SW5kaWNlcy5zZXQoZm9udE9iaiwgZm9udEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2ldID0gZm9udEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgIHByZXZDaGFyUmVzdWx0ID0gUkVTT0xWRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4ZmZmZiAmJiBpICsgMSA8IGlMZW4pIHtcbiAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2kgKyAxXSA9IGNoYXJSZXNvbHV0aW9uc1tpXTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBpZiAocHJldkNoYXJSZXN1bHQgPT09IE5FRURTX0ZBTExCQUNLKSB7XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoIC0gMV1bMV0gPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmVGYWxsYmFja3MoKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhbGxiYWNrUmFuZ2VzLnB1c2goWzAsIHRleHQubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXNvbHZlRmFsbGJhY2tzKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVGYWxsYmFja3MoKSB7XG4gICAgICAgIGlmIChmYWxsYmFja1Jhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBDb21iaW5lIGFsbCBmYWxsYmFjayBzdWJzdHJpbmdzIGludG8gYSBzaW5nbGUgc3RyaW5nIGZvciBxdWVyeWluZ1xuICAgICAgICAgIGNvbnN0IGZhbGxiYWNrU3RyaW5nID0gZmFsbGJhY2tSYW5nZXMubWFwKHJhbmdlID0+IHRleHQuc3Vic3RyaW5nKHJhbmdlWzBdLCByYW5nZVsxXSArIDEpKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50LmdldEZvbnRzRm9yU3RyaW5nKGZhbGxiYWNrU3RyaW5nLCB7XG4gICAgICAgICAgICBsYW5nOiBsYW5nIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgd2VpZ2h0LFxuICAgICAgICAgICAgZGF0YVVybDogdW5pY29kZUZvbnRzVVJMXG4gICAgICAgICAgfSkudGhlbigoe2ZvbnRVcmxzLCBjaGFyc30pID0+IHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgcmVzdWx0cyBhbmQgcHV0IHRoZW0gYmFjayBpbiB0aGUgbWFpbiBhcnJheVxuICAgICAgICAgICAgY29uc3QgZm9udEluZGV4T2Zmc2V0ID0gZm9udFJlc29sdXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjaGFySWR4ID0gMDtcbiAgICAgICAgICAgIGZhbGxiYWNrUmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZW5kSWR4ID0gcmFuZ2VbMV0gLSByYW5nZVswXTsgaSA8PSBlbmRJZHg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoYXJSZXNvbHV0aW9uc1tyYW5nZVswXSArIGldID0gY2hhcnNbY2hhcklkeCsrXSArIGZvbnRJbmRleE9mZnNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGFySWR4Kys7IC8vc2tpcCBzZWdtZW50IHNlcGFyYXRvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIExvYWQgYW5kIHBhcnNlIHRoZSBmYWxsYmFjayBmb250cyAtIGF2b2lkaW5nIFByb21pc2UgaGVyZSB0byBwcmV2ZW50IHBvbHlmaWxscyBpbiB0aGUgd29ya2VyXG4gICAgICAgICAgICBsZXQgbG9hZGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9udFVybHMuZm9yRWFjaCgodXJsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGxvYWRGb250KHVybCwgZm9udE9iaiA9PiB7XG4gICAgICAgICAgICAgICAgZm9udFJlc29sdXRpb25zW2kgKyBmb250SW5kZXhPZmZzZXRdID0gZm9udE9iajtcbiAgICAgICAgICAgICAgICBpZiAoKytsb2FkZWRDb3VudCA9PT0gZm9udFVybHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBhbGxEb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbERvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhbGxEb25lKCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgY2hhcnM6IGNoYXJSZXNvbHV0aW9ucyxcbiAgICAgICAgICBmb250czogZm9udFJlc29sdXRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0NvZGVJblJhbmdlcyhjb2RlLCByYW5nZXMpIHtcbiAgICAgICAgLy8gdG9kbyBvcHRpbWl6ZSBzZWFyY2ggLSBDb2RlUG9pbnRTZXQgZnJvbSB1bmljb2RlLWZvbnQtcmVzb2x2ZXI/XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmFuZ2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmQgPSBzdGFydF0gPSByYW5nZXNba107XG4gICAgICAgICAgaWYgKHN0YXJ0IDw9IGNvZGUgJiYgY29kZSA8PSBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZvbnRSZXNvbHZlcldvcmtlck1vZHVsZSA9IC8qI19fUFVSRV9fKi90cm9pa2FXb3JrZXJVdGlscy5kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgIG5hbWU6ICdGb250UmVzb2x2ZXInLFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgY3JlYXRlRm9udFJlc29sdmVyLFxuICAgICAgd29ya2VyTW9kdWxlLFxuICAgICAgdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudEZhY3RvcnksXG4gICAgXSxcbiAgICBpbml0KGNyZWF0ZUZvbnRSZXNvbHZlciwgZm9udFBhcnNlciwgdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudEZhY3RvcnkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGb250UmVzb2x2ZXIoZm9udFBhcnNlciwgdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudEZhY3RvcnkoKSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHR5cGVkZWYge251bWJlcnwnbGVmdCd8J2NlbnRlcid8J3JpZ2h0J30gQW5jaG9yWFZhbHVlXG4gICAqL1xuICAvKipcbiAgICogQHR5cGVkZWYge251bWJlcnwndG9wJ3wndG9wLWJhc2VsaW5lJ3wndG9wLWNhcCd8J3RvcC1leCd8J21pZGRsZSd8J2JvdHRvbS1iYXNlbGluZSd8J2JvdHRvbSd9IEFuY2hvcllWYWx1ZVxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gVHlwZXNldFBhcmFtc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dFxuICAgKiBAcHJvcGVydHkge1VzZXJGb250fFVzZXJGb250W119IFtmb250XVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2xhbmddXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2RmR2x5cGhTaXplPTY0XVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2ZvbnRTaXplPTFdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfCdub3JtYWwnfCdib2xkJ30gW2ZvbnRXZWlnaHQ9J25vcm1hbCddXG4gICAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2l0YWxpYyd9IFtmb250U3R5bGU9J25vcm1hbCddXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGV0dGVyU3BhY2luZz0wXVxuICAgKiBAcHJvcGVydHkgeydub3JtYWwnfG51bWJlcn0gW2xpbmVIZWlnaHQ9J25vcm1hbCddXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4V2lkdGhdXG4gICAqIEBwcm9wZXJ0eSB7J2x0cid8J3J0bCd9IFtkaXJlY3Rpb249J2x0ciddXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGV4dEFsaWduPSdsZWZ0J11cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt0ZXh0SW5kZW50PTBdXG4gICAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J25vd3JhcCd9IFt3aGl0ZVNwYWNlPSdub3JtYWwnXVxuICAgKiBAcHJvcGVydHkgeydub3JtYWwnfCdicmVhay13b3JkJ30gW292ZXJmbG93V3JhcD0nbm9ybWFsJ11cbiAgICogQHByb3BlcnR5IHtBbmNob3JYVmFsdWV9IFthbmNob3JYPTBdXG4gICAqIEBwcm9wZXJ0eSB7QW5jaG9yWVZhbHVlfSBbYW5jaG9yWT0wXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttZXRyaWNzT25seT1mYWxzZV1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1bmljb2RlRm9udHNVUkxdXG4gICAqIEBwcm9wZXJ0eSB7Rm9udFJlc29sdmVyUmVzdWx0fSBbcHJlUmVzb2x2ZWRGb250c11cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW5jbHVkZUNhcmV0UG9zaXRpb25zPWZhbHNlXVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2NodW5rZWRCb3VuZHNTaXplPTgxOTJdXG4gICAqIEBwcm9wZXJ0eSB7e1tyYW5nZVN0YXJ0SW5kZXhdOiBudW1iZXJ9fSBbY29sb3JSYW5nZXNdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBUeXBlc2V0UmVzdWx0XG4gICAqIEBwcm9wZXJ0eSB7VWludDE2QXJyYXl9IGdseXBoSWRzIGlkIGZvciBlYWNoIGdseXBoLCBzcGVjaWZpYyB0byB0aGF0IGdseXBoJ3MgZm9udFxuICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IGdseXBoRm9udEluZGljZXMgaW5kZXggaW50byBmb250RGF0YSBmb3IgZWFjaCBnbHlwaFxuICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZ2x5cGhQb3NpdGlvbnMgeCx5IG9mIGVhY2ggZ2x5cGgncyBvcmlnaW4gaW4gbGF5b3V0XG4gICAqIEBwcm9wZXJ0eSB7e1tmb250XToge1tnbHlwaElkXToge3BhdGg6IHN0cmluZywgcGF0aEJvdW5kczogbnVtYmVyW119fX19IGdseXBoRGF0YSBkYXRhIGFib3V0IGVhY2ggZ2x5cGggYXBwZWFyaW5nIGluIHRoZSB0ZXh0XG4gICAqIEBwcm9wZXJ0eSB7VHlwZXNldEZvbnREYXRhW119IGZvbnREYXRhIGRhdGEgYWJvdXQgZWFjaCBmb250IHVzZWQgaW4gdGhlIHRleHRcbiAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IFtjYXJldFBvc2l0aW9uc10gc3RhcnRYLGVuZFgsYm90dG9tWSBjYXJldCBwb3NpdGlvbnMgZm9yIGVhY2ggY2hhclxuICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IFtnbHlwaENvbG9yc10gY29sb3IgZm9yIGVhY2ggZ2x5cGgsIGlmIGNvbG9yIHJhbmdlcyBzdXBwbGllZFxuICAgKiAgICAgICAgIGNodW5rZWRCb3VuZHMsIC8vdG90YWwgcmVjdHMgcGVyIChuPWNodW5rZWRCb3VuZHNTaXplKSBjb25zZWN1dGl2ZSBnbHlwaHNcbiAgICogICAgICAgICBmb250U2l6ZSwgLy9jYWxjdWxhdGVkIGVtIGhlaWdodFxuICAgKiAgICAgICAgIHRvcEJhc2VsaW5lOiBhbmNob3JZT2Zmc2V0ICsgbGluZXNbMF0uYmFzZWxpbmUsIC8veSBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lXG4gICAqICAgICAgICAgYmxvY2tCb3VuZHM6IFsgLy9ib3VuZHMgZm9yIHRoZSB3aG9sZSBibG9jayBvZiB0ZXh0LCBpbmNsdWRpbmcgdmVydGljYWwgcGFkZGluZyBmb3IgbGluZUhlaWdodFxuICAgKiAgICAgICAgICAgYW5jaG9yWE9mZnNldCxcbiAgICogICAgICAgICAgIGFuY2hvcllPZmZzZXQgLSB0b3RhbEhlaWdodCxcbiAgICogICAgICAgICAgIGFuY2hvclhPZmZzZXQgKyBtYXhMaW5lV2lkdGgsXG4gICAqICAgICAgICAgICBhbmNob3JZT2Zmc2V0XG4gICAqICAgICAgICAgXSxcbiAgICogICAgICAgICB2aXNpYmxlQm91bmRzLCAvL3RvdGFsIGJvdW5kcyBvZiB2aXNpYmxlIHRleHQgcGF0aHMsIG1heSBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIGJsb2NrQm91bmRzXG4gICAqICAgICAgICAgdGltaW5nc1xuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gVHlwZXNldEZvbnREYXRhXG4gICAqIEBwcm9wZXJ0eSBzcmNcbiAgICogQHByb3BlcnR5IHVuaXRzUGVyRW1cbiAgICogQHByb3BlcnR5IGFzY2VuZGVyXG4gICAqIEBwcm9wZXJ0eSBkZXNjZW5kZXJcbiAgICogQHByb3BlcnR5IGxpbmVIZWlnaHRcbiAgICogQHByb3BlcnR5IGNhcEhlaWdodFxuICAgKiBAcHJvcGVydHkgeEhlaWdodFxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge2Z1bmN0aW9ufSBUeXBlc2V0dGVyVHlwZXNldEZ1bmN0aW9uIC0gY29tcHV0ZSBmb250cyBhbmQgbGF5b3V0IGZvciBzb21lIHRleHQuXG4gICAqIEBwYXJhbSB7VHlwZXNldFBhcmFtc30gcGFyYW1zXG4gICAqIEBwYXJhbSB7KFR5cGVzZXRSZXN1bHQpID0+IHZvaWR9IGNhbGxiYWNrIC0gZnVuY3Rpb24gY2FsbGVkIHdoZW4gdHlwZXNldHRpbmcgaXMgY29tcGxldGUuXG4gICAqICAgIElmIHRoZSBwYXJhbXMgaW5jbHVkZWQgYHByZVJlc29sdmVkRm9udHNgLCB0aGlzIHdpbGwgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7ZnVuY3Rpb259IFR5cGVzZXR0ZXJNZWFzdXJlRnVuY3Rpb24gLSBjb21wdXRlIHdpZHRoL2hlaWdodCBmb3Igc29tZSB0ZXh0LlxuICAgKiBAcGFyYW0ge1R5cGVzZXRQYXJhbXN9IHBhcmFtc1xuICAgKiBAcGFyYW0geyh3aWR0aDpudW1iZXIsIGhlaWdodDpudW1iZXIpID0+IHZvaWR9IGNhbGxiYWNrIC0gZnVuY3Rpb24gY2FsbGVkIHdoZW4gbWVhc3VyZW1lbnQgaXMgY29tcGxldGUuXG4gICAqICAgIElmIHRoZSBwYXJhbXMgaW5jbHVkZWQgYHByZVJlc29sdmVkRm9udHNgLCB0aGlzIHdpbGwgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc2VsZi1jb250YWluZWQgZW52aXJvbm1lbnQgZm9yIHByb2Nlc3NpbmcgdGV4dCB0eXBlc2V0dGluZyByZXF1ZXN0cy5cbiAgICpcbiAgICogSXQgaXMgaW1wb3J0YW50IHRoYXQgdGhpcyBmdW5jdGlvbiBoYXMgbm8gY2xvc3VyZSBkZXBlbmRlbmNpZXMsIHNvIHRoYXQgaXQgY2FuIGJlIGVhc2lseSBpbmplY3RlZFxuICAgKiBpbnRvIHRoZSBzb3VyY2UgZm9yIGEgV29ya2VyIHdpdGhvdXQgcmVxdWlyaW5nIGEgYnVpbGQgc3RlcCBvciBjb21wbGV4IGRlcGVuZGVuY3kgbG9hZGluZy4gQWxsIGl0c1xuICAgKiBkZXBlbmRlbmNpZXMgbXVzdCBiZSBwYXNzZWQgaW4gYXQgaW5pdGlhbGl6YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Rm9udFJlc29sdmVyfSByZXNvbHZlRm9udHMgLSBmdW5jdGlvbiB0byByZXNvbHZlIGEgc3RyaW5nIHRvIHBhcnNlZCBmb250c1xuICAgKiBAcGFyYW0ge29iamVjdH0gYmlkaSAtIHRoZSBiaWRpLmpzIGltcGxlbWVudGF0aW9uIG9iamVjdFxuICAgKiBAcmV0dXJuIHt7dHlwZXNldDogVHlwZXNldHRlclR5cGVzZXRGdW5jdGlvbiwgbWVhc3VyZTogVHlwZXNldHRlck1lYXN1cmVGdW5jdGlvbn19XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVUeXBlc2V0dGVyKHJlc29sdmVGb250cywgYmlkaSkge1xuICAgIGNvbnN0IElORiA9IEluZmluaXR5O1xuXG4gICAgLy8gU2V0IG9mIFVuaWNvZGUgRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBjaGFyYWN0ZXJzLCB0aGVzZSB3aWxsIG5vdCBwcm9kdWNlIHZpc2libGUgZ2x5cGhzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzXG4gICAgY29uc3QgREVGQVVMVF9JR05PUkFCTEVfQ0hBUlMgPSAvW1xcdTAwQURcXHUwMzRGXFx1MDYxQ1xcdTExNUYtXFx1MTE2MFxcdTE3QjQtXFx1MTdCNVxcdTE4MEItXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2RlxcdTMxNjRcXHVGRTAwLVxcdUZFMEZcXHVGRUZGXFx1RkZBMFxcdUZGRjAtXFx1RkZGOF0vO1xuXG4gICAgLy8gVGhpcyByZWdleCAoaW5zdGVhZCBvZiAvXFxzLykgYWxsb3dzIHVzIHRvIHNlbGVjdCBhbGwgd2hpdGVzcGFjZSBFWENFUFQgZm9yIG5vbi1icmVha2luZyB3aGl0ZSBzcGFjZXNcbiAgICBjb25zdCBsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlID0gYFteXFxcXFNcXFxcdTAwQTBdYDtcblxuICAgIC8vIEluY29tcGxldGUgc2V0IG9mIGNoYXJhY3RlcnMgdGhhdCBhbGxvdyBsaW5lIGJyZWFraW5nIGFmdGVyIHRoZW1cbiAgICAvLyBJbiB0aGUgZnV0dXJlIHdlIG1heSBjb25zaWRlciBhIGZ1bGwgVW5pY29kZSBsaW5lIGJyZWFraW5nIGFsZ29yaXRobSBpbXBsOiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMTRcbiAgICBjb25zdCBCUkVBS19BRlRFUl9DSEFSUyA9IG5ldyBSZWdFeHAoYCR7bGluZUJyZWFraW5nV2hpdGVTcGFjZX18W1xcXFwtXFxcXHUwMDdDXFxcXHUwMEFEXFxcXHUyMDEwXFxcXHUyMDEyLVxcXFx1MjAxNFxcXFx1MjAyN1xcXFx1MjA1NlxcXFx1MkUxN1xcXFx1MkU0MF1gKTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgYW5kIHBhcnNlIGFsbCB0aGUgbmVjZXNzYXJ5IGZvbnRzIHRvIHJlbmRlciBhIGdpdmVuIHN0cmluZyBvZiB0ZXh0LCB0aGVuIGdyb3VwXG4gICAgICogdGhlbSBpbnRvIGNvbnNlY3V0aXZlIHJ1bnMgb2YgY2hhcmFjdGVycyBzaGFyaW5nIGEgZm9udC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVGb250UnVucyh7dGV4dCwgbGFuZywgZm9udHMsIHN0eWxlLCB3ZWlnaHQsIHByZVJlc29sdmVkRm9udHMsIHVuaWNvZGVGb250c1VSTH0sIG9uRG9uZSkge1xuICAgICAgY29uc3Qgb25SZXNvbHZlZCA9ICh7Y2hhcnMsIGZvbnRzOiBwYXJzZWRGb250c30pID0+IHtcbiAgICAgICAgbGV0IGN1clJ1biwgcHJldlZhbDtcbiAgICAgICAgY29uc3QgcnVucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNoYXJzW2ldICE9PSBwcmV2VmFsKSB7XG4gICAgICAgICAgICBwcmV2VmFsID0gY2hhcnNbaV07XG4gICAgICAgICAgICBydW5zLnB1c2goY3VyUnVuID0geyBzdGFydDogaSwgZW5kOiBpLCBmb250T2JqOiBwYXJzZWRGb250c1tjaGFyc1tpXV19KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyUnVuLmVuZCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uRG9uZShydW5zKTtcbiAgICAgIH07XG4gICAgICBpZiAocHJlUmVzb2x2ZWRGb250cykge1xuICAgICAgICBvblJlc29sdmVkKHByZVJlc29sdmVkRm9udHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZUZvbnRzKFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgb25SZXNvbHZlZCxcbiAgICAgICAgICB7IGxhbmcsIGZvbnRzLCBzdHlsZSwgd2VpZ2h0LCB1bmljb2RlRm9udHNVUkwgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1haW4gZW50cnkgcG9pbnQuXG4gICAgICogUHJvY2VzcyBhIHRleHQgc3RyaW5nIHdpdGggZ2l2ZW4gZm9udCBhbmQgZm9ybWF0dGluZyBwYXJhbWV0ZXJzLCBhbmQgcmV0dXJuIGFsbCBpbmZvXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlbmRlciBhbGwgaXRzIGdseXBocy5cbiAgICAgKiBAdHlwZSBUeXBlc2V0dGVyVHlwZXNldEZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHlwZXNldChcbiAgICAgIHtcbiAgICAgICAgdGV4dD0nJyxcbiAgICAgICAgZm9udCxcbiAgICAgICAgbGFuZyxcbiAgICAgICAgc2RmR2x5cGhTaXplPTY0LFxuICAgICAgICBmb250U2l6ZT00MDAsXG4gICAgICAgIGZvbnRXZWlnaHQ9MSxcbiAgICAgICAgZm9udFN0eWxlPSdub3JtYWwnLFxuICAgICAgICBsZXR0ZXJTcGFjaW5nPTAsXG4gICAgICAgIGxpbmVIZWlnaHQ9J25vcm1hbCcsXG4gICAgICAgIG1heFdpZHRoPUlORixcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICB0ZXh0QWxpZ249J2xlZnQnLFxuICAgICAgICB0ZXh0SW5kZW50PTAsXG4gICAgICAgIHdoaXRlU3BhY2U9J25vcm1hbCcsXG4gICAgICAgIG92ZXJmbG93V3JhcD0nbm9ybWFsJyxcbiAgICAgICAgYW5jaG9yWCA9IDAsXG4gICAgICAgIGFuY2hvclkgPSAwLFxuICAgICAgICBtZXRyaWNzT25seT1mYWxzZSxcbiAgICAgICAgdW5pY29kZUZvbnRzVVJMLFxuICAgICAgICBwcmVSZXNvbHZlZEZvbnRzPW51bGwsXG4gICAgICAgIGluY2x1ZGVDYXJldFBvc2l0aW9ucz1mYWxzZSxcbiAgICAgICAgY2h1bmtlZEJvdW5kc1NpemU9ODE5MixcbiAgICAgICAgY29sb3JSYW5nZXM9bnVsbFxuICAgICAgfSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBjb25zdCBtYWluU3RhcnQgPSBub3coKTtcbiAgICAgIGNvbnN0IHRpbWluZ3MgPSB7Zm9udExvYWQ6IDAsIHR5cGVzZXR0aW5nOiAwfTtcblxuICAgICAgLy8gRW5zdXJlIG5ld2xpbmVzIGFyZSBub3JtYWxpemVkXG4gICAgICBpZiAodGV4dC5pbmRleE9mKCdcXHInKSA+IC0xKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnVHlwZXNldHRlcjogZ290IHRleHQgd2l0aCBcXFxcciBjaGFyczsgbm9ybWFsaXppbmcgdG8gXFxcXG4nKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgd2UndmUgZ290IG51bWJlcnMgbm90IHN0cmluZ3NcbiAgICAgIGZvbnRTaXplID0gK2ZvbnRTaXplO1xuICAgICAgbGV0dGVyU3BhY2luZyA9ICtsZXR0ZXJTcGFjaW5nO1xuICAgICAgbWF4V2lkdGggPSArbWF4V2lkdGg7XG4gICAgICBsaW5lSGVpZ2h0ID0gbGluZUhlaWdodCB8fCAnbm9ybWFsJztcbiAgICAgIHRleHRJbmRlbnQgPSArdGV4dEluZGVudDtcblxuICAgICAgY2FsY3VsYXRlRm9udFJ1bnMoe1xuICAgICAgICB0ZXh0LFxuICAgICAgICBsYW5nLFxuICAgICAgICBzdHlsZTogZm9udFN0eWxlLFxuICAgICAgICB3ZWlnaHQ6IGZvbnRXZWlnaHQsXG4gICAgICAgIGZvbnRzOiB0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycgPyBbe3NyYzogZm9udH1dIDogZm9udCxcbiAgICAgICAgdW5pY29kZUZvbnRzVVJMLFxuICAgICAgICBwcmVSZXNvbHZlZEZvbnRzXG4gICAgICB9LCBydW5zID0+IHtcbiAgICAgICAgdGltaW5ncy5mb250TG9hZCA9IG5vdygpIC0gbWFpblN0YXJ0O1xuICAgICAgICBjb25zdCBoYXNNYXhXaWR0aCA9IGlzRmluaXRlKG1heFdpZHRoKTtcbiAgICAgICAgbGV0IGdseXBoSWRzID0gbnVsbDtcbiAgICAgICAgbGV0IGdseXBoRm9udEluZGljZXMgPSBudWxsO1xuICAgICAgICBsZXQgZ2x5cGhQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgICBsZXQgZ2x5cGhEYXRhID0gbnVsbDtcbiAgICAgICAgbGV0IGdseXBoQ29sb3JzID0gbnVsbDtcbiAgICAgICAgbGV0IGNhcmV0UG9zaXRpb25zID0gbnVsbDtcbiAgICAgICAgbGV0IHZpc2libGVCb3VuZHMgPSBudWxsO1xuICAgICAgICBsZXQgY2h1bmtlZEJvdW5kcyA9IG51bGw7XG4gICAgICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgICBsZXQgcmVuZGVyYWJsZUdseXBoQ291bnQgPSAwO1xuICAgICAgICBsZXQgY2FuV3JhcCA9IHdoaXRlU3BhY2UgIT09ICdub3dyYXAnO1xuICAgICAgICBjb25zdCBtZXRyaWNzQnlGb250ID0gbmV3IE1hcCgpOyAvLyBmb250T2JqIC0+IG1ldHJpY3NcbiAgICAgICAgY29uc3QgdHlwZXNldFN0YXJ0ID0gbm93KCk7XG5cbiAgICAgICAgLy8gRGlzdHJpYnV0ZSBnbHlwaHMgaW50byBsaW5lcyBiYXNlZCBvbiB3cmFwcGluZ1xuICAgICAgICBsZXQgbGluZVhPZmZzZXQgPSB0ZXh0SW5kZW50O1xuICAgICAgICBsZXQgcHJldlJ1bkVuZFggPSAwO1xuICAgICAgICBsZXQgY3VycmVudExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBbY3VycmVudExpbmVdO1xuICAgICAgICBydW5zLmZvckVhY2gocnVuID0+IHtcbiAgICAgICAgICBjb25zdCB7IGZvbnRPYmogfSA9IHJ1bjtcbiAgICAgICAgICBjb25zdCB7IGFzY2VuZGVyLCBkZXNjZW5kZXIsIHVuaXRzUGVyRW0sIGxpbmVHYXAsIGNhcEhlaWdodCwgeEhlaWdodCB9ID0gZm9udE9iajtcblxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBtZXRyaWNzIGZvciBlYWNoIGZvbnQgdXNlZFxuICAgICAgICAgIGxldCBmb250RGF0YSA9IG1ldHJpY3NCeUZvbnQuZ2V0KGZvbnRPYmopO1xuICAgICAgICAgIGlmICghZm9udERhdGEpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgY29udmVyc2lvbiBiZXR3ZWVuIG5hdGl2ZSBmb250IHVuaXRzIGFuZCBmb250U2l6ZSB1bml0c1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemVNdWx0ID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgYXBwcm9wcmlhdGUgdmFsdWUgZm9yICdub3JtYWwnIGxpbmUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBmb250J3MgYWN0dWFsIG1ldHJpY3NcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIGluZGl2aWR1YWwgZ2x5cGhzIHdvbid0IGV4Y2VlZCB0aGUgbGluZSBoZWlnaHQsIGUuZy4gUm9ib3RvOyBzaG91bGQgd2UgdXNlIHlNaW4vTWF4IGluc3RlYWQ/XG4gICAgICAgICAgICBjb25zdCBjYWxjTGluZUhlaWdodCA9IGxpbmVIZWlnaHQgPT09ICdub3JtYWwnID9cbiAgICAgICAgICAgICAgKGFzY2VuZGVyIC0gZGVzY2VuZGVyICsgbGluZUdhcCkgKiBmb250U2l6ZU11bHQgOiBsaW5lSGVpZ2h0ICogZm9udFNpemU7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBsaW5lIGhlaWdodCBhbmQgbGVhZGluZyBhZGp1c3RtZW50c1xuICAgICAgICAgICAgY29uc3QgaGFsZkxlYWRpbmcgPSAoY2FsY0xpbmVIZWlnaHQgLSAoYXNjZW5kZXIgLSBkZXNjZW5kZXIpICogZm9udFNpemVNdWx0KSAvIDI7XG4gICAgICAgICAgICBjb25zdCBjYXJldEhlaWdodCA9IE1hdGgubWluKGNhbGNMaW5lSGVpZ2h0LCAoYXNjZW5kZXIgLSBkZXNjZW5kZXIpICogZm9udFNpemVNdWx0KTtcbiAgICAgICAgICAgIGNvbnN0IGNhcmV0VG9wID0gKGFzY2VuZGVyICsgZGVzY2VuZGVyKSAvIDIgKiBmb250U2l6ZU11bHQgKyBjYXJldEhlaWdodCAvIDI7XG4gICAgICAgICAgICBmb250RGF0YSA9IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG1ldHJpY3NCeUZvbnQuc2l6ZSxcbiAgICAgICAgICAgICAgc3JjOiBmb250T2JqLnNyYyxcbiAgICAgICAgICAgICAgZm9udE9iaixcbiAgICAgICAgICAgICAgZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgICB1bml0c1BlckVtLFxuICAgICAgICAgICAgICBhc2NlbmRlcjogYXNjZW5kZXIgKiBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICAgIGRlc2NlbmRlcjogZGVzY2VuZGVyICogZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgICBjYXBIZWlnaHQ6IGNhcEhlaWdodCAqIGZvbnRTaXplTXVsdCxcbiAgICAgICAgICAgICAgeEhlaWdodDogeEhlaWdodCAqIGZvbnRTaXplTXVsdCxcbiAgICAgICAgICAgICAgbGluZUhlaWdodDogY2FsY0xpbmVIZWlnaHQsXG4gICAgICAgICAgICAgIGJhc2VsaW5lOiAtaGFsZkxlYWRpbmcgLSBhc2NlbmRlciAqIGZvbnRTaXplTXVsdCwgLy8gYmFzZWxpbmUgb2Zmc2V0IGZyb20gdG9wIG9mIGxpbmUgaGVpZ2h0XG4gICAgICAgICAgICAgIC8vIGNhcDogLWhhbGZMZWFkaW5nIC0gY2FwSGVpZ2h0ICogZm9udFNpemVNdWx0LCAvLyBjYXAgZnJvbSB0b3Agb2YgbGluZSBoZWlnaHRcbiAgICAgICAgICAgICAgLy8gZXg6IC1oYWxmTGVhZGluZyAtIHhIZWlnaHQgKiBmb250U2l6ZU11bHQsIC8vIGV4IGZyb20gdG9wIG9mIGxpbmUgaGVpZ2h0XG4gICAgICAgICAgICAgIGNhcmV0VG9wLFxuICAgICAgICAgICAgICBjYXJldEJvdHRvbTogY2FyZXRUb3AgLSBjYXJldEhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1ldHJpY3NCeUZvbnQuc2V0KGZvbnRPYmosIGZvbnREYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyBmb250U2l6ZU11bHQgfSA9IGZvbnREYXRhO1xuXG4gICAgICAgICAgY29uc3QgcnVuVGV4dCA9IHRleHQuc2xpY2UocnVuLnN0YXJ0LCBydW4uZW5kICsgMSk7XG4gICAgICAgICAgbGV0IHByZXZHbHlwaFgsIHByZXZHbHlwaE9iajtcbiAgICAgICAgICBmb250T2JqLmZvckVhY2hHbHlwaChydW5UZXh0LCBmb250U2l6ZSwgbGV0dGVyU3BhY2luZywgKGdseXBoT2JqLCBnbHlwaFgsIGdseXBoWSwgY2hhckluZGV4KSA9PiB7XG4gICAgICAgICAgICBnbHlwaFggKz0gcHJldlJ1bkVuZFg7XG4gICAgICAgICAgICBjaGFySW5kZXggKz0gcnVuLnN0YXJ0O1xuICAgICAgICAgICAgcHJldkdseXBoWCA9IGdseXBoWDtcbiAgICAgICAgICAgIHByZXZHbHlwaE9iaiA9IGdseXBoT2JqO1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IHRleHQuY2hhckF0KGNoYXJJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBnbHlwaFdpZHRoID0gZ2x5cGhPYmouYWR2YW5jZVdpZHRoICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgY29uc3QgY3VyTGluZUNvdW50ID0gY3VycmVudExpbmUuY291bnQ7XG4gICAgICAgICAgICBsZXQgbmV4dExpbmU7XG5cbiAgICAgICAgICAgIC8vIENhbGMgaXNXaGl0ZXNwYWNlIGFuZCBpc0VtcHR5IG9uY2UgcGVyIGdseXBoT2JqXG4gICAgICAgICAgICBpZiAoISgnaXNFbXB0eScgaW4gZ2x5cGhPYmopKSB7XG4gICAgICAgICAgICAgIGdseXBoT2JqLmlzV2hpdGVzcGFjZSA9ICEhY2hhciAmJiBuZXcgUmVnRXhwKGxpbmVCcmVha2luZ1doaXRlU3BhY2UpLnRlc3QoY2hhcik7XG4gICAgICAgICAgICAgIGdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIgPSAhIWNoYXIgJiYgQlJFQUtfQUZURVJfQ0hBUlMudGVzdChjaGFyKTtcbiAgICAgICAgICAgICAgZ2x5cGhPYmouaXNFbXB0eSA9IGdseXBoT2JqLnhNaW4gPT09IGdseXBoT2JqLnhNYXggfHwgZ2x5cGhPYmoueU1pbiA9PT0gZ2x5cGhPYmoueU1heCB8fCBERUZBVUxUX0lHTk9SQUJMRV9DSEFSUy50ZXN0KGNoYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgIWdseXBoT2JqLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZUdseXBoQ291bnQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIgb3ZlcmZsb3dzIHRoZSBtYXggd2lkdGgsIHdlIG5lZWQgdG8gc29mdC13cmFwXG4gICAgICAgICAgICBpZiAoY2FuV3JhcCAmJiBoYXNNYXhXaWR0aCAmJiAhZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmIGdseXBoWCArIGdseXBoV2lkdGggKyBsaW5lWE9mZnNldCA+IG1heFdpZHRoICYmIGN1ckxpbmVDb3VudCkge1xuICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBmaXJzdCBjaGFyIGFmdGVyIGEgd2hpdGVzcGFjZSwgc3RhcnQgYSBuZXcgbGluZVxuICAgICAgICAgICAgICBpZiAoY3VycmVudExpbmUuZ2x5cGhBdChjdXJMaW5lQ291bnQgLSAxKS5nbHlwaE9iai5jYW5CcmVha0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IC1nbHlwaFg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQmFjayB1cCBsb29raW5nIGZvciBhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIHRvIHdyYXAgYXRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY3VyTGluZUNvdW50OyBpLS07KSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHRoZXJlJ3Mgbm8gc29mdCBicmVhayBwb2ludDsgbWFrZSBoYXJkIGJyZWFrIGlmIG92ZXJmbG93V3JhcD0nYnJlYWstd29yZCdcbiAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIG92ZXJmbG93V3JhcCA9PT0gJ2JyZWFrLXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gLWdseXBoWDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgc29mdCBicmVhayBwb2ludDsgbW92ZSBhbGwgY2hhcnMgc2luY2UgaXQgdG8gYSBuZXcgbGluZVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudExpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5jYW5CcmVha0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gY3VycmVudExpbmUuc3BsaXRBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdFggPSBuZXh0TGluZS5nbHlwaEF0KDApLng7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBuZXh0TGluZS5jb3VudDsgai0tOykge1xuICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lLmdseXBoQXQoaikueCAtPSBhZGp1c3RYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZXh0TGluZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lLmlzU29mdFdyYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV4dExpbmU7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbWF4V2lkdGg7IC8vYWZ0ZXIgc29mdCB3cmFwcGluZyB1c2UgbWF4V2lkdGggYXMgY2FsY3VsYXRlZCB3aWR0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBmbHkgPSBjdXJyZW50TGluZS5nbHlwaEF0KGN1cnJlbnRMaW5lLmNvdW50KTtcbiAgICAgICAgICAgIGZseS5nbHlwaE9iaiA9IGdseXBoT2JqO1xuICAgICAgICAgICAgZmx5LnggPSBnbHlwaFggKyBsaW5lWE9mZnNldDtcbiAgICAgICAgICAgIGZseS55ID0gZ2x5cGhZO1xuICAgICAgICAgICAgZmx5LndpZHRoID0gZ2x5cGhXaWR0aDtcbiAgICAgICAgICAgIGZseS5jaGFySW5kZXggPSBjaGFySW5kZXg7XG4gICAgICAgICAgICBmbHkuZm9udERhdGEgPSBmb250RGF0YTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIGhhcmQgbGluZSBicmVha3NcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICAgICAgICBjdXJyZW50TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtKGdseXBoWCArIGdseXBoV2lkdGggKyAobGV0dGVyU3BhY2luZyAqIGZvbnRTaXplKSkgKyB0ZXh0SW5kZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIEF0IHRoZSBlbmQgb2YgYSBydW4gd2UgbXVzdCBjYXB0dXJlIHRoZSB4IHBvc2l0aW9uIGFzIHRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIG5leHQgcnVuXG4gICAgICAgICAgcHJldlJ1bkVuZFggPSBwcmV2R2x5cGhYICsgcHJldkdseXBoT2JqLmFkdmFuY2VXaWR0aCAqIGZvbnRTaXplTXVsdCArIGxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHdpZHRoL2hlaWdodC9iYXNlbGluZSBvZiBlYWNoIGxpbmUgKGV4Y2x1ZGluZyB0cmFpbGluZyB3aGl0ZXNwYWNlKSBhbmQgbWF4aW11bSBibG9jayB3aWR0aFxuICAgICAgICBsZXQgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgIGxldCBpc1RyYWlsaW5nV2hpdGVzcGFjZSA9IHRydWU7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmUuY291bnQ7IGktLTspIHtcbiAgICAgICAgICAgIGNvbnN0IGdseXBoSW5mbyA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICAgIC8vIG9taXQgdHJhaWxpbmcgd2hpdGVzcGFjZSBmcm9tIHdpZHRoIGNhbGN1bGF0aW9uXG4gICAgICAgICAgICBpZiAoaXNUcmFpbGluZ1doaXRlc3BhY2UgJiYgIWdseXBoSW5mby5nbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgbGluZS53aWR0aCA9IGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoO1xuICAgICAgICAgICAgICBpZiAobGluZS53aWR0aCA+IG1heExpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXNUcmFpbGluZ1doaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZSB0aGUgdGFsbGVzdCBsaW5lIGhlaWdodCwgbG93ZXN0IGJhc2VsaW5lLCBhbmQgaGlnaGVzdCBjYXAvZXhcbiAgICAgICAgICAgIGxldCB7bGluZUhlaWdodCwgY2FwSGVpZ2h0LCB4SGVpZ2h0LCBiYXNlbGluZX0gPSBnbHlwaEluZm8uZm9udERhdGE7XG4gICAgICAgICAgICBpZiAobGluZUhlaWdodCA+IGxpbmUubGluZUhlaWdodCkgbGluZS5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VsaW5lRGlmZiA9IGJhc2VsaW5lIC0gbGluZS5iYXNlbGluZTtcbiAgICAgICAgICAgIGlmIChiYXNlbGluZURpZmYgPCAwKSB7IC8vc2hpZnQgYWxsIG1ldHJpY3MgZG93blxuICAgICAgICAgICAgICBsaW5lLmJhc2VsaW5lICs9IGJhc2VsaW5lRGlmZjtcbiAgICAgICAgICAgICAgbGluZS5jYXAgKz0gYmFzZWxpbmVEaWZmO1xuICAgICAgICAgICAgICBsaW5lLmV4ICs9IGJhc2VsaW5lRGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbXBhcmUgY2FwL2V4IGJhc2VkIG9uIG5ldyBsb3dlc3QgYmFzZWxpbmVcbiAgICAgICAgICAgIGxpbmUuY2FwID0gTWF0aC5tYXgobGluZS5jYXAsIGxpbmUuYmFzZWxpbmUgKyBjYXBIZWlnaHQpO1xuICAgICAgICAgICAgbGluZS5leCA9IE1hdGgubWF4KGxpbmUuZXgsIGxpbmUuYmFzZWxpbmUgKyB4SGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZS5iYXNlbGluZSAtPSB0b3RhbEhlaWdodDtcbiAgICAgICAgICBsaW5lLmNhcCAtPSB0b3RhbEhlaWdodDtcbiAgICAgICAgICBsaW5lLmV4IC09IHRvdGFsSGVpZ2h0O1xuICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmUubGluZUhlaWdodDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmluZCBvdmVyYWxsIHBvc2l0aW9uIGFkanVzdG1lbnRzIGZvciBhbmNob3JpbmdcbiAgICAgICAgbGV0IGFuY2hvclhPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgYW5jaG9yWU9mZnNldCA9IDA7XG4gICAgICAgIGlmIChhbmNob3JYKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JYID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYW5jaG9yWE9mZnNldCA9IC1hbmNob3JYO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYW5jaG9yWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFuY2hvclhPZmZzZXQgPSAtbWF4TGluZVdpZHRoICogKFxuICAgICAgICAgICAgICBhbmNob3JYID09PSAnbGVmdCcgPyAwIDpcbiAgICAgICAgICAgICAgYW5jaG9yWCA9PT0gJ2NlbnRlcicgPyAwLjUgOlxuICAgICAgICAgICAgICBhbmNob3JYID09PSAncmlnaHQnID8gMSA6XG4gICAgICAgICAgICAgIHBhcnNlUGVyY2VudChhbmNob3JYKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2hvclkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFuY2hvclkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBhbmNob3JZT2Zmc2V0ID0gLWFuY2hvclk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhbmNob3JZID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYW5jaG9yWU9mZnNldCA9IGFuY2hvclkgPT09ICd0b3AnID8gMCA6XG4gICAgICAgICAgICAgIGFuY2hvclkgPT09ICd0b3AtYmFzZWxpbmUnID8gLWxpbmVzWzBdLmJhc2VsaW5lIDpcbiAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1jYXAnID8gLWxpbmVzWzBdLmNhcCA6XG4gICAgICAgICAgICAgIGFuY2hvclkgPT09ICd0b3AtZXgnID8gLWxpbmVzWzBdLmV4IDpcbiAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ21pZGRsZScgPyB0b3RhbEhlaWdodCAvIDIgOlxuICAgICAgICAgICAgICBhbmNob3JZID09PSAnYm90dG9tJyA/IHRvdGFsSGVpZ2h0IDpcbiAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ2JvdHRvbS1iYXNlbGluZScgPyAtbGluZXNbbGluZXMubGVuZ3RoIC0gMV0uYmFzZWxpbmUgOlxuICAgICAgICAgICAgICBwYXJzZVBlcmNlbnQoYW5jaG9yWSkgKiB0b3RhbEhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1ldHJpY3NPbmx5KSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBiaWRpIGxldmVsc1xuICAgICAgICAgIGNvbnN0IGJpZGlMZXZlbHNSZXN1bHQgPSBiaWRpLmdldEVtYmVkZGluZ0xldmVscyh0ZXh0LCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGxpbmUsIGFwcGx5aW5nIGFsaWdubWVudCBvZmZzZXRzLCBhZGRpbmcgZWFjaCBnbHlwaCB0byB0aGUgYXRsYXMsIGFuZFxuICAgICAgICAgIC8vIGNvbGxlY3RpbmcgYWxsIHJlbmRlcmFibGUgZ2x5cGhzIGludG8gYSBzaW5nbGUgY29sbGVjdGlvbi5cbiAgICAgICAgICBnbHlwaElkcyA9IG5ldyBVaW50MTZBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCk7XG4gICAgICAgICAgZ2x5cGhGb250SW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50KTtcbiAgICAgICAgICBnbHlwaFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQgKiAyKTtcbiAgICAgICAgICBnbHlwaERhdGEgPSB7fTtcbiAgICAgICAgICB2aXNpYmxlQm91bmRzID0gW0lORiwgSU5GLCAtSU5GLCAtSU5GXTtcbiAgICAgICAgICBjaHVua2VkQm91bmRzID0gW107XG4gICAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRleHQubGVuZ3RoICogNCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgZ2x5cGhDb2xvcnMgPSBuZXcgVWludDhBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCAqIDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmVuZGVyYWJsZUdseXBoSW5kZXggPSAwO1xuICAgICAgICAgIGxldCBwcmV2Q2hhckluZGV4ID0gLTE7XG4gICAgICAgICAgbGV0IGNvbG9yQ2hhckluZGV4ID0gLTE7XG4gICAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICAgIGxldCBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSwgbGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQge2NvdW50OmxpbmVHbHlwaENvdW50LCB3aWR0aDpsaW5lV2lkdGh9ID0gbGluZTtcblxuICAgICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGxpbmVzXG4gICAgICAgICAgICBpZiAobGluZUdseXBoQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIENvdW50IHRyYWlsaW5nIHdoaXRlc3BhY2VzLCB3ZSB3YW50IHRvIGlnbm9yZSB0aGVzZSBmb3IgY2VydGFpbiB0aGluZ3NcbiAgICAgICAgICAgICAgbGV0IHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVHbHlwaENvdW50OyBpLS0gJiYgbGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmlzV2hpdGVzcGFjZTspIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQXBwbHkgaG9yaXpvbnRhbCBhbGlnbm1lbnQgYWRqdXN0bWVudHNcbiAgICAgICAgICAgICAgbGV0IGxpbmVYT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgbGV0IGp1c3RpZnlBZGp1c3QgPSAwO1xuICAgICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aCkgLyAyO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnknICYmIGxpbmUuaXNTb2Z0V3JhcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvdW50IG5vbi10cmFpbGluZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsIGFuZCB3ZSdsbCBhZGp1c3QgdGhlIG9mZnNldHMgcGVyIGNoYXJhY3RlciBpbiB0aGUgbmV4dCBsb29wXG4gICAgICAgICAgICAgICAgbGV0IHdoaXRlc3BhY2VDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQ7IGktLTspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqdXN0aWZ5QWRqdXN0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aCkgLyB3aGl0ZXNwYWNlQ291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGp1c3RpZnlBZGp1c3QgfHwgbGluZVhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQganVzdGlmeU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhPYmogPSBnbHlwaEluZm8uZ2x5cGhPYmo7XG4gICAgICAgICAgICAgICAgICBnbHlwaEluZm8ueCArPSBsaW5lWE9mZnNldCArIGp1c3RpZnlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgbm9uLXRyYWlsaW5nIHdoaXRlc3BhY2VzIGZvciBqdXN0aWZ5IGFsaWdubWVudFxuICAgICAgICAgICAgICAgICAgaWYgKGp1c3RpZnlBZGp1c3QgIT09IDAgJiYgZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmIGkgPCBsaW5lR2x5cGhDb3VudCAtIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnlPZmZzZXQgKz0ganVzdGlmeUFkanVzdDtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmZvLndpZHRoICs9IGp1c3RpZnlBZGp1c3Q7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gUGVyZm9ybSBiaWRpIHJhbmdlIGZsaXBwaW5nXG4gICAgICAgICAgICAgIGNvbnN0IGZsaXBzID0gYmlkaS5nZXRSZW9yZGVyU2VnbWVudHMoXG4gICAgICAgICAgICAgICAgdGV4dCwgYmlkaUxldmVsc1Jlc3VsdCwgbGluZS5nbHlwaEF0KDApLmNoYXJJbmRleCwgbGluZS5nbHlwaEF0KGxpbmUuY291bnQgLSAxKS5jaGFySW5kZXhcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgZmkgPSAwOyBmaSA8IGZsaXBzLmxlbmd0aDsgZmkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IGZsaXBzW2ZpXTtcbiAgICAgICAgICAgICAgICAvLyBNYXAgc3RhcnQvZW5kIHN0cmluZyBpbmRpY2VzIHRvIGluZGljZXMgaW4gdGhlIGxpbmVcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmdseXBoQXQoaSkuY2hhckluZGV4ID49IHN0YXJ0KSB7IC8vIGd0ZSB0byBoYW5kbGUgcmVtb3ZlZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydEluTGluZSA9IGksIGVuZEluTGluZSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBlbmRJbkxpbmUgPCBsaW5lR2x5cGhDb3VudDsgZW5kSW5MaW5lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IGxpbmUuZ2x5cGhBdChlbmRJbkxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmNoYXJJbmRleCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluTGluZSA8IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQpIHsgLy9kb24ndCBpbmNsdWRlIHRyYWlsaW5nIHdzIGluIGZsaXAgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCBpbmZvLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgaW5mby54ICsgaW5mby53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydEluTGluZTsgaiA8IGVuZEluTGluZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGopO1xuICAgICAgICAgICAgICAgICAgICAgIGdseXBoSW5mby54ID0gcmlnaHQgLSAoZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGggLSBsZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEFzc2VtYmxlIGZpbmFsIGRhdGEgYXJyYXlzXG4gICAgICAgICAgICAgIGxldCBnbHlwaE9iajtcbiAgICAgICAgICAgICAgY29uc3Qgc2V0R2x5cGhPYmogPSBnID0+IGdseXBoT2JqID0gZztcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgICAgIGdseXBoT2JqID0gZ2x5cGhJbmZvLmdseXBoT2JqO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoSWQgPSBnbHlwaE9iai5pbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgbWlycm9yZWQgY2hhcmFjdGVycyBpbiBydGxcbiAgICAgICAgICAgICAgICBjb25zdCBydGwgPSBiaWRpTGV2ZWxzUmVzdWx0LmxldmVsc1tnbHlwaEluZm8uY2hhckluZGV4XSAmIDE7IC8vb2RkIGxldmVsIG1lYW5zIHJ0bFxuICAgICAgICAgICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1pcnJvcmVkID0gYmlkaS5nZXRNaXJyb3JlZENoYXJhY3Rlcih0ZXh0W2dseXBoSW5mby5jaGFySW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtaXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEluZm8uZm9udERhdGEuZm9udE9iai5mb3JFYWNoR2x5cGgobWlycm9yZWQsIDAsIDAsIHNldEdseXBoT2JqKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgY2FyZXQgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgICAgICAgICAgY29uc3Qge2NoYXJJbmRleCwgZm9udERhdGF9ID0gZ2x5cGhJbmZvO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2FyZXRMZWZ0ID0gZ2x5cGhJbmZvLnggKyBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2FyZXRSaWdodCA9IGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2NoYXJJbmRleCAqIDRdID0gcnRsID8gY2FyZXRSaWdodCA6IGNhcmV0TGVmdDsgLy9zdGFydCBlZGdlIHhcbiAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2NoYXJJbmRleCAqIDQgKyAxXSA9IHJ0bCA/IGNhcmV0TGVmdCA6IGNhcmV0UmlnaHQ7IC8vZW5kIGVkZ2UgeFxuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNCArIDJdID0gbGluZS5iYXNlbGluZSArIGZvbnREYXRhLmNhcmV0Qm90dG9tICsgYW5jaG9yWU9mZnNldDsgLy9jb21tb24gYm90dG9tIHlcbiAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2NoYXJJbmRleCAqIDQgKyAzXSA9IGxpbmUuYmFzZWxpbmUgKyBmb250RGF0YS5jYXJldFRvcCArIGFuY2hvcllPZmZzZXQ7IC8vY29tbW9uIHRvcCB5XG5cbiAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHNraXBwZWQgYW55IGNoYXJzIGZyb20gdGhlIHByZXZpb3VzIGdseXBoIChkdWUgdG8gbGlnYXR1cmUgc3VicyksIGZpbGwgaW4gY2FyZXRcbiAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9ucyBmb3IgdGhvc2UgbWlzc2luZyBjaGFyIGluZGljZXM7IGN1cnJlbnRseSB0aGlzIHVzZXMgYSBiZXN0LWd1ZXNzIGJ5IGRpdmlkaW5nXG4gICAgICAgICAgICAgICAgICAvLyB0aGUgbGlnYXR1cmUncyB3aWR0aCBldmVubHkuIEluIHRoZSBmdXR1cmUgd2UgbWF5IHRyeSB0byB1c2UgdGhlIGZvbnQncyBMaWdhdHVyZUNhcmV0TGlzdFxuICAgICAgICAgICAgICAgICAgLy8gdGFibGUgdG8gZ2V0IGJldHRlciBpbnRlcmlvciBjYXJldCBwb3NpdGlvbnMuXG4gICAgICAgICAgICAgICAgICBjb25zdCBsaWdDb3VudCA9IGNoYXJJbmRleCAtIHByZXZDaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgICBpZiAobGlnQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBwcmV2Q2hhckluZGV4LCBsaWdDb3VudCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBwcmV2Q2hhckluZGV4ID0gY2hhckluZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIGN1cnJlbnQgY29sb3IgcmFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHtjaGFySW5kZXh9ID0gZ2x5cGhJbmZvO1xuICAgICAgICAgICAgICAgICAgd2hpbGUoY2hhckluZGV4ID4gY29sb3JDaGFySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JDaGFySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzLmhhc093blByb3BlcnR5KGNvbG9yQ2hhckluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IGNvbG9yUmFuZ2VzW2NvbG9yQ2hhckluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCBhdGxhcyBkYXRhIGZvciByZW5kZXJhYmxlIGdseXBoc1xuICAgICAgICAgICAgICAgIGlmICghZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmICFnbHlwaE9iai5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSByZW5kZXJhYmxlR2x5cGhJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgY29uc3Qge2ZvbnRTaXplTXVsdCwgc3JjOiBmb250U3JjLCBpbmRleDogZm9udEluZGV4fSA9IGdseXBoSW5mby5mb250RGF0YTtcblxuICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgZ2x5cGgncyBwYXRoIGRhdGFcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRHbHlwaERhdGEgPSBnbHlwaERhdGFbZm9udFNyY10gfHwgKGdseXBoRGF0YVtmb250U3JjXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgIGlmICghZm9udEdseXBoRGF0YVtnbHlwaElkXSkge1xuICAgICAgICAgICAgICAgICAgICBmb250R2x5cGhEYXRhW2dseXBoSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGdseXBoT2JqLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgcGF0aEJvdW5kczogW2dseXBoT2JqLnhNaW4sIGdseXBoT2JqLnlNaW4sIGdseXBoT2JqLnhNYXgsIGdseXBoT2JqLnlNYXhdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBmaW5hbCBnbHlwaCBwb3NpdGlvbiBhbmQgYWRkIHRvIGdseXBoUG9zaXRpb25zIGFycmF5XG4gICAgICAgICAgICAgICAgICBjb25zdCBnbHlwaFggPSBnbHlwaEluZm8ueCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCBnbHlwaFkgPSBnbHlwaEluZm8ueSArIGxpbmUuYmFzZWxpbmUgKyBhbmNob3JZT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgZ2x5cGhQb3NpdGlvbnNbaWR4ICogMl0gPSBnbHlwaFg7XG4gICAgICAgICAgICAgICAgICBnbHlwaFBvc2l0aW9uc1tpZHggKiAyICsgMV0gPSBnbHlwaFk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHRvdGFsIHZpc2libGUgYm91bmRzXG4gICAgICAgICAgICAgICAgICBjb25zdCB2aXNYMCA9IGdseXBoWCArIGdseXBoT2JqLnhNaW4gKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2aXNZMCA9IGdseXBoWSArIGdseXBoT2JqLnlNaW4gKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2aXNYMSA9IGdseXBoWCArIGdseXBoT2JqLnhNYXggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2aXNZMSA9IGdseXBoWSArIGdseXBoT2JqLnlNYXggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgICBpZiAodmlzWDAgPCB2aXNpYmxlQm91bmRzWzBdKSB2aXNpYmxlQm91bmRzWzBdID0gdmlzWDA7XG4gICAgICAgICAgICAgICAgICBpZiAodmlzWTAgPCB2aXNpYmxlQm91bmRzWzFdKSB2aXNpYmxlQm91bmRzWzFdID0gdmlzWTA7XG4gICAgICAgICAgICAgICAgICBpZiAodmlzWDEgPiB2aXNpYmxlQm91bmRzWzJdKSB2aXNpYmxlQm91bmRzWzJdID0gdmlzWDE7XG4gICAgICAgICAgICAgICAgICBpZiAodmlzWTEgPiB2aXNpYmxlQm91bmRzWzNdKSB2aXNpYmxlQm91bmRzWzNdID0gdmlzWTE7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIGJvdW5kaW5nIHJlY3RzIGZvciBlYWNoIGNodW5rIG9mIE4gZ2x5cGhzXG4gICAgICAgICAgICAgICAgICBpZiAoaWR4ICUgY2h1bmtlZEJvdW5kc1NpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSB7c3RhcnQ6IGlkeCwgZW5kOiBpZHgsIHJlY3Q6IFtJTkYsIElORiwgLUlORiwgLUlORl19O1xuICAgICAgICAgICAgICAgICAgICBjaHVua2VkQm91bmRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2h1bmsuZW5kKys7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1JlY3QgPSBjaHVuay5yZWN0O1xuICAgICAgICAgICAgICAgICAgaWYgKHZpc1gwIDwgY2h1bmtSZWN0WzBdKSBjaHVua1JlY3RbMF0gPSB2aXNYMDtcbiAgICAgICAgICAgICAgICAgIGlmICh2aXNZMCA8IGNodW5rUmVjdFsxXSkgY2h1bmtSZWN0WzFdID0gdmlzWTA7XG4gICAgICAgICAgICAgICAgICBpZiAodmlzWDEgPiBjaHVua1JlY3RbMl0pIGNodW5rUmVjdFsyXSA9IHZpc1gxO1xuICAgICAgICAgICAgICAgICAgaWYgKHZpc1kxID4gY2h1bmtSZWN0WzNdKSBjaHVua1JlY3RbM10gPSB2aXNZMTtcblxuICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIGdseXBoIGlkcyBhbmQgZm9udCBpbmRpY2VzIGFycmF5c1xuICAgICAgICAgICAgICAgICAgZ2x5cGhJZHNbaWR4XSA9IGdseXBoSWQ7XG4gICAgICAgICAgICAgICAgICBnbHlwaEZvbnRJbmRpY2VzW2lkeF0gPSBmb250SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEFkZCBjb2xvcnNcbiAgICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGlkeCAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0XSA9IGN1cnJlbnRDb2xvciA+PiAxNiAmIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnQgKyAxXSA9IGN1cnJlbnRDb2xvciA+PiA4ICYgMjU1O1xuICAgICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydCArIDJdID0gY3VycmVudENvbG9yICYgMjU1O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRmlsbCBpbiByZW1haW5pbmcgY2FyZXQgcG9zaXRpb25zIGluIGNhc2UgdGhlIGZpbmFsIGNoYXJhY3RlciB3YXMgYSBsaWdhdHVyZVxuICAgICAgICAgIGlmIChjYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbGlnQ291bnQgPSB0ZXh0Lmxlbmd0aCAtIHByZXZDaGFySW5kZXg7XG4gICAgICAgICAgICBpZiAobGlnQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBwcmV2Q2hhckluZGV4LCBsaWdDb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXNzZW1ibGUgZmluYWwgZGF0YSBhYm91dCBlYWNoIGZvbnQgdXNlZFxuICAgICAgICBjb25zdCBmb250RGF0YSA9IFtdO1xuICAgICAgICBtZXRyaWNzQnlGb250LmZvckVhY2goKHtpbmRleCwgc3JjLCB1bml0c1BlckVtLCBhc2NlbmRlciwgZGVzY2VuZGVyLCBsaW5lSGVpZ2h0LCBjYXBIZWlnaHQsIHhIZWlnaHR9KSA9PiB7XG4gICAgICAgICAgZm9udERhdGFbaW5kZXhdID0ge3NyYywgdW5pdHNQZXJFbSwgYXNjZW5kZXIsIGRlc2NlbmRlciwgbGluZUhlaWdodCwgY2FwSGVpZ2h0LCB4SGVpZ2h0fTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGltaW5nIHN0YXRzXG4gICAgICAgIHRpbWluZ3MudHlwZXNldHRpbmcgPSBub3coKSAtIHR5cGVzZXRTdGFydDtcblxuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgZ2x5cGhJZHMsIC8vaWQgZm9yIGVhY2ggZ2x5cGgsIHNwZWNpZmljIHRvIHRoYXQgZ2x5cGgncyBmb250XG4gICAgICAgICAgZ2x5cGhGb250SW5kaWNlcywgLy9pbmRleCBpbnRvIGZvbnREYXRhIGZvciBlYWNoIGdseXBoXG4gICAgICAgICAgZ2x5cGhQb3NpdGlvbnMsIC8veCx5IG9mIGVhY2ggZ2x5cGgncyBvcmlnaW4gaW4gbGF5b3V0XG4gICAgICAgICAgZ2x5cGhEYXRhLCAvL2RpY3QgaG9sZGluZyBkYXRhIGFib3V0IGVhY2ggZ2x5cGggYXBwZWFyaW5nIGluIHRoZSB0ZXh0XG4gICAgICAgICAgZm9udERhdGEsIC8vZGF0YSBhYm91dCBlYWNoIGZvbnQgdXNlZCBpbiB0aGUgdGV4dFxuICAgICAgICAgIGNhcmV0UG9zaXRpb25zLCAvL3N0YXJ0WCxlbmRYLGJvdHRvbVkgY2FyZXQgcG9zaXRpb25zIGZvciBlYWNoIGNoYXJcbiAgICAgICAgICAvLyBjYXJldEhlaWdodCwgLy9oZWlnaHQgb2YgY3Vyc29yIGZyb20gYm90dG9tIHRvIHRvcCAtIHRvZG8gcGVyIGdseXBoP1xuICAgICAgICAgIGdseXBoQ29sb3JzLCAvL2NvbG9yIGZvciBlYWNoIGdseXBoLCBpZiBjb2xvciByYW5nZXMgc3VwcGxpZWRcbiAgICAgICAgICBjaHVua2VkQm91bmRzLCAvL3RvdGFsIHJlY3RzIHBlciAobj1jaHVua2VkQm91bmRzU2l6ZSkgY29uc2VjdXRpdmUgZ2x5cGhzXG4gICAgICAgICAgZm9udFNpemUsIC8vY2FsY3VsYXRlZCBlbSBoZWlnaHRcbiAgICAgICAgICB0b3BCYXNlbGluZTogYW5jaG9yWU9mZnNldCArIGxpbmVzWzBdLmJhc2VsaW5lLCAvL3kgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxpbmUncyBiYXNlbGluZVxuICAgICAgICAgIGJsb2NrQm91bmRzOiBbIC8vYm91bmRzIGZvciB0aGUgd2hvbGUgYmxvY2sgb2YgdGV4dCwgaW5jbHVkaW5nIHZlcnRpY2FsIHBhZGRpbmcgZm9yIGxpbmVIZWlnaHRcbiAgICAgICAgICAgIGFuY2hvclhPZmZzZXQsXG4gICAgICAgICAgICBhbmNob3JZT2Zmc2V0IC0gdG90YWxIZWlnaHQsXG4gICAgICAgICAgICBhbmNob3JYT2Zmc2V0ICsgbWF4TGluZVdpZHRoLFxuICAgICAgICAgICAgYW5jaG9yWU9mZnNldFxuICAgICAgICAgIF0sXG4gICAgICAgICAgdmlzaWJsZUJvdW5kcywgLy90b3RhbCBib3VuZHMgb2YgdmlzaWJsZSB0ZXh0IHBhdGhzLCBtYXkgYmUgbGFyZ2VyIG9yIHNtYWxsZXIgdGhhbiBibG9ja0JvdW5kc1xuICAgICAgICAgIHRpbWluZ3NcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEZvciBhIGdpdmVuIHRleHQgc3RyaW5nIGFuZCBmb250IHBhcmFtZXRlcnMsIGRldGVybWluZSB0aGUgcmVzdWx0aW5nIGJsb2NrIGRpbWVuc2lvbnNcbiAgICAgKiBhZnRlciB3cmFwcGluZyBmb3IgdGhlIGdpdmVuIG1heFdpZHRoLlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhc3VyZShhcmdzLCBjYWxsYmFjaykge1xuICAgICAgdHlwZXNldCh7Li4uYXJncywgbWV0cmljc09ubHk6IHRydWV9LCAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSByZXN1bHQuYmxvY2tCb3VuZHM7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICB3aWR0aDogeDEgLSB4MCxcbiAgICAgICAgICBoZWlnaHQ6IHkxIC0geTBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBlcmNlbnQoc3RyKSB7XG4gICAgICBsZXQgbWF0Y2ggPSBzdHIubWF0Y2goL14oW1xcZC5dKyklJC8pO1xuICAgICAgbGV0IHBjdCA9IG1hdGNoID8gcGFyc2VGbG9hdChtYXRjaFsxXSkgOiBOYU47XG4gICAgICByZXR1cm4gaXNOYU4ocGN0KSA/IDAgOiBwY3QgLyAxMDBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWxsTGlnYXR1cmVDYXJldFBvc2l0aW9ucyhjYXJldFBvc2l0aW9ucywgbGlnU3RhcnRJbmRleCwgbGlnQ291bnQpIHtcbiAgICAgIGNvbnN0IGxpZ1N0YXJ0WCA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiA0XTtcbiAgICAgIGNvbnN0IGxpZ0VuZFggPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogNCArIDFdO1xuICAgICAgY29uc3QgbGlnQm90dG9tID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDQgKyAyXTtcbiAgICAgIGNvbnN0IGxpZ1RvcCA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiA0ICsgM107XG4gICAgICBjb25zdCBndWVzc2VkQWR2YW5jZVggPSAobGlnRW5kWCAtIGxpZ1N0YXJ0WCkgLyBsaWdDb3VudDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlnQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gKGxpZ1N0YXJ0SW5kZXggKyBpKSAqIDQ7XG4gICAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXhdID0gbGlnU3RhcnRYICsgZ3Vlc3NlZEFkdmFuY2VYICogaTtcbiAgICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleCArIDFdID0gbGlnU3RhcnRYICsgZ3Vlc3NlZEFkdmFuY2VYICogKGkgKyAxKTtcbiAgICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleCArIDJdID0gbGlnQm90dG9tO1xuICAgICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4ICsgM10gPSBsaWdUb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm93KCkge1xuICAgICAgcmV0dXJuIChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpXG4gICAgfVxuXG4gICAgLy8gQXJyYXktYmFja2VkIHN0cnVjdHVyZSBmb3IgYSBzaW5nbGUgbGluZSdzIGdseXBocyBkYXRhXG4gICAgZnVuY3Rpb24gVGV4dExpbmUoKSB7XG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG4gICAgY29uc3QgdGV4dExpbmVQcm9wcyA9IFsnZ2x5cGhPYmonLCAneCcsICd5JywgJ3dpZHRoJywgJ2NoYXJJbmRleCcsICdmb250RGF0YSddO1xuICAgIFRleHRMaW5lLnByb3RvdHlwZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgbGluZUhlaWdodDogMCxcbiAgICAgIGJhc2VsaW5lOiAwLFxuICAgICAgY2FwOiAwLFxuICAgICAgZXg6IDAsXG4gICAgICBpc1NvZnRXcmFwcGVkOiBmYWxzZSxcbiAgICAgIGdldCBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRhdGEubGVuZ3RoIC8gdGV4dExpbmVQcm9wcy5sZW5ndGgpXG4gICAgICB9LFxuICAgICAgZ2x5cGhBdChpKSB7XG4gICAgICAgIGxldCBmbHkgPSBUZXh0TGluZS5mbHl3ZWlnaHQ7XG4gICAgICAgIGZseS5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmbHkuaW5kZXggPSBpO1xuICAgICAgICByZXR1cm4gZmx5XG4gICAgICB9LFxuICAgICAgc3BsaXRBdChpKSB7XG4gICAgICAgIGxldCBuZXdMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgIG5ld0xpbmUuZGF0YSA9IHRoaXMuZGF0YS5zcGxpY2UoaSAqIHRleHRMaW5lUHJvcHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVcbiAgICAgIH1cbiAgICB9O1xuICAgIFRleHRMaW5lLmZseXdlaWdodCA9IHRleHRMaW5lUHJvcHMucmVkdWNlKChvYmosIHByb3AsIGksIGFsbCkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmluZGV4ICogdGV4dExpbmVQcm9wcy5sZW5ndGggKyBpXVxuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgdGhpcy5kYXRhW3RoaXMuaW5kZXggKiB0ZXh0TGluZVByb3BzLmxlbmd0aCArIGldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmpcbiAgICB9LCB7ZGF0YTogbnVsbCwgaW5kZXg6IDB9KTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGVzZXQsXG4gICAgICBtZWFzdXJlLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5vdyA9ICgpID0+IChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpO1xuXG4gIGNvbnN0IG1haW5UaHJlYWRHZW5lcmF0b3IgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNERkdlbmVyYXRvcl9fZGVmYXVsdFsnZGVmYXVsdCddKCk7XG5cbiAgbGV0IHdhcm5lZDtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgc2luZ2xlIGdseXBoIHBhdGgsIHBsYWNpbmcgdGhlIHJlc3VsdCBpbnRvIGEgd2ViZ2wgY2FudmFzIGF0IGFcbiAgICogZ2l2ZW4gbG9jYXRpb24gYW5kIGNoYW5uZWwuIFV0aWxpemVzIHRoZSB3ZWJnbC1zZGYtZ2VuZXJhdG9yIGV4dGVybmFsIHBhY2thZ2UgZm9yIEdQVS1hY2NlbGVyYXRlZCBTREZcbiAgICogZ2VuZXJhdGlvbiB3aGVuIHN1cHBvcnRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlU0RGKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsLCB1c2VXZWJHTCA9IHRydWUpIHtcbiAgICAvLyBBbGxvdyBvcHQtb3V0XG4gICAgaWYgKCF1c2VXZWJHTCkge1xuICAgICAgcmV0dXJuIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbClcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IEdQVS1hY2NlbGVyYXRlZCBnZW5lcmF0aW9uIGZpcnN0XG4gICAgcmV0dXJuIGdlbmVyYXRlU0RGX0dMKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKS50aGVuKFxuICAgICAgbnVsbCxcbiAgICAgIGVyciA9PiB7XG4gICAgICAgIC8vIFdlYkdMIGZhaWxlZCBlaXRoZXIgZHVlIHRvIGEgaGFyZCBlcnJvciBvciB1bmV4cGVjdGVkIHJlc3VsdHM7IGZhbGwgYmFjayB0byBKUyBpbiB3b3JrZXJzXG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKU2AsIGVycik7XG4gICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHF1ZXVlID0gW107XG4gIGNvbnN0IGNodW5rVGltZUJ1ZGdldCA9IDU7IC8vIG1zXG4gIGxldCB0aW1lciA9IDA7XG5cbiAgZnVuY3Rpb24gbmV4dENodW5rKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAmJiBub3coKSAtIHN0YXJ0IDwgY2h1bmtUaW1lQnVkZ2V0KSB7XG4gICAgICBxdWV1ZS5zaGlmdCgpKCk7XG4gICAgfVxuICAgIHRpbWVyID0gcXVldWUubGVuZ3RoID8gc2V0VGltZW91dChuZXh0Q2h1bmssIDApIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZWJHTC1iYXNlZCBpbXBsZW1lbnRhdGlvbiBleGVjdXRlZCBvbiB0aGUgbWFpbiB0aHJlYWQuIFJlcXVlc3RzIGFyZSBleGVjdXRlZCBpbiB0aW1lLWJvdW5kZWRcbiAgICogbWFjcm90YXNrIGNodW5rcyB0byBhbGxvdyByZW5kZXIgZnJhbWVzIHRvIGV4ZWN1dGUgaW4gYmV0d2Vlbi5cbiAgICovXG4gIGNvbnN0IGdlbmVyYXRlU0RGX0dMID0gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbC5nZW5lcmF0ZUludG9DYW52YXMoLi4uYXJncyk7XG4gICAgICAgICAgcmVzb2x2ZSh7IHRpbWluZzogbm93KCkgLSBzdGFydCB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQobmV4dENodW5rLCAwKTtcbiAgICAgIH1cbiAgICB9KVxuICB9O1xuXG4gIGNvbnN0IHRocmVhZENvdW50ID0gNDsgLy8gaG93IG1hbnkgd29ya2VycyB0byBzcGF3blxuICBjb25zdCBpZGxlVGltZW91dCA9IDIwMDA7IC8vIHdvcmtlcnMgd2lsbCBiZSB0ZXJtaW5hdGVkIGFmdGVyIGJlaW5nIGlkbGUgdGhpcyBtYW55IG1pbGxpc2Vjb25kc1xuICBjb25zdCB0aHJlYWRzID0ge307XG4gIGxldCBjYWxsTnVtID0gMDtcblxuICAvKipcbiAgICogRmFsbGJhY2sgSlMtYmFzZWQgaW1wbGVtZW50YXRpb24sIGZhbm5lZCBvdXQgdG8gYSBudW1iZXIgb2Ygd29ya2VyIHRocmVhZHMgZm9yIHBhcmFsbGVsaXNtXG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpIHtcbiAgICBjb25zdCB3b3JrZXJJZCA9ICdUcm9pa2FUZXh0U0RGR2VuZXJhdG9yX0pTXycgKyAoKGNhbGxOdW0rKykgJSB0aHJlYWRDb3VudCk7XG4gICAgbGV0IHRocmVhZCA9IHRocmVhZHNbd29ya2VySWRdO1xuICAgIGlmICghdGhyZWFkKSB7XG4gICAgICB0aHJlYWQgPSB0aHJlYWRzW3dvcmtlcklkXSA9IHtcbiAgICAgICAgd29ya2VyTW9kdWxlOiB0cm9pa2FXb3JrZXJVdGlscy5kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgICAgICAgIG5hbWU6IHdvcmtlcklkLFxuICAgICAgICAgIHdvcmtlcklkLFxuICAgICAgICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgICAgICAgY3JlYXRlU0RGR2VuZXJhdG9yX19kZWZhdWx0WydkZWZhdWx0J10sXG4gICAgICAgICAgICBub3dcbiAgICAgICAgICBdLFxuICAgICAgICAgIGluaXQoX2NyZWF0ZVNERkdlbmVyYXRvciwgbm93KSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZSA9IF9jcmVhdGVTREZHZW5lcmF0b3IoKS5qYXZhc2NyaXB0LmdlbmVyYXRlO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVEYXRhID0gZ2VuZXJhdGUoLi4uYXJncyk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZURhdGEsXG4gICAgICAgICAgICAgICAgdGltaW5nOiBub3coKSAtIHN0YXJ0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFRyYW5zZmVyYWJsZXMocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdC50ZXh0dXJlRGF0YS5idWZmZXJdXG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcmVxdWVzdHM6IDAsXG4gICAgICAgIGlkbGVUaW1lcjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJlYWQucmVxdWVzdHMrKztcbiAgICBjbGVhclRpbWVvdXQodGhyZWFkLmlkbGVUaW1lcik7XG4gICAgcmV0dXJuIHRocmVhZC53b3JrZXJNb2R1bGUod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50KVxuICAgICAgLnRoZW4oKHsgdGV4dHVyZURhdGEsIHRpbWluZyB9KSA9PiB7XG4gICAgICAgIC8vIGNvcHkgcmVzdWx0IGRhdGEgaW50byB0aGUgY2FudmFzXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAgIC8vIGV4cGFuZCBzaW5nbGUtY2hhbm5lbCBkYXRhIGludG8gcmdiYVxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlRGF0YS5sZW5ndGggKiA0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGltYWdlRGF0YVtpICogNCArIGNoYW5uZWxdID0gdGV4dHVyZURhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlbmRlckltYWdlRGF0YShjYW52YXMsIGltYWdlRGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSA8PCAoMyAtIGNoYW5uZWwpKTtcbiAgICAgICAgdGltaW5nICs9IG5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgd29ya2VycyBhZnRlciBhIHdoaWxlXG4gICAgICAgIGlmICgtLXRocmVhZC5yZXF1ZXN0cyA9PT0gMCkge1xuICAgICAgICAgIHRocmVhZC5pZGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgdHJvaWthV29ya2VyVXRpbHMudGVybWluYXRlV29ya2VyKHdvcmtlcklkKTsgfSwgaWRsZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRpbWluZyB9XG4gICAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gd2FybVVwU0RGQ2FudmFzKGNhbnZhcykge1xuICAgIGlmICghY2FudmFzLl93YXJtKSB7XG4gICAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsLmlzU3VwcG9ydGVkKGNhbnZhcyk7XG4gICAgICBjYW52YXMuX3dhcm0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nID0gbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nO1xuXG4gIGNvbnN0IENPTkZJRyA9IHtcbiAgICBkZWZhdWx0Rm9udFVSTDogbnVsbCxcbiAgICB1bmljb2RlRm9udHNVUkw6IG51bGwsXG4gICAgc2RmR2x5cGhTaXplOiA2NCxcbiAgICBzZGZNYXJnaW46IDEgLyAxNixcbiAgICBzZGZFeHBvbmVudDogOSxcbiAgICB0ZXh0dXJlV2lkdGg6IDIwNDgsXG4gIH07XG4gIGNvbnN0IHRlbXBDb2xvciA9IC8qI19fUFVSRV9fKi9uZXcgdGhyZWUuQ29sb3IoKTtcbiAgbGV0IGhhc1JlcXVlc3RlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG5vdyQxKCkge1xuICAgIHJldHVybiAoc2VsZi5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKVxuICB9XG5cbiAgLyoqXG4gICAqIEN1c3RvbWl6ZXMgdGhlIHRleHQgYnVpbGRlciBjb25maWd1cmF0aW9uLiBUaGlzIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvIHRoZSBmaXJzdCBmb250IHByb2Nlc3NpbmdcbiAgICogcmVxdWVzdCwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRlZmF1bHRGb250VVJMIC0gVGhlIFVSTCBvZiB0aGUgZGVmYXVsdCBmb250IHRvIHVzZSBmb3IgdGV4dCBwcm9jZXNzaW5nXG4gICAqICAgICAgICAgICAgICAgICByZXF1ZXN0cywgaW4gY2FzZSBub25lIGlzIHNwZWNpZmllZCBvciB0aGUgc3BlY2lmaWVkZSBmb250IGZhaWxzIHRvIGxvYWQgb3IgcGFyc2UuXG4gICAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBcIlJvYm90byBSZWd1bGFyXCIgZnJvbSBHb29nbGUgRm9udHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudW5pY29kZUZvbnRzVVJMIC0gQSBjdXN0b20gbG9jYXRpb24gZm9yIHRoZSBmYWxsYmFjayB1bmljb2RlLWZvbnQtcmVzb2x2ZXJcbiAgICogICAgICAgICAgICAgICAgIGRhdGEgYW5kIGZvbnQgZmlsZXMsIGlmIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCBDRE4uIFNlZVxuICAgKiAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2xvamppYy91bmljb2RlLWZvbnQtcmVzb2x2ZXIgZm9yIGRldGFpbHMuIEl0IGNhbiBhbHNvIGJlXG4gICAqICAgICAgICAgICAgICAgICBjb25maWd1cmVkIHBlciB0ZXh0IGluc3RhbmNlLCBidXQgdGhpcyBsZXRzIHlvdSBkbyBpdCBvbmNlIGdsb2JhbGx5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkdseXBoU2l6ZSAtIFRoZSBkZWZhdWx0IHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKVxuICAgKiAgICAgICAgICAgICAgICAgdGV4dHVyZSB1c2VkIGZvciByZW5kZXJpbmcuIE11c3QgYmUgYSBwb3dlci1vZi10d28gbnVtYmVyLCBhbmQgYXBwbGllcyB0byBhbGwgZm9udHMsXG4gICAqICAgICAgICAgICAgICAgICBidXQgbm90ZSB0aGF0IHRoaXMgY2FuIGFsc28gYmUgb3ZlcnJpZGRlbiBwZXIgY2FsbCB0byBgZ2V0VGV4dFJlbmRlckluZm8oKWAuXG4gICAqICAgICAgICAgICAgICAgICBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmcgdGhlIHNoYXJwbmVzc1xuICAgKiAgICAgICAgICAgICAgICAgb2YgY29ybmVycyBhbmQgcHJldmVudGluZyBsb3NzIG9mIHZlcnkgdGhpbiBsaW5lcywgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5LiBEZWZhdWx0c1xuICAgKiAgICAgICAgICAgICAgICAgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCB3aGVuIGVuY29kaW5nIHRoZSBTREYgdmFsdWVzLiBBIGhpZ2hlciBleHBvbmVudFxuICAgKiAgICAgICAgICAgICAgICAgc2hpZnRzIHRoZSBlbmNvZGVkIDgtYml0IHZhbHVlcyB0byBhY2hpZXZlIGhpZ2hlciBwcmVjaXNpb24vYWNjdXJhY3kgYXQgdGV4ZWxzIG5lYXJlclxuICAgKiAgICAgICAgICAgICAgICAgdGhlIGdseXBoJ3MgcGF0aCwgd2l0aCBsb3dlciBwcmVjaXNpb24gZnVydGhlciBhd2F5LiBEZWZhdWx0cyB0byA5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZk1hcmdpbiAtIEhvdyBtdWNoIHNwYWNlIHRvIHJlc2VydmUgaW4gdGhlIFNERiBhcyBtYXJnaW4gb3V0c2lkZSB0aGUgZ2x5cGgnc1xuICAgKiAgICAgICAgICAgICAgICAgcGF0aCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBTREYgd2lkdGguIEEgbGFyZ2VyIG1hcmdpbiBpbmNyZWFzZXMgdGhlIHF1YWxpdHkgb2ZcbiAgICogICAgICAgICAgICAgICAgIGV4dHJ1ZGVkIGdseXBoIG91dGxpbmVzLCBidXQgZGVjcmVhc2VzIHRoZSBwcmVjaXNpb24gYXZhaWxhYmxlIGZvciB0aGUgZ2x5cGggaXRzZWxmLlxuICAgKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gMS8xNnRoIG9mIHRoZSBnbHlwaCBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnRleHR1cmVXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgU0RGIHRleHR1cmU7IG11c3QgYmUgYSBwb3dlciBvZiAyLiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgICAgICAgICAgMjA0OCB3aGljaCBpcyBhIHNhZmUgbWF4aW11bSB0ZXh0dXJlIGRpbWVuc2lvbiBhY2NvcmRpbmcgdG8gdGhlIHN0YXRzIGF0XG4gICAqICAgICAgICAgICAgICAgICBodHRwczovL3dlYmdsc3RhdHMuY29tL3dlYmdsL3BhcmFtZXRlci9NQVhfVEVYVFVSRV9TSVpFIGFuZCBzaG91bGQgYWxsb3cgZm9yIGFcbiAgICogICAgICAgICAgICAgICAgIHJlYXNvbmFibHkgbGFyZ2UgbnVtYmVyIG9mIGdseXBocyAoZGVmYXVsdCBnbHlwaCBzaXplIG9mIDY0XjIgYW5kIHNhZmUgdGV4dHVyZSBzaXplIG9mXG4gICAqICAgICAgICAgICAgICAgICAyMDQ4XjIsIHRpbWVzIDQgY2hhbm5lbHMsIGFsbG93cyBmb3IgNDA5NiBnbHlwaHMuKSBUaGlzIGNhbiBiZSBpbmNyZWFzZWQgaWYgeW91IG5lZWQgdG9cbiAgICogICAgICAgICAgICAgICAgIGluY3JlYXNlIHRoZSBnbHlwaCBzaXplIGFuZC9vciBoYXZlIGFuIGV4dHJhb3JkaW5hcnkgbnVtYmVyIG9mIGdseXBocy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZVRleHRCdWlsZGVyKGNvbmZpZykge1xuICAgIGlmIChoYXNSZXF1ZXN0ZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignY29uZmlndXJlVGV4dEJ1aWxkZXIgY2FsbGVkIGFmdGVyIGZpcnN0IGZvbnQgcmVxdWVzdDsgd2lsbCBiZSBpZ25vcmVkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ24oQ09ORklHLCBjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBvc2l0b3J5IGZvciBhbGwgZm9udCBTREYgYXRsYXMgdGV4dHVyZXMgYW5kIHRoZWlyIGdseXBoIG1hcHBpbmdzLiBUaGVyZSBpcyBhIHNlcGFyYXRlIGF0bGFzIGZvclxuICAgKiBlYWNoIHNkZkdseXBoU2l6ZS4gRWFjaCBhdGxhcyBoYXMgYSBzaW5nbGUgVGV4dHVyZSB0aGF0IGhvbGRzIGFsbCBnbHlwaHMgZm9yIGFsbCBmb250cy5cbiAgICpcbiAgICogICB7XG4gICAqICAgICBbc2RmR2x5cGhTaXplXToge1xuICAgKiAgICAgICBnbHlwaENvdW50OiBudW1iZXIsXG4gICAqICAgICAgIHNkZkdseXBoU2l6ZTogbnVtYmVyLFxuICAgKiAgICAgICBzZGZUZXh0dXJlOiBUZXh0dXJlLFxuICAgKiAgICAgICBzZGZDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICAgKiAgICAgICBjb250ZXh0TG9zdDogYm9vbGVhbixcbiAgICogICAgICAgZ2x5cGhzQnlGb250OiBNYXA8Zm9udFVSTCwgTWFwPGdseXBoSUQsIHtwYXRoLCBhdGxhc0luZGV4LCBzZGZWaWV3Qm94fT4+XG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKi9cbiAgY29uc3QgYXRsYXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtvYmplY3R9IFRyb2lrYVRleHRSZW5kZXJJbmZvIC0gRm9ybWF0IG9mIHRoZSByZXN1bHQgZnJvbSBgZ2V0VGV4dFJlbmRlckluZm9gLlxuICAgKiBAcHJvcGVydHkge1R5cGVzZXRQYXJhbXN9IHBhcmFtZXRlcnMgLSBUaGUgbm9ybWFsaXplZCBpbnB1dCBhcmd1bWVudHMgdG8gdGhlIHJlbmRlciBjYWxsLlxuICAgKiBAcHJvcGVydHkge1RleHR1cmV9IHNkZlRleHR1cmUgLSBUaGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZGZHbHlwaFNpemUgLSBUaGUgc2l6ZSBvZiBlYWNoIGdseXBoJ3MgU0RGOyBzZWUgYGNvbmZpZ3VyZVRleHRCdWlsZGVyYC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZkV4cG9uZW50IC0gVGhlIGV4cG9uZW50IHVzZWQgaW4gZW5jb2RpbmcgdGhlIFNERidzIHZhbHVlczsgc2VlIGBjb25maWd1cmVUZXh0QnVpbGRlcmAuXG4gICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIExpc3Qgb2YgW21pblgsIG1pblksIG1heFgsIG1heFldIHF1YWQgYm91bmRzIGZvciBlYWNoIGdseXBoLlxuICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZ2x5cGhBdGxhc0luZGljZXMgLSBMaXN0IGhvbGRpbmcgZWFjaCBnbHlwaCdzIGluZGV4IGluIHRoZSBTREYgYXRsYXMuXG4gICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgW3IsIGcsIGJdIGNvbG9yLCBpZiBgY29sb3JSYW5nZXNgIHdhcyBzdXBwbGllZC5cbiAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IFtjYXJldFBvc2l0aW9uc10gLSBBIGxpc3Qgb2YgY2FyZXQgcG9zaXRpb25zIGZvciBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nOyBlYWNoIGlzXG4gICAqICAgICAgICAgICBmb3VyIGVsZW1lbnRzOiB0aGUgc3RhcnRpbmcgWCwgdGhlIGVuZGluZyBYLCB0aGUgYm90dG9tIFksIGFuZCB0aGUgdG9wIFkgZm9yIHRoZSBjYXJldC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYXJldEhlaWdodF0gLSBBbiBhcHByb3ByaWF0ZSBoZWlnaHQgZm9yIGFsbCBzZWxlY3Rpb24gY2FyZXRzLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gYXNjZW5kZXIgLSBUaGUgZm9udCdzIGFzY2VuZGVyIG1ldHJpYy5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbmRlciAtIFRoZSBmb250J3MgZGVzY2VuZGVyIG1ldHJpYy5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNhcEhlaWdodCAtIFRoZSBmb250J3MgY2FwIGhlaWdodCBtZXRyaWMsIGJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgTGF0aW4gY2FwaXRhbCBsZXR0ZXJzLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0geEhlaWdodCAtIFRoZSBmb250J3MgeCBoZWlnaHQgbWV0cmljLCBiYXNlZCBvbiB0aGUgaGVpZ2h0IG9mIExhdGluIGxvd2VyY2FzZSBsZXR0ZXJzLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbGluZUhlaWdodCAtIFRoZSBmaW5hbCBjb21wdXRlZCBsaW5lSGVpZ2h0IG1lYXN1cmVtZW50LlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdG9wQmFzZWxpbmUgLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgdG9wIGxpbmUncyBiYXNlbGluZS5cbiAgICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBibG9ja0JvdW5kcyAtIFRoZSB0b3RhbCBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gcmVjdCBvZiB0aGUgd2hvbGUgdGV4dCBibG9jaztcbiAgICogICAgICAgICAgIHRoaXMgY2FuIGluY2x1ZGUgZXh0cmEgdmVydGljYWwgc3BhY2UgYmV5b25kIHRoZSB2aXNpYmxlIGdseXBocyBkdWUgdG8gbGluZUhlaWdodCwgYW5kIGlzXG4gICAqICAgICAgICAgICBlcXVpdmFsZW50IHRvIHRoZSBkaW1lbnNpb25zIG9mIGEgYmxvY2stbGV2ZWwgdGV4dCBlbGVtZW50IGluIENTUy5cbiAgICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSB2aXNpYmxlQm91bmRzIC0gVGhlIHRvdGFsIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSByZWN0IG9mIHRoZSB3aG9sZSB0ZXh0IGJsb2NrO1xuICAgKiAgICAgICAgICAgdW5saWtlIGBibG9ja0JvdW5kc2AgdGhpcyBpcyB0aWdodGx5IHdyYXBwZWQgdG8gdGhlIHZpc2libGUgZ2x5cGggcGF0aHMuXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8b2JqZWN0Pn0gY2h1bmtlZEJvdW5kcyAtIExpc3Qgb2YgYm91bmRpbmcgcmVjdHMgZm9yIGVhY2ggY29uc2VjdXRpdmUgc2V0IG9mIE4gZ2x5cGhzLFxuICAgKiAgICAgICAgICAgaW4gdGhlIGZvcm1hdCBge3N0YXJ0Ok4sIGVuZDpOLCByZWN0OlttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXX1gLlxuICAgKiBAcHJvcGVydHkge29iamVjdH0gdGltaW5ncyAtIFRpbWluZyBpbmZvIGZvciB2YXJpb3VzIHBhcnRzIG9mIHRoZSByZW5kZXJpbmcgbG9naWMgaW5jbHVkaW5nIFNERlxuICAgKiAgICAgICAgICAgZ2VuZXJhdGlvbiwgdHlwZXNldHRpbmcsIGV0Yy5cbiAgICogQGZyb3plblxuICAgKi9cblxuICAvKipcbiAgICogQGNhbGxiYWNrIGdldFRleHRSZW5kZXJJbmZvfmNhbGxiYWNrXG4gICAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNYWluIGVudHJ5IHBvaW50IGZvciByZXF1ZXN0aW5nIHRoZSBkYXRhIG5lZWRlZCB0byByZW5kZXIgYSB0ZXh0IHN0cmluZyB3aXRoIGdpdmVuIGZvbnQgcGFyYW1ldGVycy5cbiAgICogVGhpcyBpcyBhbiBhc3luY2hyb25vdXMgY2FsbCwgcGVyZm9ybWluZyBtb3N0IG9mIHRoZSBsb2dpYyBpbiBhIHdlYiB3b3JrZXIgdGhyZWFkLlxuICAgKiBAcGFyYW0ge1R5cGVzZXRQYXJhbXN9IGFyZ3NcbiAgICogQHBhcmFtIHtnZXRUZXh0UmVuZGVySW5mb35jYWxsYmFja30gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIGdldFRleHRSZW5kZXJJbmZvKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgaGFzUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICBhcmdzID0gYXNzaWduKHt9LCBhcmdzKTtcbiAgICBjb25zdCB0b3RhbFN0YXJ0ID0gbm93JDEoKTtcblxuICAgIC8vIENvbnZlcnQgcmVsYXRpdmUgVVJMIHRvIGFic29sdXRlIHNvIGl0IGNhbiBiZSByZXNvbHZlZCBpbiB0aGUgd29ya2VyLCBhbmQgYWRkIGZhbGxiYWNrcy5cbiAgICAvLyBJbiB0aGUgZnV0dXJlIHdlJ2xsIGFsbG93IGFyZ3MuZm9udCB0byBiZSBhIGxpc3Qgd2l0aCB1bmljb2RlIHJhbmdlcyB0b28uXG4gICAgY29uc3QgeyBkZWZhdWx0Rm9udFVSTCB9ID0gQ09ORklHO1xuICAgIGNvbnN0IGZvbnRzID0gW107XG4gICAgaWYgKGRlZmF1bHRGb250VVJMKSB7XG4gICAgICBmb250cy5wdXNoKHtsYWJlbDogJ2RlZmF1bHQnLCBzcmM6IHRvQWJzb2x1dGVVUkwoZGVmYXVsdEZvbnRVUkwpfSk7XG4gICAgfVxuICAgIGlmIChhcmdzLmZvbnQpIHtcbiAgICAgIGZvbnRzLnB1c2goe2xhYmVsOiAndXNlcicsIHNyYzogdG9BYnNvbHV0ZVVSTChhcmdzLmZvbnQpfSk7XG4gICAgfVxuICAgIGFyZ3MuZm9udCA9IGZvbnRzO1xuXG4gICAgLy8gTm9ybWFsaXplIHRleHQgdG8gYSBzdHJpbmdcbiAgICBhcmdzLnRleHQgPSAnJyArIGFyZ3MudGV4dDtcblxuICAgIGFyZ3Muc2RmR2x5cGhTaXplID0gYXJncy5zZGZHbHlwaFNpemUgfHwgQ09ORklHLnNkZkdseXBoU2l6ZTtcbiAgICBhcmdzLnVuaWNvZGVGb250c1VSTCA9IGFyZ3MudW5pY29kZUZvbnRzVVJMIHx8IENPTkZJRy51bmljb2RlRm9udHNVUkw7XG5cbiAgICAvLyBOb3JtYWxpemUgY29sb3JzXG4gICAgaWYgKGFyZ3MuY29sb3JSYW5nZXMgIT0gbnVsbCkge1xuICAgICAgbGV0IGNvbG9ycyA9IHt9O1xuICAgICAgZm9yIChsZXQga2V5IGluIGFyZ3MuY29sb3JSYW5nZXMpIHtcbiAgICAgICAgaWYgKGFyZ3MuY29sb3JSYW5nZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGxldCB2YWwgPSBhcmdzLmNvbG9yUmFuZ2VzW2tleV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWwgPSB0ZW1wQ29sb3Iuc2V0KHZhbCkuZ2V0SGV4KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbG9yc1trZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzLmNvbG9yUmFuZ2VzID0gY29sb3JzO1xuICAgIH1cblxuICAgIE9iamVjdC5mcmVlemUoYXJncyk7XG5cbiAgICAvLyBJbml0IHRoZSBhdGxhcyBpZiBuZWVkZWRcbiAgICBjb25zdCB7dGV4dHVyZVdpZHRoLCBzZGZFeHBvbmVudH0gPSBDT05GSUc7XG4gICAgY29uc3Qge3NkZkdseXBoU2l6ZX0gPSBhcmdzO1xuICAgIGNvbnN0IGdseXBoc1BlclJvdyA9ICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUgKiA0KTtcbiAgICBsZXQgYXRsYXMgPSBhdGxhc2VzW3NkZkdseXBoU2l6ZV07XG4gICAgaWYgKCFhdGxhcykge1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjYW52YXMud2lkdGggPSB0ZXh0dXJlV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gc2RmR2x5cGhTaXplICogMjU2IC8gZ2x5cGhzUGVyUm93OyAvLyBzdGFydCB0YWxsIGVub3VnaCB0byBmaXQgMjU2IGdseXBoc1xuICAgICAgYXRsYXMgPSBhdGxhc2VzW3NkZkdseXBoU2l6ZV0gPSB7XG4gICAgICAgIGdseXBoQ291bnQ6IDAsXG4gICAgICAgIHNkZkdseXBoU2l6ZSxcbiAgICAgICAgc2RmQ2FudmFzOiBjYW52YXMsXG4gICAgICAgIHNkZlRleHR1cmU6IG5ldyB0aHJlZS5UZXh0dXJlKFxuICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB0aHJlZS5MaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgdGhyZWUuTGluZWFyRmlsdGVyXG4gICAgICAgICksXG4gICAgICAgIGNvbnRleHRMb3N0OiBmYWxzZSxcbiAgICAgICAgZ2x5cGhzQnlGb250OiBuZXcgTWFwKClcbiAgICAgIH07XG4gICAgICBhdGxhcy5zZGZUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHtzZGZUZXh0dXJlLCBzZGZDYW52YXN9ID0gYXRsYXM7XG5cbiAgICAvLyBJc3N1ZSByZXF1ZXN0IHRvIHRoZSB0eXBlc2V0dGluZyBlbmdpbmUgaW4gdGhlIHdvcmtlclxuICAgIHR5cGVzZXRJbldvcmtlcihhcmdzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCB7Z2x5cGhJZHMsIGdseXBoRm9udEluZGljZXMsIGZvbnREYXRhLCBnbHlwaFBvc2l0aW9ucywgZm9udFNpemUsIHRpbWluZ3N9ID0gcmVzdWx0O1xuICAgICAgY29uc3QgbmVlZGVkU0RGcyA9IFtdO1xuICAgICAgY29uc3QgZ2x5cGhCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KGdseXBoSWRzLmxlbmd0aCAqIDQpO1xuICAgICAgbGV0IGJvdW5kc0lkeCA9IDA7XG4gICAgICBsZXQgcG9zaXRpb25zSWR4ID0gMDtcbiAgICAgIGNvbnN0IHF1YWRzU3RhcnQgPSBub3ckMSgpO1xuXG4gICAgICBjb25zdCBmb250R2x5cGhNYXBzID0gZm9udERhdGEubWFwKGZvbnQgPT4ge1xuICAgICAgICBsZXQgbWFwID0gYXRsYXMuZ2x5cGhzQnlGb250LmdldChmb250LnNyYyk7XG4gICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgYXRsYXMuZ2x5cGhzQnlGb250LnNldChmb250LnNyYywgbWFwID0gbmV3IE1hcCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwXG4gICAgICB9KTtcblxuICAgICAgZ2x5cGhJZHMuZm9yRWFjaCgoZ2x5cGhJZCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBmb250SW5kZXggPSBnbHlwaEZvbnRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCB7c3JjOiBmb250U3JjLCB1bml0c1BlckVtfSA9IGZvbnREYXRhW2ZvbnRJbmRleF07XG4gICAgICAgIGxldCBnbHlwaEluZm8gPSBmb250R2x5cGhNYXBzW2ZvbnRJbmRleF0uZ2V0KGdseXBoSWQpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBnbHlwaElkIG5vdCBzZWVuIGJlZm9yZSwgYWRkIGl0IHRvIHRoZSBhdGxhc1xuICAgICAgICBpZiAoIWdseXBoSW5mbykge1xuICAgICAgICAgIGNvbnN0IHtwYXRoLCBwYXRoQm91bmRzfSA9IHJlc3VsdC5nbHlwaERhdGFbZm9udFNyY11bZ2x5cGhJZF07XG5cbiAgICAgICAgICAvLyBNYXJnaW4gYXJvdW5kIHBhdGggZWRnZXMgaW4gU0RGLCBiYXNlZCBvbiBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGdseXBoJ3MgbWF4IGRpbWVuc2lvbi5cbiAgICAgICAgICAvLyBOb3RlIHdlIGFkZCBhbiBleHRyYSAwLjUgcHggb3ZlciB0aGUgY29uZmlndXJlZCB2YWx1ZSBiZWNhdXNlIHRoZSBvdXRlciAwLjUgZG9lc24ndCBjb250YWluXG4gICAgICAgICAgLy8gdXNlZnVsIGludGVycG9sYXRlZCB2YWx1ZXMgYW5kIHdpbGwgYmUgaWdub3JlZCBhbnl3YXkuXG4gICAgICAgICAgY29uc3QgZm9udFVuaXRzTWFyZ2luID0gTWF0aC5tYXgocGF0aEJvdW5kc1syXSAtIHBhdGhCb3VuZHNbMF0sIHBhdGhCb3VuZHNbM10gLSBwYXRoQm91bmRzWzFdKVxuICAgICAgICAgICAgLyBzZGZHbHlwaFNpemUgKiAoQ09ORklHLnNkZk1hcmdpbiAqIHNkZkdseXBoU2l6ZSArIDAuNSk7XG5cbiAgICAgICAgICBjb25zdCBhdGxhc0luZGV4ID0gYXRsYXMuZ2x5cGhDb3VudCsrO1xuICAgICAgICAgIGNvbnN0IHNkZlZpZXdCb3ggPSBbXG4gICAgICAgICAgICBwYXRoQm91bmRzWzBdIC0gZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgICAgcGF0aEJvdW5kc1sxXSAtIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICAgIHBhdGhCb3VuZHNbMl0gKyBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgICBwYXRoQm91bmRzWzNdICsgZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgIF07XG4gICAgICAgICAgZm9udEdseXBoTWFwc1tmb250SW5kZXhdLnNldChnbHlwaElkLCAoZ2x5cGhJbmZvID0geyBwYXRoLCBhdGxhc0luZGV4LCBzZGZWaWV3Qm94IH0pKTtcblxuICAgICAgICAgIC8vIENvbGxlY3QgdGhvc2UgdGhhdCBuZWVkIFNERiBnZW5lcmF0aW9uXG4gICAgICAgICAgbmVlZGVkU0RGcy5wdXNoKGdseXBoSW5mbyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgYm91bmRzIGZvciByZW5kZXJhYmxlIHF1YWRzXG4gICAgICAgIC8vIFRPRE8gY2FuIHdlIGdldCB0aGlzIGJhY2sgb2ZmIHRoZSBtYWluIHRocmVhZD9cbiAgICAgICAgY29uc3Qge3NkZlZpZXdCb3h9ID0gZ2x5cGhJbmZvO1xuICAgICAgICBjb25zdCBwb3NYID0gZ2x5cGhQb3NpdGlvbnNbcG9zaXRpb25zSWR4KytdO1xuICAgICAgICBjb25zdCBwb3NZID0gZ2x5cGhQb3NpdGlvbnNbcG9zaXRpb25zSWR4KytdO1xuICAgICAgICBjb25zdCBmb250U2l6ZU11bHQgPSBmb250U2l6ZSAvIHVuaXRzUGVyRW07XG4gICAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1ggKyBzZGZWaWV3Qm94WzBdICogZm9udFNpemVNdWx0O1xuICAgICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NZICsgc2RmVmlld0JveFsxXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWCArIHNkZlZpZXdCb3hbMl0gKiBmb250U2l6ZU11bHQ7XG4gICAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1kgKyBzZGZWaWV3Qm94WzNdICogZm9udFNpemVNdWx0O1xuXG4gICAgICAgIC8vIENvbnZlcnQgZ2x5cGhJZCB0byBTREYgaW5kZXggZm9yIHRoZSBzaGFkZXJcbiAgICAgICAgZ2x5cGhJZHNbaV0gPSBnbHlwaEluZm8uYXRsYXNJbmRleDtcbiAgICAgIH0pO1xuICAgICAgdGltaW5ncy5xdWFkcyA9ICh0aW1pbmdzLnF1YWRzIHx8IDApICsgKG5vdyQxKCkgLSBxdWFkc1N0YXJ0KTtcblxuICAgICAgY29uc3Qgc2RmU3RhcnQgPSBub3ckMSgpO1xuICAgICAgdGltaW5ncy5zZGYgPSB7fTtcblxuICAgICAgLy8gR3JvdyB0aGUgdGV4dHVyZSBoZWlnaHQgYnkgcG93ZXIgb2YgMiBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBzZGZDYW52YXMuaGVpZ2h0O1xuICAgICAgY29uc3QgbmVlZGVkUm93cyA9IE1hdGguY2VpbChhdGxhcy5nbHlwaENvdW50IC8gZ2x5cGhzUGVyUm93KTtcbiAgICAgIGNvbnN0IG5lZWRlZEhlaWdodCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobmVlZGVkUm93cyAqIHNkZkdseXBoU2l6ZSkpKTtcbiAgICAgIGlmIChuZWVkZWRIZWlnaHQgPiBjdXJyZW50SGVpZ2h0KSB7XG4gICAgICAgIC8vIFNpbmNlIHJlc2l6aW5nIHRoZSBjYW52YXMgY2xlYXJzIGl0cyByZW5kZXIgYnVmZmVyLCBpdCBuZWVkcyBzcGVjaWFsIGhhbmRsaW5nIHRvIGNvcHkgdGhlIG9sZCBjb250ZW50cyBvdmVyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgSW5jcmVhc2luZyBTREYgdGV4dHVyZSBzaXplICR7Y3VycmVudEhlaWdodH0tPiR7bmVlZGVkSGVpZ2h0fWApO1xuICAgICAgICByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZyhzZGZDYW52YXMsIHRleHR1cmVXaWR0aCwgbmVlZGVkSGVpZ2h0KTtcbiAgICAgICAgLy8gQXMgb2YgVGhyZWUgcjEzNiB0ZXh0dXJlcyBjYW5ub3QgYmUgcmVzaXplZCBvbmNlIHRoZXkncmUgYWxsb2NhdGVkIG9uIHRoZSBHUFUsIHdlIG11c3QgZGlzcG9zZSB0byByZWFsbG9jYXRlIGl0XG4gICAgICAgIHNkZlRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBQcm9taXNlLmFsbChuZWVkZWRTREZzLm1hcChnbHlwaEluZm8gPT5cbiAgICAgICAgZ2VuZXJhdGVHbHlwaFNERihnbHlwaEluZm8sIGF0bGFzLCBhcmdzLmdwdUFjY2VsZXJhdGVTREYpLnRoZW4oKHt0aW1pbmd9KSA9PiB7XG4gICAgICAgICAgdGltaW5ncy5zZGZbZ2x5cGhJbmZvLmF0bGFzSW5kZXhdID0gdGltaW5nO1xuICAgICAgICB9KVxuICAgICAgKSkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChuZWVkZWRTREZzLmxlbmd0aCAmJiAhYXRsYXMuY29udGV4dExvc3QpIHtcbiAgICAgICAgICBzYWZhcmlQcmUxNVdvcmthcm91bmQoYXRsYXMpO1xuICAgICAgICAgIHNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRpbWluZ3Muc2RmVG90YWwgPSBub3ckMSgpIC0gc2RmU3RhcnQ7XG4gICAgICAgIHRpbWluZ3MudG90YWwgPSBub3ckMSgpIC0gdG90YWxTdGFydDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYFNERiAtICR7dGltaW5ncy5zZGZUb3RhbH0sIFRvdGFsIC0gJHt0aW1pbmdzLnRvdGFsIC0gdGltaW5ncy5mb250TG9hZH1gKVxuXG4gICAgICAgIC8vIEludm9rZSBjYWxsYmFjayB3aXRoIHRoZSB0ZXh0IGxheW91dCBhcnJheXMgYW5kIHVwZGF0ZWQgdGV4dHVyZVxuICAgICAgICBjYWxsYmFjayhPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBhcmdzLFxuICAgICAgICAgIHNkZlRleHR1cmUsXG4gICAgICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgICAgIHNkZkV4cG9uZW50LFxuICAgICAgICAgIGdseXBoQm91bmRzLFxuICAgICAgICAgIGdseXBoQXRsYXNJbmRpY2VzOiBnbHlwaElkcyxcbiAgICAgICAgICBnbHlwaENvbG9yczogcmVzdWx0LmdseXBoQ29sb3JzLFxuICAgICAgICAgIGNhcmV0UG9zaXRpb25zOiByZXN1bHQuY2FyZXRQb3NpdGlvbnMsXG4gICAgICAgICAgY2h1bmtlZEJvdW5kczogcmVzdWx0LmNodW5rZWRCb3VuZHMsXG4gICAgICAgICAgYXNjZW5kZXI6IHJlc3VsdC5hc2NlbmRlcixcbiAgICAgICAgICBkZXNjZW5kZXI6IHJlc3VsdC5kZXNjZW5kZXIsXG4gICAgICAgICAgbGluZUhlaWdodDogcmVzdWx0LmxpbmVIZWlnaHQsXG4gICAgICAgICAgY2FwSGVpZ2h0OiByZXN1bHQuY2FwSGVpZ2h0LFxuICAgICAgICAgIHhIZWlnaHQ6IHJlc3VsdC54SGVpZ2h0LFxuICAgICAgICAgIHRvcEJhc2VsaW5lOiByZXN1bHQudG9wQmFzZWxpbmUsXG4gICAgICAgICAgYmxvY2tCb3VuZHM6IHJlc3VsdC5ibG9ja0JvdW5kcyxcbiAgICAgICAgICB2aXNpYmxlQm91bmRzOiByZXN1bHQudmlzaWJsZUJvdW5kcyxcbiAgICAgICAgICB0aW1pbmdzOiByZXN1bHQudGltaW5ncyxcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBXaGlsZSB0aGUgdHlwZXNldHRpbmcgcmVxdWVzdCBpcyBiZWluZyBoYW5kbGVkLCBnbyBhaGVhZCBhbmQgbWFrZSBzdXJlIHRoZSBhdGxhcyBjYW52YXMgY29udGV4dCBpc1xuICAgIC8vIFwid2FybWVkIHVwXCI7IHRoZSBmaXJzdCByZXF1ZXN0IHdpbGwgYmUgdGhlIGxvbmdlc3QgZHVlIHRvIHNoYWRlciBwcm9ncmFtIGNvbXBpbGF0aW9uIHNvIHRoaXMgZ2V0c1xuICAgIC8vIGEgaGVhZCBzdGFydCBvbiB0aGF0IHByb2Nlc3MgYmVmb3JlIFNERnMgYWN0dWFsbHkgc3RhcnQgZ2V0dGluZyBwcm9jZXNzZWQuXG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWF0bGFzLmNvbnRleHRMb3N0KSB7XG4gICAgICAgIHdhcm1VcFNERkNhbnZhcyhzZGZDYW52YXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVHbHlwaFNERih7cGF0aCwgYXRsYXNJbmRleCwgc2RmVmlld0JveH0sIHtzZGZHbHlwaFNpemUsIHNkZkNhbnZhcywgY29udGV4dExvc3R9LCB1c2VHUFUpIHtcbiAgICBpZiAoY29udGV4dExvc3QpIHtcbiAgICAgIC8vIElmIHRoZSBjb250ZXh0IGlzIGxvc3QgdGhlcmUncyBub3RoaW5nIHdlIGNhbiBkbywganVzdCBxdWl0IHNpbGVudGx5IGFuZCBsZXQgaXRcbiAgICAgIC8vIGdldCByZWdlbmVyYXRlZCB3aGVuIHRoZSBjb250ZXh0IGlzIHJlc3RvcmVkXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt0aW1pbmc6IC0xfSlcbiAgICB9XG4gICAgY29uc3Qge3RleHR1cmVXaWR0aCwgc2RmRXhwb25lbnR9ID0gQ09ORklHO1xuICAgIGNvbnN0IG1heERpc3QgPSBNYXRoLm1heChzZGZWaWV3Qm94WzJdIC0gc2RmVmlld0JveFswXSwgc2RmVmlld0JveFszXSAtIHNkZlZpZXdCb3hbMV0pO1xuICAgIGNvbnN0IHNxdWFyZUluZGV4ID0gTWF0aC5mbG9vcihhdGxhc0luZGV4IC8gNCk7XG4gICAgY29uc3QgeCA9IHNxdWFyZUluZGV4ICUgKHRleHR1cmVXaWR0aCAvIHNkZkdseXBoU2l6ZSkgKiBzZGZHbHlwaFNpemU7XG4gICAgY29uc3QgeSA9IE1hdGguZmxvb3Ioc3F1YXJlSW5kZXggLyAodGV4dHVyZVdpZHRoIC8gc2RmR2x5cGhTaXplKSkgKiBzZGZHbHlwaFNpemU7XG4gICAgY29uc3QgY2hhbm5lbCA9IGF0bGFzSW5kZXggJSA0O1xuICAgIHJldHVybiBnZW5lcmF0ZVNERihzZGZHbHlwaFNpemUsIHNkZkdseXBoU2l6ZSwgcGF0aCwgc2RmVmlld0JveCwgbWF4RGlzdCwgc2RmRXhwb25lbnQsIHNkZkNhbnZhcywgeCwgeSwgY2hhbm5lbCwgdXNlR1BVKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpIHtcbiAgICBjb25zdCBjYW52YXMgPSBhdGxhcy5zZGZDYW52YXM7XG5cbiAgICAvKlxuICAgIC8vIEJlZ2luIGNvbnRleHQgbG9zcyBzaW11bGF0aW9uXG4gICAgaWYgKCF3aW5kb3cuV2ViR0xEZWJ1Z1V0aWxzKSB7XG4gICAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dlYkdMRGVidWdVdGlsc1NjcmlwdCcpXG4gICAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICAgICAgICBzY3JpcHQuaWQgPSAnV2ViR0xEZWJ1Z1V0aWxzJ1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICAgICAgc2NyaXB0LnNyYyA9ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvS2hyb25vc0dyb3VwL1dlYkdMRGV2ZWxvcGVyVG9vbHNAYjQyZTcwMi9zcmMvZGVidWcvd2ViZ2wtZGVidWcuanMnXG4gICAgICB9XG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHdpbmRvdy5XZWJHTERlYnVnVXRpbHMubWFrZUxvc3RDb250ZXh0U2ltdWxhdGluZ0NhbnZhcyhjYW52YXMpXG4gICAgY2FudmFzLmxvc2VDb250ZXh0SW5OQ2FsbHMoNTAwKVxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIChldmVudCkgPT4ge1xuICAgICAgY2FudmFzLmxvc2VDb250ZXh0SW5OQ2FsbHMoNTAwMClcbiAgICB9KVxuICAgIC8vIEVuZCBjb250ZXh0IGxvc3Mgc2ltdWxhdGlvblxuICAgICovXG5cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIChldmVudCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ0NvbnRleHQgTG9zdCcsIGV2ZW50KTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBhdGxhcy5jb250ZXh0TG9zdCA9IHRydWU7XG4gICAgfSk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnQ29udGV4dCBSZXN0b3JlZCcsIGV2ZW50KTtcbiAgICAgIGF0bGFzLmNvbnRleHRMb3N0ID0gZmFsc2U7XG4gICAgICAvLyBSZWdlbmVyYXRlIGFsbCBnbHlwaHMgaW50byB0aGUgcmVzdG9yZWQgY2FudmFzOlxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIGF0bGFzLmdseXBoc0J5Rm9udC5mb3JFYWNoKGdseXBoTWFwID0+IHtcbiAgICAgICAgZ2x5cGhNYXAuZm9yRWFjaChnbHlwaCA9PiB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChnZW5lcmF0ZUdseXBoU0RGKGdseXBoLCBhdGxhcywgdHJ1ZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICBzYWZhcmlQcmUxNVdvcmthcm91bmQoYXRsYXMpO1xuICAgICAgICBhdGxhcy5zZGZUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZWxvYWQgYSBnaXZlbiBmb250IGFuZCBvcHRpb25hbGx5IHByZS1nZW5lcmF0ZSBnbHlwaCBTREZzIGZvciBvbmUgb3IgbW9yZSBjaGFyYWN0ZXIgc2VxdWVuY2VzLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gYXZvaWQgbG9uZyBwYXVzZXMgd2hlbiBmaXJzdCBzaG93aW5nIHRleHQgaW4gYSBzY2VuZSwgYnkgcHJlbG9hZGluZyB0aGVcbiAgICogbmVlZGVkIGZvbnRzIGFuZCBnbHlwaHMgdXAgZnJvbnQgYWxvbmcgd2l0aCBvdGhlciBhc3NldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZvbnQgLSBVUkwgb2YgdGhlIGZvbnQgZmlsZSB0byBwcmVsb2FkLiBJZiBub3QgZ2l2ZW4sIHRoZSBkZWZhdWx0IGZvbnQgd2lsbFxuICAgKiAgICAgICAgYmUgbG9hZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0aW9ucy5jaGFyYWN0ZXJzIC0gT25lIG9yIG1vcmUgY2hhcmFjdGVyIHNlcXVlbmNlcyBmb3Igd2hpY2ggdG8gcHJlLVxuICAgKiAgICAgICAgZ2VuZXJhdGUgZ2x5cGggU0RGcy4gTm90ZSB0aGF0IHRoaXMgd2lsbCBob25vciBsaWdhdHVyZSBzdWJzdGl0dXRpb24sIHNvIHlvdSBtYXkgbmVlZFxuICAgKiAgICAgICAgdG8gc3BlY2lmeSBsaWdhdHVyZSBzZXF1ZW5jZXMgaW4gYWRkaXRpb24gdG8gdGhlaXIgaW5kaXZpZHVhbCBjaGFyYWN0ZXJzIHRvIGdldCBhbGxcbiAgICogICAgICAgIHBvc3NpYmxlIGdseXBocywgZS5nLiBgW1widFwiLCBcImhcIiwgXCJ0aFwiXWAgdG8gZ2V0IHRoZSBcInRcIiBhbmQgXCJoXCIgZ2x5cGhzIHBsdXMgdGhlIFwidGhcIiBsaWdhdHVyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgYXQgd2hpY2ggdG8gcHJlcmVuZGVyIHRoZSBTREYgdGV4dHVyZXMgZm9yIHRoZVxuICAgKiAgICAgICAgc3BlY2lmaWVkIGBjaGFyYWN0ZXJzYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgcHJlbG9hZGluZyBpcyBjb21wbGV0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHByZWxvYWRGb250KHtmb250LCBjaGFyYWN0ZXJzLCBzZGZHbHlwaFNpemV9LCBjYWxsYmFjaykge1xuICAgIGxldCB0ZXh0ID0gQXJyYXkuaXNBcnJheShjaGFyYWN0ZXJzKSA/IGNoYXJhY3RlcnMuam9pbignXFxuJykgOiAnJyArIGNoYXJhY3RlcnM7XG4gICAgZ2V0VGV4dFJlbmRlckluZm8oeyBmb250LCBzZGZHbHlwaFNpemUsIHRleHQgfSwgY2FsbGJhY2spO1xuICB9XG5cblxuICAvLyBMb2NhbCBhc3NpZ24gaW1wbCBzbyB3ZSBkb24ndCBoYXZlIHRvIGltcG9ydCB0cm9pa2EtY29yZVxuICBmdW5jdGlvbiBhc3NpZ24odG9PYmosIGZyb21PYmopIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gZnJvbU9iaikge1xuICAgICAgaWYgKGZyb21PYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB0b09ialtrZXldID0gZnJvbU9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9PYmpcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZm9yIG1ha2luZyBVUkxzIGFic29sdXRlXG4gIGxldCBsaW5rRWw7XG4gIGZ1bmN0aW9uIHRvQWJzb2x1dGVVUkwocGF0aCkge1xuICAgIGlmICghbGlua0VsKSB7XG4gICAgICBsaW5rRWwgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8ge30gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgfVxuICAgIGxpbmtFbC5ocmVmID0gcGF0aDtcbiAgICByZXR1cm4gbGlua0VsLmhyZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBTYWZhcmkgPCB2MTUgc2VlbXMgdW5hYmxlIHRvIHVzZSB0aGUgU0RGIHdlYmdsIGNhbnZhcyBhcyBhIHRleHR1cmUuIFRoaXMgYXBwbGllcyBhIHdvcmthcm91bmRcbiAgICogd2hlcmUgaXQgcmVhZHMgdGhlIHBpeGVscyBvdXQgb2YgdGhhdCBjYW52YXMgYW5kIHVwbG9hZHMgdGhlbSBhcyBhIGRhdGEgdGV4dHVyZSBpbnN0ZWFkLCBhdFxuICAgKiBhIHNsaWdodCBwZXJmb3JtYW5jZSBjb3N0LlxuICAgKi9cbiAgZnVuY3Rpb24gc2FmYXJpUHJlMTVXb3JrYXJvdW5kKGF0bGFzKSB7XG4gICAgLy8gVXNlIGNyZWF0ZUltYWdlQml0bWFwIHN1cHBvcnQgYXMgYSBwcm94eSBmb3IgU2FmYXJpPDE1LCBhbGwgb3RoZXIgbWFpbnN0cmVhbSBicm93c2Vyc1xuICAgIC8vIGhhdmUgc3VwcG9ydGVkIGl0IGZvciBhIGxvbmcgd2hpbGUgc28gYW55IGZhbHNlIHBvc2l0aXZlcyBzaG91bGQgYmUgbWluaW1hbC5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmluZm8oJ1NhZmFyaTwxNTogYXBwbHlpbmcgU0RGIGNhbnZhcyB3b3JrYXJvdW5kJyk7XG4gICAgICBjb25zdCB7c2RmQ2FudmFzLCBzZGZUZXh0dXJlfSA9IGF0bGFzO1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2RmQ2FudmFzO1xuICAgICAgY29uc3QgZ2wgPSBhdGxhcy5zZGZDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKTtcbiAgICAgIGxldCBwaXhlbHMgPSBzZGZUZXh0dXJlLmltYWdlLmRhdGE7XG4gICAgICBpZiAoIXBpeGVscyB8fCBwaXhlbHMubGVuZ3RoICE9PSB3aWR0aCAqIGhlaWdodCAqIDQpIHtcbiAgICAgICAgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgc2RmVGV4dHVyZS5pbWFnZSA9IHt3aWR0aCwgaGVpZ2h0LCBkYXRhOiBwaXhlbHN9O1xuICAgICAgICBzZGZUZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgICAgIHNkZlRleHR1cmUuaXNEYXRhVGV4dHVyZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdHlwZXNldHRlcldvcmtlck1vZHVsZSA9IC8qI19fUFVSRV9fKi90cm9pa2FXb3JrZXJVdGlscy5kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgIG5hbWU6ICdUeXBlc2V0dGVyJyxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIGNyZWF0ZVR5cGVzZXR0ZXIsXG4gICAgICBmb250UmVzb2x2ZXJXb3JrZXJNb2R1bGUsXG4gICAgICBiaWRpRmFjdG9yeV9fZGVmYXVsdFsnZGVmYXVsdCddLFxuICAgIF0sXG4gICAgaW5pdChjcmVhdGVUeXBlc2V0dGVyLCBmb250UmVzb2x2ZXIsIGJpZGlGYWN0b3J5KSB7XG4gICAgICByZXR1cm4gY3JlYXRlVHlwZXNldHRlcihmb250UmVzb2x2ZXIsIGJpZGlGYWN0b3J5KCkpXG4gICAgfVxuICB9KTtcblxuICBjb25zdCB0eXBlc2V0SW5Xb3JrZXIgPSAvKiNfX1BVUkVfXyovdHJvaWthV29ya2VyVXRpbHMuZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICBuYW1lOiAnVHlwZXNldHRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICB0eXBlc2V0dGVyV29ya2VyTW9kdWxlLFxuICAgIF0sXG4gICAgaW5pdCh0eXBlc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgdHlwZXNldHRlci50eXBlc2V0KGFyZ3MsIHJlc29sdmUpO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpIHtcbiAgICAgIC8vIE1hcmsgYXJyYXkgYnVmZmVycyBhcyB0cmFuc2ZlcmFibGUgdG8gYXZvaWQgY2xvbmluZyBkdXJpbmcgcG9zdE1lc3NhZ2VcbiAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IHAgaW4gcmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHRbcF0gJiYgcmVzdWx0W3BdLmJ1ZmZlcikge1xuICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChyZXN1bHRbcF0uYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZmVyYWJsZXNcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGR1bXBTREZUZXh0dXJlcygpIHtcbiAgICBPYmplY3Qua2V5cyhhdGxhc2VzKS5mb3JFYWNoKHNpemUgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gYXRsYXNlc1tzaXplXS5zZGZDYW52YXM7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBjYW52YXM7XG4gICAgICBjb25zb2xlLmxvZyhcIiVjLlwiLCBgXG4gICAgICBiYWNrZ3JvdW5kOiB1cmwoJHtjYW52YXMudG9EYXRhVVJMKCl9KTtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogJHt3aWR0aH1weCAke2hlaWdodH1weDtcbiAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAke2hlaWdodH1weDtcbiAgICAgIHBhZGRpbmctbGVmdDogJHt3aWR0aH1weDtcbiAgICBgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHRlbXBsYXRlR2VvbWV0cmllcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldFRlbXBsYXRlR2VvbWV0cnkoZGV0YWlsKSB7XG4gICAgbGV0IGdlb20gPSB0ZW1wbGF0ZUdlb21ldHJpZXNbZGV0YWlsXTtcbiAgICBpZiAoIWdlb20pIHtcbiAgICAgIC8vIEdlb21ldHJ5IGlzIHR3byBwbGFuZXMgYmFjay10by1iYWNrLCB3aGljaCB3aWxsIGFsd2F5cyBiZSByZW5kZXJlZCBGcm9udFNpZGUgb25seSBidXRcbiAgICAgIC8vIGFwcGVhciBhcyBEb3VibGVTaWRlIGJ5IGRlZmF1bHQuIEZyb250U2lkZS9CYWNrU2lkZSBhcmUgZW11bGF0ZWQgdXNpbmcgZHJhd1JhbmdlLlxuICAgICAgLy8gV2UgZG8gaXQgdGhpcyB3YXkgdG8gYXZvaWQgdGhlIHBlcmZvcm1hbmNlIGhpdCBvZiB0d28gZHJhdyBjYWxscyBmb3IgRG91YmxlU2lkZSBtYXRlcmlhbHNcbiAgICAgIC8vIGludHJvZHVjZWQgYnkgVGhyZWUuanMgaW4gcjEzMCAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjE5NjdcbiAgICAgIGNvbnN0IGZyb250ID0gbmV3IHRocmVlLlBsYW5lR2VvbWV0cnkoMSwgMSwgZGV0YWlsLCBkZXRhaWwpO1xuICAgICAgY29uc3QgYmFjayA9IGZyb250LmNsb25lKCk7XG4gICAgICBjb25zdCBmcm9udEF0dHJzID0gZnJvbnQuYXR0cmlidXRlcztcbiAgICAgIGNvbnN0IGJhY2tBdHRycyA9IGJhY2suYXR0cmlidXRlcztcbiAgICAgIGNvbnN0IGNvbWJpbmVkID0gbmV3IHRocmVlLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICBjb25zdCB2ZXJ0Q291bnQgPSBmcm9udEF0dHJzLnV2LmNvdW50O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0Q291bnQ7IGkrKykge1xuICAgICAgICBiYWNrQXR0cnMucG9zaXRpb24uYXJyYXlbaSAqIDNdICo9IC0xOyAvLyBmbGlwIHBvc2l0aW9uIHhcbiAgICAgICAgYmFja0F0dHJzLm5vcm1hbC5hcnJheVtpICogMyArIDJdICo9IC0xOyAvLyBmbGlwIG5vcm1hbCB6XG4gICAgICB9XG4gICAgICBbJ3Bvc2l0aW9uJywgJ25vcm1hbCcsICd1diddLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbWJpbmVkLnNldEF0dHJpYnV0ZShuYW1lLCBuZXcgdGhyZWUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShcbiAgICAgICAgICBbLi4uZnJvbnRBdHRyc1tuYW1lXS5hcnJheSwgLi4uYmFja0F0dHJzW25hbWVdLmFycmF5XSxcbiAgICAgICAgICBmcm9udEF0dHJzW25hbWVdLml0ZW1TaXplKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICBjb21iaW5lZC5zZXRJbmRleChbLi4uZnJvbnQuaW5kZXguYXJyYXksIC4uLmJhY2suaW5kZXguYXJyYXkubWFwKG4gPT4gbiArIHZlcnRDb3VudCldKTtcbiAgICAgIGNvbWJpbmVkLnRyYW5zbGF0ZSgwLjUsIDAuNSwgMCk7XG4gICAgICBnZW9tID0gdGVtcGxhdGVHZW9tZXRyaWVzW2RldGFpbF0gPSBjb21iaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGdlb21cbiAgfVxuXG4gIGNvbnN0IGdseXBoQm91bmRzQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQm91bmRzJztcbiAgY29uc3QgZ2x5cGhJbmRleEF0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaEluZGV4JztcbiAgY29uc3QgZ2x5cGhDb2xvckF0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaENvbG9yJztcblxuICAvKipcbiAgQGNsYXNzIEdseXBoc0dlb21ldHJ5XG5cbiAgQSBzcGVjaWFsaXplZCBHZW9tZXRyeSBmb3IgcmVuZGVyaW5nIGEgc2V0IG9mIHRleHQgZ2x5cGhzLiBVc2VzIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IHRvXG4gIHJlbmRlciB0aGUgZ2x5cGhzIHVzaW5nIEdQVSBpbnN0YW5jaW5nIG9mIGEgc2luZ2xlIHF1YWQsIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHdob2xlXG4gIGdlb21ldHJ5IHdpdGggdmVydGljZXMsIGZvciBtdWNoIHNtYWxsZXIgYXR0cmlidXRlIGFycmF5YnVmZmVycyBhY2NvcmRpbmcgdG8gdGhpcyBtYXRoOlxuXG4gICAgV2hlcmUgTiA9IG51bWJlciBvZiBnbHlwaHMuLi5cblxuICAgIEluc3RhbmNlZDpcbiAgICAtIHBvc2l0aW9uOiA0ICogM1xuICAgIC0gaW5kZXg6IDIgKiAzXG4gICAgLSBub3JtYWw6IDQgKiAzXG4gICAgLSB1djogNCAqIDJcbiAgICAtIGdseXBoIHgveSBib3VuZHM6IE4gKiA0XG4gICAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICAgID0gNU4gKyAzOFxuXG4gICAgTm9uLWluc3RhbmNlZDpcbiAgICAtIHBvc2l0aW9uOiBOICogNCAqIDNcbiAgICAtIGluZGV4OiBOICogMiAqIDNcbiAgICAtIG5vcm1hbDogTiAqIDQgKiAzXG4gICAgLSB1djogTiAqIDQgKiAyXG4gICAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICAgID0gMzlOXG5cbiAgQSBkb3duc2lkZSBvZiB0aGlzIGlzIHRoZSByYXJlLWJ1dC1wb3NzaWJsZSBsYWNrIG9mIHRoZSBpbnN0YW5jZWQgYXJyYXlzIGV4dGVuc2lvbixcbiAgd2hpY2ggd2UgY291bGQgcG90ZW50aWFsbHkgd29yayBhcm91bmQgd2l0aCBhIGZhbGxiYWNrIG5vbi1pbnN0YW5jZWQgaW1wbGVtZW50YXRpb24uXG5cbiAgKi9cbiAgY2xhc3MgR2x5cGhzR2VvbWV0cnkgZXh0ZW5kcyB0aHJlZS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLmRldGFpbCA9IDE7XG4gICAgICB0aGlzLmN1cnZlUmFkaXVzID0gMDtcblxuICAgICAgLy8gRGVmaW5lIGdyb3VwcyBmb3IgcmVuZGVyaW5nIHRleHQgb3V0bGluZSBhcyBhIHNlcGFyYXRlIHBhc3M7IHRoZXNlIHdpbGwgb25seVxuICAgICAgLy8gYmUgdXNlZCB3aGVuIHRoZSBgbWF0ZXJpYWxgIGdldHRlciByZXR1cm5zIGFuIGFycmF5LCBpLmUuIG91dGxpbmVXaWR0aCA+IDAuXG4gICAgICB0aGlzLmdyb3VwcyA9IFtcbiAgICAgICAge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHksIG1hdGVyaWFsSW5kZXg6IDB9LFxuICAgICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMX1cbiAgICAgIF07XG5cbiAgICAgIC8vIFByZWFsbG9jYXRlIGVtcHR5IGJvdW5kaW5nIG9iamVjdHNcbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgdGhyZWUuU3BoZXJlKCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IHRocmVlLkJveDMoKTtcbiAgICB9XG5cbiAgICBjb21wdXRlQm91bmRpbmdTcGhlcmUgKCkge1xuICAgICAgLy8gTm8tb3A7IHdlJ2xsIHN5bmMgdGhlIGJvdW5kaW5nU3BoZXJlIHByb2FjdGl2ZWx5IHdoZW4gbmVlZGVkLlxuICAgIH1cblxuICAgIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICAgIC8vIE5vLW9wOyB3ZSdsbCBzeW5jIHRoZSBib3VuZGluZ0JveCBwcm9hY3RpdmVseSB3aGVuIG5lZWRlZC5cbiAgICB9XG5cbiAgICAvLyBTaW5jZSBvdXIgYmFzZSBnZW9tZXRyeSBjb250YWlucyB0cmlhbmdsZXMgZm9yIGJvdGggZnJvbnQgYW5kIGJhY2sgc2lkZXMsIHdlIGNhbiBlbXVsYXRlXG4gICAgLy8gdGhlIFwic2lkZVwiIGJ5IHJlc3RyaWN0aW5nIHRoZSBkcmF3IHJhbmdlLlxuICAgIHNldFNpZGUoc2lkZSkge1xuICAgICAgY29uc3QgdmVydHMgPSB0aGlzLmdldEluZGV4KCkuY291bnQ7XG4gICAgICB0aGlzLnNldERyYXdSYW5nZShzaWRlID09PSB0aHJlZS5CYWNrU2lkZSA/IHZlcnRzIC8gMiA6IDAsIHNpZGUgPT09IHRocmVlLkRvdWJsZVNpZGUgPyB2ZXJ0cyA6IHZlcnRzIC8gMik7XG4gICAgfVxuXG4gICAgc2V0IGRldGFpbChkZXRhaWwpIHtcbiAgICAgIGlmIChkZXRhaWwgIT09IHRoaXMuX2RldGFpbCkge1xuICAgICAgICB0aGlzLl9kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgIGlmICh0eXBlb2YgZGV0YWlsICE9PSAnbnVtYmVyJyB8fCBkZXRhaWwgPCAxKSB7XG4gICAgICAgICAgZGV0YWlsID0gMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHBsID0gZ2V0VGVtcGxhdGVHZW9tZXRyeShkZXRhaWwpXG4gICAgICAgIDtbJ3Bvc2l0aW9uJywgJ25vcm1hbCcsICd1diddLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdID0gdHBsLmF0dHJpYnV0ZXNbYXR0cl0uY2xvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0SW5kZXgodHBsLmdldEluZGV4KCkuY2xvbmUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldCBkZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGV0YWlsXG4gICAgfVxuXG4gICAgc2V0IGN1cnZlUmFkaXVzKHIpIHtcbiAgICAgIGlmIChyICE9PSB0aGlzLl9jdXJ2ZVJhZGl1cykge1xuICAgICAgICB0aGlzLl9jdXJ2ZVJhZGl1cyA9IHI7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgY3VydmVSYWRpdXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3VydmVSYWRpdXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGdlb21ldHJ5IGZvciBhIG5ldyBzZXQgb2YgZ2x5cGhzLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIHBsYW5hciBib3VuZHMgZm9yIGFsbCBnbHlwaHNcbiAgICAgKiAgICAgICAgdG8gYmUgcmVuZGVyZWQsIDQgZW50cmllcyBmb3IgZWFjaCBnbHlwaDogeDEseDIseTEseTFcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZ2x5cGhBdGxhc0luZGljZXMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBpbmRleCBvZiBlYWNoIGdseXBoIHdpdGhpblxuICAgICAqICAgICAgICB0aGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmxvY2tCb3VuZHMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gYWNyb3NzIGFsbCBnbHlwaHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY2h1bmtlZEJvdW5kc10gLSBBbiBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgYm91bmRzIGZvciBlYWNoIGNodW5rIG9mIE5cbiAgICAgKiAgICAgICAgY29uc2VjdXRpdmUgZ2x5cGhzOiBge3N0YXJ0Ok4sIGVuZDpOLCByZWN0OlttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXX1gLiBUaGlzIGNhbiBiZVxuICAgICAqICAgICAgICB1c2VkIHdpdGggYGFwcGx5Q2xpcFJlY3RgIHRvIGNob29zZSBhbiBvcHRpbWl6ZWQgYGluc3RhbmNlQ291bnRgLlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSAtIEFuIGFycmF5IGhvbGRpbmcgcixnLGIgdmFsdWVzIGZvciBlYWNoIGdseXBoLlxuICAgICAqL1xuICAgIHVwZGF0ZUdseXBocyhnbHlwaEJvdW5kcywgZ2x5cGhBdGxhc0luZGljZXMsIGJsb2NrQm91bmRzLCBjaHVua2VkQm91bmRzLCBnbHlwaENvbG9ycykge1xuICAgICAgLy8gVXBkYXRlIHRoZSBpbnN0YW5jZSBhdHRyaWJ1dGVzXG4gICAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoQm91bmRzQXR0ck5hbWUsIGdseXBoQm91bmRzLCA0KTtcbiAgICAgIHVwZGF0ZUJ1ZmZlckF0dHIodGhpcywgZ2x5cGhJbmRleEF0dHJOYW1lLCBnbHlwaEF0bGFzSW5kaWNlcywgMSk7XG4gICAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoQ29sb3JBdHRyTmFtZSwgZ2x5cGhDb2xvcnMsIDMpO1xuICAgICAgdGhpcy5fYmxvY2tCb3VuZHMgPSBibG9ja0JvdW5kcztcbiAgICAgIHRoaXMuX2NodW5rZWRCb3VuZHMgPSBjaHVua2VkQm91bmRzO1xuICAgICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gZ2x5cGhBdGxhc0luZGljZXMubGVuZ3RoO1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZUJvdW5kcygpIHtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2Jsb2NrQm91bmRzO1xuICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICBjb25zdCB7IGN1cnZlUmFkaXVzLCBib3VuZGluZ0JveDogYmJveCB9ID0gdGhpcztcbiAgICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgICAgY29uc3QgeyBQSSwgZmxvb3IsIG1pbiwgbWF4LCBzaW4sIGNvcyB9ID0gTWF0aDtcbiAgICAgICAgICBjb25zdCBoYWxmUGkgPSBQSSAvIDI7XG4gICAgICAgICAgY29uc3QgdHdvUGkgPSBQSSAqIDI7XG4gICAgICAgICAgY29uc3QgYWJzUiA9IE1hdGguYWJzKGN1cnZlUmFkaXVzKTtcbiAgICAgICAgICBjb25zdCBsZWZ0QW5nbGUgPSBib3VuZHNbMF0gLyBhYnNSO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0QW5nbGUgPSBib3VuZHNbMl0gLyBhYnNSO1xuICAgICAgICAgIGNvbnN0IG1pblggPSBmbG9vcigobGVmdEFuZ2xlICsgaGFsZlBpKSAvIHR3b1BpKSAhPT0gZmxvb3IoKHJpZ2h0QW5nbGUgKyBoYWxmUGkpIC8gdHdvUGkpXG4gICAgICAgICAgICA/IC1hYnNSIDogbWluKHNpbihsZWZ0QW5nbGUpICogYWJzUiwgc2luKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgICAgY29uc3QgbWF4WCA9IGZsb29yKChsZWZ0QW5nbGUgLSBoYWxmUGkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSAtIGhhbGZQaSkgLyB0d29QaSlcbiAgICAgICAgICAgID8gYWJzUiA6IG1heChzaW4obGVmdEFuZ2xlKSAqIGFic1IsIHNpbihyaWdodEFuZ2xlKSAqIGFic1IpO1xuICAgICAgICAgIGNvbnN0IG1heFogPSBmbG9vcigobGVmdEFuZ2xlICsgUEkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSArIFBJKSAvIHR3b1BpKVxuICAgICAgICAgICAgPyBhYnNSICogMiA6IG1heChhYnNSIC0gY29zKGxlZnRBbmdsZSkgKiBhYnNSLCBhYnNSIC0gY29zKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgICAgYmJveC5taW4uc2V0KG1pblgsIGJvdW5kc1sxXSwgY3VydmVSYWRpdXMgPCAwID8gLW1heFogOiAwKTtcbiAgICAgICAgICBiYm94Lm1heC5zZXQobWF4WCwgYm91bmRzWzNdLCBjdXJ2ZVJhZGl1cyA8IDAgPyAwIDogbWF4Wik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmJveC5taW4uc2V0KGJvdW5kc1swXSwgYm91bmRzWzFdLCAwKTtcbiAgICAgICAgICBiYm94Lm1heC5zZXQoYm91bmRzWzJdLCBib3VuZHNbM10sIDApO1xuICAgICAgICB9XG4gICAgICAgIGJib3guZ2V0Qm91bmRpbmdTcGhlcmUodGhpcy5ib3VuZGluZ1NwaGVyZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjbGlwcGluZyByZWN0LCBhbmQgdGhlIGNodW5rZWRCb3VuZHMgZnJvbSB0aGUgbGFzdCB1cGRhdGVHbHlwaHMgY2FsbCwgY2hvb3NlIHRoZSBsb3dlc3RcbiAgICAgKiBgaW5zdGFuY2VDb3VudGAgdGhhdCB3aWxsIHNob3cgYWxsIGdseXBocyB3aXRoaW4gdGhlIGNsaXBwZWQgdmlldy4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb25cbiAgICAgKiBmb3IgbG9uZyBibG9ja3Mgb2YgdGV4dCB0aGF0IGFyZSBjbGlwcGVkLCB0byBza2lwIHZlcnRleCBzaGFkZXIgZXZhbHVhdGlvbiBmb3IgZ2x5cGhzIHRoYXQgd291bGRcbiAgICAgKiBiZSBjbGlwcGVkIGFueXdheS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBzaW5jZSBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkW0FOR0xFXWAgb25seSBhY2NlcHRzIGFuIGluc3RhbmNlIGNvdW50IGFuZCBub3QgYSBzdGFydGluZ1xuICAgICAqIG9mZnNldCwgdGhpcyBvcHRpbWl6YXRpb24gYmVjb21lcyBsZXNzIGVmZmVjdGl2ZSBhcyB0aGUgY2xpcFJlY3QgbW92ZXMgY2xvc2VyIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgICogdGV4dCBibG9jay4gV2UgY291bGQgZml4IHRoYXQgYnkgc3dpdGNoaW5nIGZyb20gaW5zdGFuY2luZyB0byBhIGZ1bGwgZ2VvbWV0cnkgd2l0aCBhIGRyYXdSYW5nZSxcbiAgICAgKiBidXQgYXQgdGhlIGV4cGVuc2Ugb2YgbXVjaCBsYXJnZXIgYXR0cmlidXRlIGJ1ZmZlcnMgKHNlZSBjbGFzc2RvYyBhYm92ZS4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1ZlY3RvcjR9IGNsaXBSZWN0XG4gICAgICovXG4gICAgYXBwbHlDbGlwUmVjdChjbGlwUmVjdCkge1xuICAgICAgbGV0IGNvdW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoZ2x5cGhJbmRleEF0dHJOYW1lKS5jb3VudDtcbiAgICAgIGxldCBjaHVua3MgPSB0aGlzLl9jaHVua2VkQm91bmRzO1xuICAgICAgaWYgKGNodW5rcykge1xuICAgICAgICBmb3IgKGxldCBpID0gY2h1bmtzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGNvdW50ID0gY2h1bmtzW2ldLmVuZDtcbiAgICAgICAgICBsZXQgcmVjdCA9IGNodW5rc1tpXS5yZWN0O1xuICAgICAgICAgIC8vIG5vdGU6IGJvdGggcmVjdHMgYXJlIGwtYi1yLXRcbiAgICAgICAgICBpZiAocmVjdFsxXSA8IGNsaXBSZWN0LncgJiYgcmVjdFszXSA+IGNsaXBSZWN0LnkgJiYgcmVjdFswXSA8IGNsaXBSZWN0LnogJiYgcmVjdFsyXSA+IGNsaXBSZWN0LngpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBjb3VudDtcbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlckF0dHIoZ2VvbSwgYXR0ck5hbWUsIG5ld0FycmF5LCBpdGVtU2l6ZSkge1xuICAgIGNvbnN0IGF0dHIgPSBnZW9tLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgaWYgKG5ld0FycmF5KSB7XG4gICAgICAvLyBJZiBsZW5ndGggaXNuJ3QgY2hhbmdpbmcsIGp1c3QgdXBkYXRlIHRoZSBhdHRyaWJ1dGUncyBhcnJheSBkYXRhXG4gICAgICBpZiAoYXR0ciAmJiBhdHRyLmFycmF5Lmxlbmd0aCA9PT0gbmV3QXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGF0dHIuYXJyYXkuc2V0KG5ld0FycmF5KTtcbiAgICAgICAgYXR0ci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgbmV3IHRocmVlLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShuZXdBcnJheSwgaXRlbVNpemUpKTtcbiAgICAgICAgLy8gSWYgdGhlIG5ldyBhdHRyaWJ1dGUgaGFzIGEgZGlmZmVyZW50IHNpemUsIHdlIGFsc28gaGF2ZSB0byAoYXMgb2YgcjExNykgbWFudWFsbHkgY2xlYXIgdGhlXG4gICAgICAgIC8vIGludGVybmFsIGNhY2hlZCBtYXggaW5zdGFuY2UgY291bnQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xOTcwNlxuICAgICAgICAvLyBJdCdzIHVuY2xlYXIgaWYgdGhpcyBpcyBhIHRocmVlanMgYnVnIG9yIGEgdHJ1bHkgdW5zdXBwb3J0ZWQgc2NlbmFyaW87IGRpc2N1c3Npb24gaW5cbiAgICAgICAgLy8gdGhhdCB0aWNrZXQgaXMgYW1iaWd1b3VzIGFzIHRvIHdoZXRoZXIgcmVwbGFjaW5nIGEgQnVmZmVyQXR0cmlidXRlIHdpdGggb25lIG9mIGFcbiAgICAgICAgLy8gZGlmZmVyZW50IHNpemUgaXMgc3VwcG9ydGVkLCBidXQgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzE3NDE4IHN0cm9uZ2x5XG4gICAgICAgIC8vIGltcGxpZXMgaXQgc2hvdWxkIGJlIHN1cHBvcnRlZC4gSXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvXG4gICAgICAgIGRlbGV0ZSBnZW9tLl9tYXhJbnN0YW5jZUNvdW50OyAvL2ZvciByMTE3KywgY291bGQgYmUgZnJhZ2lsZVxuICAgICAgICBnZW9tLmRpc3Bvc2UoKTsgLy9mb3IgcjExOCssIG1vcmUgcm9idXN0IGZlZWxpbmcsIGJ1dCBtb3JlIGhlYXZ5LWhhbmRlZCB0aGFuIEknZCBsaWtlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyKSB7XG4gICAgICBnZW9tLmRlbGV0ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gbGFuZ3VhZ2U9R0xTTFxuICBjb25zdCBWRVJURVhfREVGUyA9IGBcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIHZlYzQgdVRyb2lrYVRvdGFsQm91bmRzO1xudW5pZm9ybSB2ZWM0IHVUcm9pa2FDbGlwUmVjdDtcbnVuaWZvcm0gbWF0MyB1VHJvaWthT3JpZW50O1xudW5pZm9ybSBib29sIHVUcm9pa2FVc2VHbHlwaENvbG9ycztcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYURpc3RhbmNlT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthQmx1clJhZGl1cztcbnVuaWZvcm0gdmVjMiB1VHJvaWthUG9zaXRpb25PZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FDdXJ2ZVJhZGl1cztcbmF0dHJpYnV0ZSB2ZWM0IGFUcm9pa2FHbHlwaEJvdW5kcztcbmF0dHJpYnV0ZSBmbG9hdCBhVHJvaWthR2x5cGhJbmRleDtcbmF0dHJpYnV0ZSB2ZWMzIGFUcm9pa2FHbHlwaENvbG9yO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaFVWO1xudmFyeWluZyB2ZWM0IHZUcm9pa2FUZXh0dXJlVVZCb3VuZHM7XG52YXJ5aW5nIGZsb2F0IHZUcm9pa2FUZXh0dXJlQ2hhbm5lbDtcbnZhcnlpbmcgdmVjMyB2VHJvaWthR2x5cGhDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhEaW1lbnNpb25zO1xuYDtcblxuICAvLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbiAgY29uc3QgVkVSVEVYX1RSQU5TRk9STSA9IGBcbnZlYzQgYm91bmRzID0gYVRyb2lrYUdseXBoQm91bmRzO1xuYm91bmRzLnh6ICs9IHVUcm9pa2FQb3NpdGlvbk9mZnNldC54O1xuYm91bmRzLnl3IC09IHVUcm9pa2FQb3NpdGlvbk9mZnNldC55O1xuXG52ZWM0IG91dGxpbmVCb3VuZHMgPSB2ZWM0KFxuICBib3VuZHMueHkgLSB1VHJvaWthRGlzdGFuY2VPZmZzZXQgLSB1VHJvaWthQmx1clJhZGl1cyxcbiAgYm91bmRzLnp3ICsgdVRyb2lrYURpc3RhbmNlT2Zmc2V0ICsgdVRyb2lrYUJsdXJSYWRpdXNcbik7XG52ZWM0IGNsaXBwZWRCb3VuZHMgPSB2ZWM0KFxuICBjbGFtcChvdXRsaW5lQm91bmRzLnh5LCB1VHJvaWthQ2xpcFJlY3QueHksIHVUcm9pa2FDbGlwUmVjdC56dyksXG4gIGNsYW1wKG91dGxpbmVCb3VuZHMuencsIHVUcm9pa2FDbGlwUmVjdC54eSwgdVRyb2lrYUNsaXBSZWN0Lnp3KVxuKTtcblxudmVjMiBjbGlwcGVkWFkgPSAobWl4KGNsaXBwZWRCb3VuZHMueHksIGNsaXBwZWRCb3VuZHMuencsIHBvc2l0aW9uLnh5KSAtIGJvdW5kcy54eSkgLyAoYm91bmRzLnp3IC0gYm91bmRzLnh5KTtcblxucG9zaXRpb24ueHkgPSBtaXgoYm91bmRzLnh5LCBib3VuZHMuencsIGNsaXBwZWRYWSk7XG5cbnV2ID0gKHBvc2l0aW9uLnh5IC0gdVRyb2lrYVRvdGFsQm91bmRzLnh5KSAvICh1VHJvaWthVG90YWxCb3VuZHMuencgLSB1VHJvaWthVG90YWxCb3VuZHMueHkpO1xuXG5mbG9hdCByYWQgPSB1VHJvaWthQ3VydmVSYWRpdXM7XG5pZiAocmFkICE9IDAuMCkge1xuICBmbG9hdCBhbmdsZSA9IHBvc2l0aW9uLnggLyByYWQ7XG4gIHBvc2l0aW9uLnh6ID0gdmVjMihzaW4oYW5nbGUpICogcmFkLCByYWQgLSBjb3MoYW5nbGUpICogcmFkKTtcbiAgbm9ybWFsLnh6ID0gdmVjMihzaW4oYW5nbGUpLCBjb3MoYW5nbGUpKTtcbn1cbiAgXG5wb3NpdGlvbiA9IHVUcm9pa2FPcmllbnQgKiBwb3NpdGlvbjtcbm5vcm1hbCA9IHVUcm9pa2FPcmllbnQgKiBub3JtYWw7XG5cbnZUcm9pa2FHbHlwaFVWID0gY2xpcHBlZFhZLnh5O1xudlRyb2lrYUdseXBoRGltZW5zaW9ucyA9IHZlYzIoYm91bmRzWzJdIC0gYm91bmRzWzBdLCBib3VuZHNbM10gLSBib3VuZHNbMV0pO1xuXG4keycnLyogTk9URTogaXQgc2VlbXMgaW1wb3J0YW50IHRvIGNhbGN1bGF0ZSB0aGUgZ2x5cGgncyBib3VuZGluZyB0ZXh0dXJlIFVWcyBoZXJlIGluIHRoZVxuICB2ZXJ0ZXggc2hhZGVyLCByYXRoZXIgdGhhbiBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLCBhcyB0aGUgbGF0dGVyIGdpdmVzIHN0cmFuZ2UgYXJ0aWZhY3RzXG4gIG9uIHNvbWUgZ2x5cGhzICh0aG9zZSBpbiB0aGUgbGVmdG1vc3QgdGV4dHVyZSBjb2x1bW4pIG9uIHNvbWUgc3lzdGVtcy4gVGhlIGV4YWN0IHJlYXNvblxuICBpc24ndCB1bmRlcnN0b29kIGJ1dCBkb2luZyB0aGlzIGhlcmUsIHRoZW4gbWl4KCktaW5nIGluIHRoZSBmcmFnbWVudCBzaGFkZXIsIHNlZW1zIHRvIHdvcmsuICovfVxuZmxvYXQgdHhDb2xzID0gdVRyb2lrYVNERlRleHR1cmVTaXplLnggLyB1VHJvaWthU0RGR2x5cGhTaXplO1xudmVjMiB0eFV2UGVyU3F1YXJlID0gdVRyb2lrYVNERkdseXBoU2l6ZSAvIHVUcm9pa2FTREZUZXh0dXJlU2l6ZTtcbnZlYzIgdHhTdGFydFVWID0gdHhVdlBlclNxdWFyZSAqIHZlYzIoXG4gIG1vZChmbG9vcihhVHJvaWthR2x5cGhJbmRleCAvIDQuMCksIHR4Q29scyksXG4gIGZsb29yKGZsb29yKGFUcm9pa2FHbHlwaEluZGV4IC8gNC4wKSAvIHR4Q29scylcbik7XG52VHJvaWthVGV4dHVyZVVWQm91bmRzID0gdmVjNCh0eFN0YXJ0VVYsIHZlYzIodHhTdGFydFVWKSArIHR4VXZQZXJTcXVhcmUpO1xudlRyb2lrYVRleHR1cmVDaGFubmVsID0gbW9kKGFUcm9pa2FHbHlwaEluZGV4LCA0LjApO1xuYDtcblxuICAvLyBsYW5ndWFnZT1HTFNMXG4gIGNvbnN0IEZSQUdNRU5UX0RFRlMgPSBgXG51bmlmb3JtIHNhbXBsZXIyRCB1VHJvaWthU0RGVGV4dHVyZTtcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZFeHBvbmVudDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYURpc3RhbmNlT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthRmlsbE9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FPdXRsaW5lT3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUJsdXJSYWRpdXM7XG51bmlmb3JtIHZlYzMgdVRyb2lrYVN0cm9rZUNvbG9yO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTdHJva2VPcGFjaXR5O1xudW5pZm9ybSBib29sIHVUcm9pa2FTREZEZWJ1ZztcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhVVjtcbnZhcnlpbmcgdmVjNCB2VHJvaWthVGV4dHVyZVVWQm91bmRzO1xudmFyeWluZyBmbG9hdCB2VHJvaWthVGV4dHVyZUNoYW5uZWw7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoRGltZW5zaW9ucztcblxuZmxvYXQgdHJvaWthU2RmVmFsdWVUb1NpZ25lZERpc3RhbmNlKGZsb2F0IGFscGhhKSB7XG4gIC8vIEludmVyc2Ugb2YgZXhwb25lbnRpYWwgZW5jb2RpbmcgaW4gd2ViZ2wtc2RmLWdlbmVyYXRvclxuICAkeycnLyogVE9ETyAtIHRoZXJlJ3Mgc29tZSBzbGlnaHQgaW5hY2N1cmFjeSBoZXJlIHdoZW4gZGVhbGluZyB3aXRoIGludGVycG9sYXRlZCBhbHBoYSB2YWx1ZXM7IHRob3NlXG4gICAgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZCB3aGVyZSB0aGUgZW5jb2RpbmcgaXMgZXhwb25lbnRpYWwuIExvb2sgaW50byBpbXByb3ZpbmcgdGhpcyBieSByb3VuZGluZ1xuICAgIHRvIG5lYXJlc3QgMiB3aG9sZSB0ZXhlbHMsIGRlY29kaW5nIHRob3NlIGV4cG9uZW50aWFsIHZhbHVlcywgYW5kIGxpbmVhcmx5IGludGVycG9sYXRpbmcgdGhlIHJlc3VsdC5cbiAgKi99XG4gIGZsb2F0IG1heERpbWVuc2lvbiA9IG1heCh2VHJvaWthR2x5cGhEaW1lbnNpb25zLngsIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueSk7XG4gIGZsb2F0IGFic0Rpc3QgPSAoMS4wIC0gcG93KDIuMCAqIChhbHBoYSA+IDAuNSA/IDEuMCAtIGFscGhhIDogYWxwaGEpLCAxLjAgLyB1VHJvaWthU0RGRXhwb25lbnQpKSAqIG1heERpbWVuc2lvbjtcbiAgZmxvYXQgc2lnbmVkRGlzdCA9IGFic0Rpc3QgKiAoYWxwaGEgPiAwLjUgPyAtMS4wIDogMS4wKTtcbiAgcmV0dXJuIHNpZ25lZERpc3Q7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZlYzIgZ2x5cGhVVikge1xuICB2ZWMyIHRleHR1cmVVViA9IG1peCh2VHJvaWthVGV4dHVyZVVWQm91bmRzLnh5LCB2VHJvaWthVGV4dHVyZVVWQm91bmRzLnp3LCBnbHlwaFVWKTtcbiAgdmVjNCByZ2JhID0gdGV4dHVyZTJEKHVUcm9pa2FTREZUZXh0dXJlLCB0ZXh0dXJlVVYpO1xuICBmbG9hdCBjaCA9IGZsb29yKHZUcm9pa2FUZXh0dXJlQ2hhbm5lbCArIDAuNSk7IC8vTk9URTogY2FuJ3QgdXNlIHJvdW5kKCkgaW4gV2ViR0wxXG4gIHJldHVybiBjaCA9PSAwLjAgPyByZ2JhLnIgOiBjaCA9PSAxLjAgPyByZ2JhLmcgOiBjaCA9PSAyLjAgPyByZ2JhLmIgOiByZ2JhLmE7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKHZlYzIgdXYpIHtcbiAgcmV0dXJuIHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZSh0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh1dikpO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRBQURpc3QoKSB7XG4gICR7JycvKlxuICAgIFdoZW4gdGhlIHN0YW5kYXJkIGRlcml2YXRpdmVzIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUsIHdlIGNob29zZSBhbiBhbnRpYWxpYXNpbmcgYWxwaGEgdGhyZXNob2xkIGJhc2VkXG4gICAgb24gdGhlIHBvdGVudGlhbCBjaGFuZ2UgaW4gdGhlIFNERidzIGFscGhhIGZyb20gdGhpcyBmcmFnbWVudCB0byBpdHMgbmVpZ2hib3IuIFRoaXMgc3RyYXRlZ3kgbWF4aW1pemVzIFxuICAgIHJlYWRhYmlsaXR5IGFuZCBlZGdlIGNyaXNwbmVzcyBhdCBhbGwgc2l6ZXMgYW5kIHNjcmVlbiByZXNvbHV0aW9ucy5cbiAgKi99XG4gICNpZiBkZWZpbmVkKEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcykgfHwgX19WRVJTSU9OX18gPj0gMzAwXG4gIHJldHVybiBsZW5ndGgoZndpZHRoKHZUcm9pa2FHbHlwaFVWICogdlRyb2lrYUdseXBoRGltZW5zaW9ucykpICogMC41O1xuICAjZWxzZVxuICByZXR1cm4gdlRyb2lrYUdseXBoRGltZW5zaW9ucy54IC8gNjQuMDtcbiAgI2VuZGlmXG59XG5cbmZsb2F0IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKSB7XG4gIHZlYzIgY2xhbXBlZEdseXBoVVYgPSBjbGFtcCh2VHJvaWthR2x5cGhVViwgMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSwgMS4wIC0gMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSk7XG4gIGZsb2F0IGRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UoY2xhbXBlZEdseXBoVVYpO1xuIFxuICAvLyBFeHRyYXBvbGF0ZSBkaXN0YW5jZSB3aGVuIG91dHNpZGUgYm91bmRzOlxuICBkaXN0YW5jZSArPSBjbGFtcGVkR2x5cGhVViA9PSB2VHJvaWthR2x5cGhVViA/IDAuMCA6IFxuICAgIGxlbmd0aCgodlRyb2lrYUdseXBoVVYgLSBjbGFtcGVkR2x5cGhVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcblxuICAkeycnLyogXG4gIC8vIFRPRE8gbW9yZSByZWZpbmVkIGV4dHJhcG9sYXRlZCBkaXN0YW5jZSBieSBhZGp1c3RpbmcgZm9yIGFuZ2xlIG9mIGdyYWRpZW50IGF0IGVkZ2UuLi5cbiAgLy8gVGhpcyBoYXMgcG90ZW50aWFsIGJ1dCBjdXJyZW50bHkgZ2l2ZXMgdmVyeSBqYWdnZWQgZXh0ZW5zaW9ucywgbWF5YmUgZHVlIHRvIHByZWNpc2lvbiBpc3N1ZXM/XG4gIGZsb2F0IHV2U3RlcCA9IDEuMCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XG4gIHZlYzIgbmVpZ2hib3IxVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi55KSkgOlxuICAgIHZUcm9pa2FHbHlwaFVWLnkgIT0gY2xhbXBlZEdseXBoVVYueSA/IHZlYzIodXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIHZlYzIgbmVpZ2hib3IyVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogLXNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLngpLCAwLjApIDpcbiAgICB2ZWMyKDAuMClcbiAgKTtcbiAgZmxvYXQgbmVpZ2hib3IxRGlzdGFuY2UgPSB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZShuZWlnaGJvcjFVVik7XG4gIGZsb2F0IG5laWdoYm9yMkRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IyVVYpO1xuICBmbG9hdCBkaXN0VG9VbmNsYW1wZWQgPSBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG4gIGZsb2F0IGRpc3RUb05laWdoYm9yID0gbGVuZ3RoKChjbGFtcGVkR2x5cGhVViAtIG5laWdoYm9yMVVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMSA9IG1pbihhc2luKGFicyhuZWlnaGJvcjFEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMiA9IG1pbihhc2luKGFicyhuZWlnaGJvcjJEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBkaXN0YW5jZSArPSAoY29zKGdyYWRpZW50QW5nbGUxKSArIGNvcyhncmFkaWVudEFuZ2xlMikpIC8gMi4wICogZGlzdFRvVW5jbGFtcGVkO1xuICAqL31cblxuICByZXR1cm4gZGlzdGFuY2U7XG59XG5cbmZsb2F0IHRyb2lrYUdldEVkZ2VBbHBoYShmbG9hdCBkaXN0YW5jZSwgZmxvYXQgZGlzdGFuY2VPZmZzZXQsIGZsb2F0IGFhRGlzdCkge1xuICAjaWYgZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgfHwgZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbiAgZmxvYXQgYWxwaGEgPSBzdGVwKC1kaXN0YW5jZU9mZnNldCwgLWRpc3RhbmNlKTtcbiAgI2Vsc2VcblxuICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoXG4gICAgZGlzdGFuY2VPZmZzZXQgKyBhYURpc3QsXG4gICAgZGlzdGFuY2VPZmZzZXQgLSBhYURpc3QsXG4gICAgZGlzdGFuY2VcbiAgKTtcbiAgI2VuZGlmXG5cbiAgcmV0dXJuIGFscGhhO1xufVxuYDtcblxuICAvLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbiAgY29uc3QgRlJBR01FTlRfVFJBTlNGT1JNID0gYFxuZmxvYXQgYWFEaXN0ID0gdHJvaWthR2V0QUFEaXN0KCk7XG5mbG9hdCBmcmFnRGlzdGFuY2UgPSB0cm9pa2FHZXRGcmFnRGlzdFZhbHVlKCk7XG5mbG9hdCBlZGdlQWxwaGEgPSB1VHJvaWthU0RGRGVidWcgP1xuICB0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh2VHJvaWthR2x5cGhVVikgOlxuICB0cm9pa2FHZXRFZGdlQWxwaGEoZnJhZ0Rpc3RhbmNlLCB1VHJvaWthRGlzdGFuY2VPZmZzZXQsIG1heChhYURpc3QsIHVUcm9pa2FCbHVyUmFkaXVzKSk7XG5cbiNpZiAhZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgJiYgIWRlZmluZWQoSVNfRElTVEFOQ0VfTUFURVJJQUwpXG52ZWM0IGZpbGxSR0JBID0gZ2xfRnJhZ0NvbG9yO1xuZmlsbFJHQkEuYSAqPSB1VHJvaWthRmlsbE9wYWNpdHk7XG52ZWM0IHN0cm9rZVJHQkEgPSB1VHJvaWthU3Ryb2tlV2lkdGggPT0gMC4wID8gZmlsbFJHQkEgOiB2ZWM0KHVUcm9pa2FTdHJva2VDb2xvciwgdVRyb2lrYVN0cm9rZU9wYWNpdHkpO1xuaWYgKGZpbGxSR0JBLmEgPT0gMC4wKSBmaWxsUkdCQS5yZ2IgPSBzdHJva2VSR0JBLnJnYjtcbmdsX0ZyYWdDb2xvciA9IG1peChmaWxsUkdCQSwgc3Ryb2tlUkdCQSwgc21vb3Roc3RlcChcbiAgLXVUcm9pa2FTdHJva2VXaWR0aCAtIGFhRGlzdCxcbiAgLXVUcm9pa2FTdHJva2VXaWR0aCArIGFhRGlzdCxcbiAgZnJhZ0Rpc3RhbmNlXG4pKTtcbmdsX0ZyYWdDb2xvci5hICo9IGVkZ2VBbHBoYTtcbiNlbmRpZlxuXG5pZiAoZWRnZUFscGhhID09IDAuMCkge1xuICBkaXNjYXJkO1xufVxuYDtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtYXRlcmlhbCBmb3IgcmVuZGVyaW5nIHRleHQsIGRlcml2ZWQgZnJvbSBhIGJhc2VNYXRlcmlhbFxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICBjb25zdCB0ZXh0TWF0ZXJpYWwgPSB0cm9pa2FUaHJlZVV0aWxzLmNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIHtcbiAgICAgIGNoYWluZWQ6IHRydWUsXG4gICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgIGRlcml2YXRpdmVzOiB0cnVlXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdVRyb2lrYVNERlRleHR1cmU6IHt2YWx1ZTogbnVsbH0sXG4gICAgICAgIHVUcm9pa2FTREZUZXh0dXJlU2l6ZToge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMigpfSxcbiAgICAgICAgdVRyb2lrYVNERkdseXBoU2l6ZToge3ZhbHVlOiAwfSxcbiAgICAgICAgdVRyb2lrYVNERkV4cG9uZW50OiB7dmFsdWU6IDB9LFxuICAgICAgICB1VHJvaWthVG90YWxCb3VuZHM6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjQoMCwwLDAsMCl9LFxuICAgICAgICB1VHJvaWthQ2xpcFJlY3Q6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjQoMCwwLDAsMCl9LFxuICAgICAgICB1VHJvaWthRGlzdGFuY2VPZmZzZXQ6IHt2YWx1ZTogMH0sXG4gICAgICAgIHVUcm9pa2FPdXRsaW5lT3BhY2l0eToge3ZhbHVlOiAwfSxcbiAgICAgICAgdVRyb2lrYUZpbGxPcGFjaXR5OiB7dmFsdWU6IDF9LFxuICAgICAgICB1VHJvaWthUG9zaXRpb25PZmZzZXQ6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjIoKX0sXG4gICAgICAgIHVUcm9pa2FDdXJ2ZVJhZGl1czoge3ZhbHVlOiAwfSxcbiAgICAgICAgdVRyb2lrYUJsdXJSYWRpdXM6IHt2YWx1ZTogMH0sXG4gICAgICAgIHVUcm9pa2FTdHJva2VXaWR0aDoge3ZhbHVlOiAwfSxcbiAgICAgICAgdVRyb2lrYVN0cm9rZUNvbG9yOiB7dmFsdWU6IG5ldyB0aHJlZS5Db2xvcigpfSxcbiAgICAgICAgdVRyb2lrYVN0cm9rZU9wYWNpdHk6IHt2YWx1ZTogMX0sXG4gICAgICAgIHVUcm9pa2FPcmllbnQ6IHt2YWx1ZTogbmV3IHRocmVlLk1hdHJpeDMoKX0sXG4gICAgICAgIHVUcm9pa2FVc2VHbHlwaENvbG9yczoge3ZhbHVlOiB0cnVlfSxcbiAgICAgICAgdVRyb2lrYVNERkRlYnVnOiB7dmFsdWU6IGZhbHNlfVxuICAgICAgfSxcbiAgICAgIHZlcnRleERlZnM6IFZFUlRFWF9ERUZTLFxuICAgICAgdmVydGV4VHJhbnNmb3JtOiBWRVJURVhfVFJBTlNGT1JNLFxuICAgICAgZnJhZ21lbnREZWZzOiBGUkFHTUVOVF9ERUZTLFxuICAgICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybTogRlJBR01FTlRfVFJBTlNGT1JNLFxuICAgICAgY3VzdG9tUmV3cml0ZXIoe3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9KSB7XG4gICAgICAgIGxldCB1RGlmZnVzZVJFID0gL1xcYnVuaWZvcm1cXHMrdmVjM1xccytkaWZmdXNlXFxiLztcbiAgICAgICAgaWYgKHVEaWZmdXNlUkUudGVzdChmcmFnbWVudFNoYWRlcikpIHtcbiAgICAgICAgICAvLyBSZXBsYWNlIGFsbCBpbnN0YW5jZXMgb2YgYGRpZmZ1c2VgIHdpdGggb3VyIHZhcnlpbmdcbiAgICAgICAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyXG4gICAgICAgICAgICAucmVwbGFjZSh1RGlmZnVzZVJFLCAndmFyeWluZyB2ZWMzIHZUcm9pa2FHbHlwaENvbG9yJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXGJkaWZmdXNlXFxiL2csICd2VHJvaWthR2x5cGhDb2xvcicpO1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmVydGV4IHNoYWRlciBkZWNsYXJlcyB0aGUgdW5pZm9ybSBzbyB3ZSBjYW4gZ3JhYiBpdCBhcyBhIGZhbGxiYWNrXG4gICAgICAgICAgaWYgKCF1RGlmZnVzZVJFLnRlc3QodmVydGV4U2hhZGVyKSkge1xuICAgICAgICAgICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UoXG4gICAgICAgICAgICAgIHRyb2lrYVRocmVlVXRpbHMudm9pZE1haW5SZWdFeHAsXG4gICAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG4kJlxcbnZUcm9pa2FHbHlwaENvbG9yID0gdVRyb2lrYVVzZUdseXBoQ29sb3JzID8gYVRyb2lrYUdseXBoQ29sb3IgLyAyNTUuMCA6IGRpZmZ1c2U7XFxuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBGb3JjZSB0cmFuc3BhcmVuY3kgLSBUT0RPIGlzIHRoaXMgcmVhc29uYWJsZT9cbiAgICB0ZXh0TWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGV4dE1hdGVyaWFsLCB7XG4gICAgICBpc1Ryb2lrYVRleHRNYXRlcmlhbDoge3ZhbHVlOiB0cnVlfSxcblxuICAgICAgLy8gV2ViR0xTaGFkb3dNYXAgcmV2ZXJzZXMgdGhlIHNpZGUgb2YgdGhlIHNoYWRvdyBtYXRlcmlhbCBieSBkZWZhdWx0LCB3aGljaCBmYWlsc1xuICAgICAgLy8gZm9yIHBsYW5lcywgc28gaGVyZSB3ZSBmb3JjZSB0aGUgYHNoYWRvd1NpZGVgIHRvIGFsd2F5cyBtYXRjaCB0aGUgbWFpbiBzaWRlLlxuICAgICAgc2hhZG93U2lkZToge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2lkZVxuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgLy9uby1vcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGV4dE1hdGVyaWFsXG4gIH1cblxuICBjb25zdCBkZWZhdWx0TWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovIG5ldyB0aHJlZS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgIHNpZGU6IHRocmVlLkRvdWJsZVNpZGUsXG4gICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAgfSk7XG4gIGNvbnN0IGRlZmF1bHRTdHJva2VDb2xvciA9IDB4ODA4MDgwO1xuXG4gIGNvbnN0IHRlbXBNYXQ0ID0gLyojX19QVVJFX18qLyBuZXcgdGhyZWUuTWF0cml4NCgpO1xuICBjb25zdCB0ZW1wVmVjM2EgPSAvKiNfX1BVUkVfXyovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBWZWMzYiA9IC8qI19fUFVSRV9fKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcEFycmF5ID0gW107XG4gIGNvbnN0IG9yaWdpbiA9IC8qI19fUFVSRV9fKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgY29uc3QgZGVmYXVsdE9yaWVudCA9ICcreCt5JztcblxuICBmdW5jdGlvbiBmaXJzdChvKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobykgPyBvWzBdIDogb1xuICB9XG5cbiAgbGV0IGdldEZsYXRSYXljYXN0TWVzaCA9ICgpID0+IHtcbiAgICBjb25zdCBtZXNoID0gbmV3IHRocmVlLk1lc2goXG4gICAgICBuZXcgdGhyZWUuUGxhbmVHZW9tZXRyeSgxLCAxKSxcbiAgICAgIGRlZmF1bHRNYXRlcmlhbFxuICAgICk7XG4gICAgZ2V0RmxhdFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgICByZXR1cm4gbWVzaFxuICB9O1xuICBsZXQgZ2V0Q3VydmVkUmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gICAgY29uc3QgbWVzaCA9IG5ldyB0aHJlZS5NZXNoKFxuICAgICAgbmV3IHRocmVlLlBsYW5lR2VvbWV0cnkoMSwgMSwgMzIsIDEpLFxuICAgICAgZGVmYXVsdE1hdGVyaWFsXG4gICAgKTtcbiAgICBnZXRDdXJ2ZWRSYXljYXN0TWVzaCA9ICgpID0+IG1lc2g7XG4gICAgcmV0dXJuIG1lc2hcbiAgfTtcblxuICBjb25zdCBzeW5jU3RhcnRFdmVudCA9IHsgdHlwZTogJ3N5bmNzdGFydCcgfTtcbiAgY29uc3Qgc3luY0NvbXBsZXRlRXZlbnQgPSB7IHR5cGU6ICdzeW5jY29tcGxldGUnIH07XG5cbiAgY29uc3QgU1lOQ0FCTEVfUFJPUFMgPSBbXG4gICAgJ2ZvbnQnLFxuICAgICdmb250U2l6ZScsXG4gICAgJ2ZvbnRTdHlsZScsXG4gICAgJ2ZvbnRXZWlnaHQnLFxuICAgICdsYW5nJyxcbiAgICAnbGV0dGVyU3BhY2luZycsXG4gICAgJ2xpbmVIZWlnaHQnLFxuICAgICdtYXhXaWR0aCcsXG4gICAgJ292ZXJmbG93V3JhcCcsXG4gICAgJ3RleHQnLFxuICAgICdkaXJlY3Rpb24nLFxuICAgICd0ZXh0QWxpZ24nLFxuICAgICd0ZXh0SW5kZW50JyxcbiAgICAnd2hpdGVTcGFjZScsXG4gICAgJ2FuY2hvclgnLFxuICAgICdhbmNob3JZJyxcbiAgICAnY29sb3JSYW5nZXMnLFxuICAgICdzZGZHbHlwaFNpemUnXG4gIF07XG5cbiAgY29uc3QgQ09QWUFCTEVfUFJPUFMgPSBTWU5DQUJMRV9QUk9QUy5jb25jYXQoXG4gICAgJ21hdGVyaWFsJyxcbiAgICAnY29sb3InLFxuICAgICdkZXB0aE9mZnNldCcsXG4gICAgJ2NsaXBSZWN0JyxcbiAgICAnY3VydmVSYWRpdXMnLFxuICAgICdvcmllbnRhdGlvbicsXG4gICAgJ2dseXBoR2VvbWV0cnlEZXRhaWwnXG4gICk7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBUZXh0XG4gICAqXG4gICAqIEEgVGhyZWVKUyBNZXNoIHRoYXQgcmVuZGVycyBhIHN0cmluZyBvZiB0ZXh0IG9uIGEgcGxhbmUgaW4gM0Qgc3BhY2UgdXNpbmcgc2lnbmVkIGRpc3RhbmNlXG4gICAqIGZpZWxkcyAoU0RGKS5cbiAgICovXG4gIGNsYXNzIFRleHQgZXh0ZW5kcyB0aHJlZS5NZXNoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdseXBoc0dlb21ldHJ5KCk7XG4gICAgICBzdXBlcihnZW9tZXRyeSwgbnVsbCk7XG5cbiAgICAgIC8vID09PSBUZXh0IGxheW91dCBwcm9wZXJ0aWVzOiA9PT0gLy9cblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRleHRcbiAgICAgICAqIFRoZSBzdHJpbmcgb2YgdGV4dCB0byBiZSByZW5kZXJlZC5cbiAgICAgICAqL1xuICAgICAgdGhpcy50ZXh0ID0gJyc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gYW5jaG9yWFxuICAgICAgICogRGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgYSBudW1lcmljIHggcG9zaXRpb24gaW4gbG9jYWwgdW5pdHMsIGEgc3RyaW5nIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsXG4gICAgICAgKiB0ZXh0IGJsb2NrIHdpZHRoIGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOiAnbGVmdCcsICdjZW50ZXInLFxuICAgICAgICogb3IgJ3JpZ2h0Jy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5hbmNob3JYID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBhbmNob3JZXG4gICAgICAgKiBEZWZpbmVzIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgYSBudW1lcmljIHkgcG9zaXRpb24gaW4gbG9jYWwgdW5pdHMgKG5vdGU6IGRvd24gaXMgbmVnYXRpdmUgeSksIGEgc3RyaW5nXG4gICAgICAgKiBwZXJjZW50YWdlIG9mIHRoZSB0b3RhbCB0ZXh0IGJsb2NrIGhlaWdodCBlLmcuIGAnMjUlJ2AsIG9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIGtleXdvcmQgc3RyaW5nczpcbiAgICAgICAqICd0b3AnLCAndG9wLWJhc2VsaW5lJywgJ3RvcC1jYXAnLCAndG9wLWV4JywgJ21pZGRsZScsICdib3R0b20tYmFzZWxpbmUnLCBvciAnYm90dG9tJy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5hbmNob3JZID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGN1cnZlUmFkaXVzXG4gICAgICAgKiBEZWZpbmVzIGEgY3lsaW5kcmljYWwgcmFkaXVzIGFsb25nIHdoaWNoIHRoZSB0ZXh0J3MgcGxhbmUgd2lsbCBiZSBjdXJ2ZWQuIFBvc2l0aXZlIG51bWJlcnMgcHV0XG4gICAgICAgKiB0aGUgY3lsaW5kZXIncyBjZW50ZXJsaW5lIChvcmllbnRlZCB2ZXJ0aWNhbGx5KSB0aGF0IGRpc3RhbmNlIGluIGZyb250IG9mIHRoZSB0ZXh0LCBmb3IgYSBjb25jYXZlXG4gICAgICAgKiBjdXJ2YXR1cmUsIHdoaWxlIG5lZ2F0aXZlIG51bWJlcnMgcHV0IGl0IGJlaGluZCB0aGUgdGV4dCBmb3IgYSBjb252ZXggY3VydmF0dXJlLiBUaGUgY2VudGVybGluZVxuICAgICAgICogd2lsbCBiZSBhbGlnbmVkIHdpdGggdGhlIHRleHQncyBsb2NhbCBvcmlnaW47IHlvdSBjYW4gdXNlIGBhbmNob3JYYCB0byBvZmZzZXQgaXQuXG4gICAgICAgKlxuICAgICAgICogU2luY2UgZWFjaCBnbHlwaCBpcyBieSBkZWZhdWx0IHJlbmRlcmVkIHdpdGggYSBzaW1wbGUgcXVhZCwgZWFjaCBnbHlwaCByZW1haW5zIGEgZmxhdCBwbGFuZVxuICAgICAgICogaW50ZXJuYWxseS4gWW91IGNhbiB1c2UgYGdseXBoR2VvbWV0cnlEZXRhaWxgIHRvIGFkZCBtb3JlIHZlcnRpY2VzIGZvciBjdXJ2YXR1cmUgaW5zaWRlIGdseXBocy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5jdXJ2ZVJhZGl1cyA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgICAqIFNldHMgdGhlIGJhc2UgZGlyZWN0aW9uIGZvciB0aGUgdGV4dC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgXCJhdXRvXCIgd2lsbCBjaG9vc2UgYSBkaXJlY3Rpb24gYmFzZWRcbiAgICAgICAqIG9uIHRoZSB0ZXh0J3MgY29udGVudCBhY2NvcmRpbmcgdG8gdGhlIGJpZGkgc3BlYy4gQSB2YWx1ZSBvZiBcImx0clwiIG9yIFwicnRsXCIgd2lsbCBmb3JjZSB0aGUgZGlyZWN0aW9uLlxuICAgICAgICovXG4gICAgICB0aGlzLmRpcmVjdGlvbiA9ICdhdXRvJztcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVsbH0gZm9udFxuICAgICAgICogVVJMIG9mIGEgY3VzdG9tIGZvbnQgdG8gYmUgdXNlZC4gRm9udCBmaWxlcyBjYW4gYmUgaW4gLnR0ZiwgLm90Ziwgb3IgLndvZmYgKG5vdCAud29mZjIpIGZvcm1hdHMuXG4gICAgICAgKiBEZWZhdWx0cyB0byBOb3RvIFNhbnMuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZm9udCA9IG51bGw7IC8vd2lsbCB1c2UgZGVmYXVsdCBmcm9tIFRleHRCdWlsZGVyXG5cbiAgICAgIHRoaXMudW5pY29kZUZvbnRzVVJMID0gbnVsbDsgLy9kZWZhdWx0cyB0byBDRE5cblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZvbnRTaXplXG4gICAgICAgKiBUaGUgc2l6ZSBhdCB3aGljaCB0byByZW5kZXIgdGhlIGZvbnQgaW4gbG9jYWwgdW5pdHM7IGNvcnJlc3BvbmRzIHRvIHRoZSBlbS1ib3ggaGVpZ2h0XG4gICAgICAgKiBvZiB0aGUgY2hvc2VuIGBmb250YC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5mb250U2l6ZSA9IDAuMTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8J25vcm1hbCd8J2JvbGQnfVxuICAgICAgICogVGhlIHdlaWdodCBvZiB0aGUgZm9udC4gQ3VycmVudGx5IG9ubHkgdXNlZCBmb3IgZmFsbGJhY2sgTm90byBmb250cy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5mb250V2VpZ2h0ID0gJ25vcm1hbCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7J25vcm1hbCd8J2l0YWxpYyd9XG4gICAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGZvbnQuIEN1cnJlbnRseSBvbmx5IHVzZWQgZm9yIGZhbGxiYWNrIE5vdG8gZm9udHMuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZm9udFN0eWxlID0gJ25vcm1hbCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfG51bGx9IGxhbmdcbiAgICAgICAqIFRoZSBsYW5ndWFnZSBjb2RlIG9mIHRoaXMgdGV4dDsgY2FuIGJlIHVzZWQgZm9yIGV4cGxpY2l0bHkgc2VsZWN0aW5nIGNlcnRhaW4gQ0pLIGZvbnRzLlxuICAgICAgICovXG4gICAgICB0aGlzLmxhbmcgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBsZXR0ZXJTcGFjaW5nXG4gICAgICAgKiBTZXRzIGEgdW5pZm9ybSBhZGp1c3RtZW50IHRvIHNwYWNpbmcgYmV0d2VlbiBsZXR0ZXJzIGFmdGVyIGtlcm5pbmcgaXMgYXBwbGllZC4gUG9zaXRpdmVcbiAgICAgICAqIG51bWJlcnMgaW5jcmVhc2Ugc3BhY2luZyBhbmQgbmVnYXRpdmUgbnVtYmVycyBkZWNyZWFzZSBpdC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5sZXR0ZXJTcGFjaW5nID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBsaW5lSGVpZ2h0XG4gICAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCBsaW5lIG9mIHRleHQsIGFzIGEgbXVsdGlwbGUgb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvICdub3JtYWwnXG4gICAgICAgKiB3aGljaCBjaG9vc2VzIGEgcmVhc29uYWJsZSBoZWlnaHQgYmFzZWQgb24gdGhlIGNob3NlbiBmb250J3MgYXNjZW5kZXIvZGVzY2VuZGVyIG1ldHJpY3MuXG4gICAgICAgKi9cbiAgICAgIHRoaXMubGluZUhlaWdodCA9ICdub3JtYWwnO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbWF4V2lkdGhcbiAgICAgICAqIFRoZSBtYXhpbXVtIHdpZHRoIG9mIHRoZSB0ZXh0IGJsb2NrLCBhYm92ZSB3aGljaCB0ZXh0IG1heSBzdGFydCB3cmFwcGluZyBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICAgKiBgd2hpdGVTcGFjZWAgYW5kIGBvdmVyZmxvd1dyYXBgIHByb3BlcnRpZXMuXG4gICAgICAgKi9cbiAgICAgIHRoaXMubWF4V2lkdGggPSBJbmZpbml0eTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG92ZXJmbG93V3JhcFxuICAgICAgICogRGVmaW5lcyBob3cgdGV4dCB3cmFwcyBpZiB0aGUgYHdoaXRlU3BhY2VgIHByb3BlcnR5IGlzIGBub3JtYWxgLiBDYW4gYmUgZWl0aGVyIGAnbm9ybWFsJ2BcbiAgICAgICAqIHRvIGJyZWFrIGF0IHdoaXRlc3BhY2UgY2hhcmFjdGVycywgb3IgYCdicmVhay13b3JkJ2AgdG8gYWxsb3cgYnJlYWtpbmcgd2l0aGluIHdvcmRzLlxuICAgICAgICogRGVmYXVsdHMgdG8gYCdub3JtYWwnYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5vdmVyZmxvd1dyYXAgPSAnbm9ybWFsJztcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRleHRBbGlnblxuICAgICAgICogVGhlIGhvcml6b250YWwgYWxpZ25tZW50IG9mIGVhY2ggbGluZSBvZiB0ZXh0IHdpdGhpbiB0aGUgb3ZlcmFsbCB0ZXh0IGJvdW5kaW5nIGJveC5cbiAgICAgICAqL1xuICAgICAgdGhpcy50ZXh0QWxpZ24gPSAnbGVmdCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSB0ZXh0SW5kZW50XG4gICAgICAgKiBJbmRlbnRhdGlvbiBmb3IgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGxpbmU7IHNlZSBDU1MgYHRleHQtaW5kZW50YC5cbiAgICAgICAqL1xuICAgICAgdGhpcy50ZXh0SW5kZW50ID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHdoaXRlU3BhY2VcbiAgICAgICAqIERlZmluZXMgd2hldGhlciB0ZXh0IHNob3VsZCB3cmFwIHdoZW4gYSBsaW5lIHJlYWNoZXMgdGhlIGBtYXhXaWR0aGAuIENhblxuICAgICAgICogYmUgZWl0aGVyIGAnbm9ybWFsJ2AgKHRoZSBkZWZhdWx0KSwgdG8gYWxsb3cgd3JhcHBpbmcgYWNjb3JkaW5nIHRvIHRoZSBgb3ZlcmZsb3dXcmFwYCBwcm9wZXJ0eSxcbiAgICAgICAqIG9yIGAnbm93cmFwJ2AgdG8gcHJldmVudCB3cmFwcGluZy4gTm90ZSB0aGF0IGAnbm9ybWFsJ2AgaGVyZSBob25vcnMgbmV3bGluZSBjaGFyYWN0ZXJzIHRvXG4gICAgICAgKiBtYW51YWxseSBicmVhayBsaW5lcywgbWFraW5nIGl0IGJlaGF2ZSBtb3JlIGxpa2UgYCdwcmUtd3JhcCdgIGRvZXMgaW4gQ1NTLlxuICAgICAgICovXG4gICAgICB0aGlzLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcblxuXG4gICAgICAvLyA9PT0gUHJlc2VudGF0aW9uIHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge1RIUkVFLk1hdGVyaWFsfSBtYXRlcmlhbFxuICAgICAgICogRGVmaW5lcyBhIF9iYXNlXyBtYXRlcmlhbCB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIHRoZSB0ZXh0LiBUaGlzIG1hdGVyaWFsIHdpbGwgYmVcbiAgICAgICAqIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgd2l0aCBhIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBpdCwgdGhhdCBhZGRzIHNoYWRlciBjb2RlIHRvXG4gICAgICAgKiBkZWNyZWFzZSB0aGUgYWxwaGEgZm9yIGVhY2ggZnJhZ21lbnQgKHBpeGVsKSBvdXRzaWRlIHRoZSB0ZXh0IGdseXBocywgd2l0aCBhbnRpYWxpYXNpbmcuXG4gICAgICAgKiBCeSBkZWZhdWx0IGl0IHdpbGwgZGVyaXZlIGZyb20gYSBzaW1wbGUgd2hpdGUgTWVzaEJhc2ljTWF0ZXJpYWwsIGJ1dCB5b3UgY2FuIHVzZSBhbnlcbiAgICAgICAqIG9mIHRoZSBvdGhlciBtZXNoIG1hdGVyaWFscyB0byBnYWluIG90aGVyIGZlYXR1cmVzIGxpa2UgbGlnaHRpbmcsIHRleHR1cmUgbWFwcywgZXRjLlxuICAgICAgICpcbiAgICAgICAqIEFsc28gc2VlIHRoZSBgY29sb3JgIHNob3J0Y3V0IHByb3BlcnR5LlxuICAgICAgICovXG4gICAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBjb2xvclxuICAgICAgICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBzZXR0aW5nIHRoZSBgY29sb3JgIG9mIHRoZSB0ZXh0J3MgbWF0ZXJpYWwuIFlvdSBjYW4gdXNlIHRoaXNcbiAgICAgICAqIGlmIHlvdSBkb24ndCB3YW50IHRvIHNwZWNpZnkgYSB3aG9sZSBjdXN0b20gYG1hdGVyaWFsYC4gQWxzbywgaWYgeW91IGRvIHVzZSBhIGN1c3RvbVxuICAgICAgICogYG1hdGVyaWFsYCwgdGhpcyBjb2xvciB3aWxsIG9ubHkgYmUgdXNlZCBmb3IgdGhpcyBwYXJ0aWN1YXIgVGV4dCBpbnN0YW5jZSwgZXZlbiBpZlxuICAgICAgICogdGhhdCBzYW1lIG1hdGVyaWFsIGluc3RhbmNlIGlzIHNoYXJlZCBhY3Jvc3MgbXVsdGlwbGUgVGV4dCBvYmplY3RzLlxuICAgICAgICovXG4gICAgICB0aGlzLmNvbG9yID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtvYmplY3R8bnVsbH0gY29sb3JSYW5nZXNcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIFRoaXMgYWxsb3dzIG1vcmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb2YgY29sb3JzIGZvciBpbmRpdmlkdWFsIG9yIHJhbmdlcyBvZiBjaGFyYWN0ZXJzLFxuICAgICAgICogdGFraW5nIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWF0ZXJpYWwncyBgY29sb3JgLiBJdHMgZm9ybWF0IGlzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGVhY2hcbiAgICAgICAqIGRlZmluZSBhIHN0YXJ0aW5nIGNoYXJhY3RlciBpbmRleCBmb3IgYSByYW5nZSwgYW5kIHdob3NlIHZhbHVlcyBhcmUgdGhlIGNvbG9yIGZvciBlYWNoXG4gICAgICAgKiByYW5nZS4gVGhlIGNvbG9yIHZhbHVlIGNhbiBiZSBhIG51bWVyaWMgaGV4IGNvbG9yIHZhbHVlLCBhIGBUSFJFRS5Db2xvcmAgb2JqZWN0LCBvclxuICAgICAgICogYW55IG9mIHRoZSBzdHJpbmdzIGFjY2VwdGVkIGJ5IGBUSFJFRS5Db2xvcmAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuY29sb3JSYW5nZXMgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVXaWR0aFxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogVGhlIHdpZHRoIG9mIGFuIG91dGxpbmUvaGFsbyB0byBiZSBkcmF3biBhcm91bmQgZWFjaCB0ZXh0IGdseXBoIHVzaW5nIHRoZSBgb3V0bGluZUNvbG9yYCBhbmQgYG91dGxpbmVPcGFjaXR5YC5cbiAgICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuXG4gICAgICAgKiBgXCIxMiVcImAgd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYCwgd2hpY2ggbWVhbnNcbiAgICAgICAqIG5vIG91dGxpbmUgd2lsbCBiZSBkcmF3biB1bmxlc3MgYW4gYG91dGxpbmVPZmZzZXRYL1lgIG9yIGBvdXRsaW5lQmx1cmAgaXMgc2V0LlxuICAgICAgICovXG4gICAgICB0aGlzLm91dGxpbmVXaWR0aCA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gb3V0bGluZUNvbG9yXG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgb3V0bGluZSwgaWYgYG91dGxpbmVXaWR0aGAvYG91dGxpbmVCbHVyYC9gb3V0bGluZU9mZnNldFgvWWAgYXJlIHNldC5cbiAgICAgICAqIERlZmF1bHRzIHRvIGJsYWNrLlxuICAgICAgICovXG4gICAgICB0aGlzLm91dGxpbmVDb2xvciA9IDB4MDAwMDAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gb3V0bGluZU9wYWNpdHlcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBvdXRsaW5lLCBpZiBgb3V0bGluZVdpZHRoYC9gb3V0bGluZUJsdXJgL2BvdXRsaW5lT2Zmc2V0WC9ZYCBhcmUgc2V0LlxuICAgICAgICogRGVmYXVsdHMgdG8gYDFgLlxuICAgICAgICovXG4gICAgICB0aGlzLm91dGxpbmVPcGFjaXR5ID0gMTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lQmx1clxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogQSBibHVyIHJhZGl1cyBhcHBsaWVkIHRvIHRoZSBvdXRlciBlZGdlIG9mIHRoZSB0ZXh0J3Mgb3V0bGluZS4gSWYgdGhlIGBvdXRsaW5lV2lkdGhgIGlzXG4gICAgICAgKiB6ZXJvLCB0aGUgYmx1ciB3aWxsIGJlIGFwcGxpZWQgYXQgdGhlIGdseXBoIGVkZ2UsIGxpa2UgQ1NTJ3MgYHRleHQtc2hhZG93YCBibHVyIHJhZGl1cy5cbiAgICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuXG4gICAgICAgKiBgXCIxMiVcImAgd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5vdXRsaW5lQmx1ciA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZU9mZnNldFhcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIEEgaG9yaXpvbnRhbCBvZmZzZXQgZm9yIHRoZSB0ZXh0IG91dGxpbmUuXG4gICAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMub3V0bGluZU9mZnNldFggPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVPZmZzZXRZXG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBBIHZlcnRpY2FsIG9mZnNldCBmb3IgdGhlIHRleHQgb3V0bGluZS5cbiAgICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5vdXRsaW5lT2Zmc2V0WSA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gc3Ryb2tlV2lkdGhcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIFRoZSB3aWR0aCBvZiBhbiBpbm5lciBzdHJva2UgZHJhd24gaW5zaWRlIGVhY2ggdGV4dCBnbHlwaCB1c2luZyB0aGUgYHN0cm9rZUNvbG9yYCBhbmQgYHN0cm9rZU9wYWNpdHlgLlxuICAgICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAgICovXG4gICAgICB0aGlzLnN0cm9rZVdpZHRoID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBzdHJva2VDb2xvclxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IHN0cm9rZSwgaWYgYHN0cm9rZVdpZHRoYCBpcyBncmVhdGVyIHRoYW4gemVyby4gRGVmYXVsdHMgdG8gZ3JheS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5zdHJva2VDb2xvciA9IGRlZmF1bHRTdHJva2VDb2xvcjtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHN0cm9rZU9wYWNpdHlcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBzdHJva2UsIGlmIGBzdHJva2VXaWR0aGAgaXMgZ3JlYXRlciB0aGFuIHplcm8uIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZpbGxPcGFjaXR5XG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgZ2x5cGgncyBmaWxsIGZyb20gMCB0byAxLiBUaGlzIGJlaGF2ZXMgbGlrZSB0aGUgbWF0ZXJpYWwncyBgb3BhY2l0eWAgYnV0IGFsbG93c1xuICAgICAgICogZ2l2aW5nIHRoZSBmaWxsIGEgZGlmZmVyZW50IG9wYWNpdHkgdGhhbiB0aGUgYHN0cm9rZU9wYWNpdHlgLiBBIGZpbGxPcGFjaXR5IG9mIGAwYCBtYWtlcyB0aGVcbiAgICAgICAqIGludGVyaW9yIG9mIHRoZSBnbHlwaCBpbnZpc2libGUsIGxlYXZpbmcganVzdCB0aGUgYHN0cm9rZVdpZHRoYC4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAgICovXG4gICAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGRlcHRoT2Zmc2V0XG4gICAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHNldHRpbmcgdGhlIG1hdGVyaWFsJ3MgYHBvbHlnb25PZmZzZXRgIGFuZCByZWxhdGVkIHByb3BlcnRpZXMsXG4gICAgICAgKiB3aGljaCBjYW4gYmUgdXNlZnVsIGluIHByZXZlbnRpbmcgei1maWdodGluZyB3aGVuIHRoaXMgdGV4dCBpcyBsYWlkIG9uIHRvcCBvZiBhbm90aGVyXG4gICAgICAgKiBwbGFuZSBpbiB0aGUgc2NlbmUuIFBvc2l0aXZlIG51bWJlcnMgYXJlIGZ1cnRoZXIgZnJvbSB0aGUgY2FtZXJhLCBuZWdhdGl2ZXMgY2xvc2VyLlxuICAgICAgICovXG4gICAgICB0aGlzLmRlcHRoT2Zmc2V0ID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtBcnJheTxudW1iZXI+fSBjbGlwUmVjdFxuICAgICAgICogSWYgc3BlY2lmaWVkLCBkZWZpbmVzIGEgYFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXWAgb2YgYSByZWN0YW5nbGUgb3V0c2lkZSBvZiB3aGljaCBhbGxcbiAgICAgICAqIHBpeGVscyB3aWxsIGJlIGRpc2NhcmRlZC4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBjbGlwIG92ZXJmbG93aW5nIHRleHQgd2hlblxuICAgICAgICogYHdoaXRlU3BhY2U9J25vd3JhcCdgLlxuICAgICAgICovXG4gICAgICB0aGlzLmNsaXBSZWN0ID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG9yaWVudGF0aW9uXG4gICAgICAgKiBEZWZpbmVzIHRoZSBheGlzIHBsYW5lIG9uIHdoaWNoIHRoZSB0ZXh0IHNob3VsZCBiZSBsYWlkIG91dCB3aGVuIHRoZSBtZXNoIGhhcyBubyBleHRyYVxuICAgICAgICogcm90YXRpb24gdHJhbnNmb3JtLiBJdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgd2l0aCB0d28gYXhlczogdGhlIGhvcml6b250YWwgYXhpcyB3aXRoXG4gICAgICAgKiBwb3NpdGl2ZSBwb2ludGluZyByaWdodCwgYW5kIHRoZSB2ZXJ0aWNhbCBheGlzIHdpdGggcG9zaXRpdmUgcG9pbnRpbmcgdXAuIEJ5IGRlZmF1bHQgdGhpc1xuICAgICAgICogaXMgJyt4K3knLCBtZWFuaW5nIHRoZSB0ZXh0IHNpdHMgb24gdGhlIHh5IHBsYW5lIHdpdGggdGhlIHRleHQncyB0b3AgdG93YXJkIHBvc2l0aXZlIHlcbiAgICAgICAqIGFuZCBmYWNpbmcgcG9zaXRpdmUgei4gQSB2YWx1ZSBvZiAnK3gteicgd291bGQgcGxhY2UgaXQgb24gdGhlIHh6IHBsYW5lIHdpdGggdGhlIHRleHQnc1xuICAgICAgICogdG9wIHRvd2FyZCBuZWdhdGl2ZSB6IGFuZCBmYWNpbmcgcG9zaXRpdmUgeS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IGRlZmF1bHRPcmllbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBnbHlwaEdlb21ldHJ5RGV0YWlsXG4gICAgICAgKiBDb250cm9scyBudW1iZXIgb2YgdmVydGljYWwvaG9yaXpvbnRhbCBzZWdtZW50cyB0aGF0IG1ha2UgdXAgZWFjaCBnbHlwaCdzIHJlY3Rhbmd1bGFyXG4gICAgICAgKiBwbGFuZS4gRGVmYXVsdHMgdG8gMS4gVGhpcyBjYW4gYmUgaW5jcmVhc2VkIHRvIHByb3ZpZGUgbW9yZSBnZW9tZXRyaWNhbCBkZXRhaWwgZm9yIGN1c3RvbVxuICAgICAgICogdmVydGV4IHNoYWRlciBlZmZlY3RzLCBmb3IgZXhhbXBsZS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5nbHlwaEdlb21ldHJ5RGV0YWlsID0gMTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8bnVsbH0gc2RmR2x5cGhTaXplXG4gICAgICAgKiBUaGUgc2l6ZSBvZiBlYWNoIGdseXBoJ3MgU0RGIChzaWduZWQgZGlzdGFuY2UgZmllbGQpIHVzZWQgZm9yIHJlbmRlcmluZy4gVGhpcyBtdXN0IGJlIGFcbiAgICAgICAqIHBvd2VyLW9mLXR3byBudW1iZXIuIERlZmF1bHRzIHRvIDY0IHdoaWNoIGlzIGdlbmVyYWxseSBhIGdvb2QgYmFsYW5jZSBvZiBzaXplIGFuZCBxdWFsaXR5XG4gICAgICAgKiBmb3IgbW9zdCBmb250cy4gTGFyZ2VyIHNpemVzIGNhbiBpbXByb3ZlIHRoZSBxdWFsaXR5IG9mIGdseXBoIHJlbmRlcmluZyBieSBpbmNyZWFzaW5nXG4gICAgICAgKiB0aGUgc2hhcnBuZXNzIG9mIGNvcm5lcnMgYW5kIHByZXZlbnRpbmcgbG9zcyBvZiB2ZXJ5IHRoaW4gbGluZXMsIGF0IHRoZSBleHBlbnNlIG9mXG4gICAgICAgKiBpbmNyZWFzZWQgbWVtb3J5IGZvb3RwcmludCBhbmQgbG9uZ2VyIFNERiBnZW5lcmF0aW9uIHRpbWUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc2RmR2x5cGhTaXplID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBncHVBY2NlbGVyYXRlU0RGXG4gICAgICAgKiBXaGVuIGB0cnVlYCwgdGhlIFNERiBnZW5lcmF0aW9uIHByb2Nlc3Mgd2lsbCBiZSBHUFUtYWNjZWxlcmF0ZWQgd2l0aCBXZWJHTCB3aGVuIHBvc3NpYmxlLFxuICAgICAgICogbWFraW5nIGl0IG11Y2ggZmFzdGVyIGVzcGVjaWFsbHkgZm9yIGNvbXBsZXggZ2x5cGhzLCBhbmQgZmFsbGluZyBiYWNrIHRvIGEgSmF2YVNjcmlwdCB2ZXJzaW9uXG4gICAgICAgKiBleGVjdXRlZCBpbiB3ZWIgd29ya2VycyB3aGVuIHN1cHBvcnQgaXNuJ3QgYXZhaWxhYmxlLiBJdCBzaG91bGQgYXV0b21hdGljYWxseSBkZXRlY3Qgc3VwcG9ydCxcbiAgICAgICAqIGJ1dCBpdCdzIHN0aWxsIHNvbWV3aGF0IGV4cGVyaW1lbnRhbCwgc28geW91IGNhbiBzZXQgaXQgdG8gYGZhbHNlYCB0byBmb3JjZSBpdCB0byB1c2UgdGhlIEpTXG4gICAgICAgKiB2ZXJzaW9uIGlmIHlvdSBlbmNvdW50ZXIgaXNzdWVzIHdpdGggaXQuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZ3B1QWNjZWxlcmF0ZVNERiA9IHRydWU7XG5cbiAgICAgIHRoaXMuZGVidWdTREYgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0ZXh0IHJlbmRlcmluZyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdGV4dC1yZWxhdGVkIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcy5cbiAgICAgKiBUaGlzIGlzIGFuIGFzeW5jIHByb2Nlc3MsIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaXRcbiAgICAgKiBmaW5pc2hlcy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAgICovXG4gICAgc3luYyhjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuX25lZWRzU3luYykge1xuICAgICAgICB0aGlzLl9uZWVkc1N5bmMgPSBmYWxzZTtcblxuICAgICAgICAvLyBJZiB0aGVyZSdzIGFub3RoZXIgc3luYyBzdGlsbCBpbiBwcm9ncmVzcywgcXVldWVcbiAgICAgICAgaWYgKHRoaXMuX2lzU3luY2luZykge1xuICAgICAgICAgICh0aGlzLl9xdWV1ZWRTeW5jcyB8fCAodGhpcy5fcXVldWVkU3luY3MgPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2lzU3luY2luZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN5bmNTdGFydEV2ZW50KTtcblxuICAgICAgICAgIGdldFRleHRSZW5kZXJJbmZvKHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgICAgICAgIGZvbnQ6IHRoaXMuZm9udCxcbiAgICAgICAgICAgIGxhbmc6IHRoaXMubGFuZyxcbiAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplIHx8IDAuMSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCB8fCAnbm9ybWFsJyxcbiAgICAgICAgICAgIGZvbnRTdHlsZTogdGhpcy5mb250U3R5bGUgfHwgJ25vcm1hbCcsXG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcgfHwgMCxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMubGluZUhlaWdodCB8fCAnbm9ybWFsJyxcbiAgICAgICAgICAgIG1heFdpZHRoOiB0aGlzLm1heFdpZHRoLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbiB8fCAnYXV0bycsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRoaXMudGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dEluZGVudDogdGhpcy50ZXh0SW5kZW50LFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgICAgICAgb3ZlcmZsb3dXcmFwOiB0aGlzLm92ZXJmbG93V3JhcCxcbiAgICAgICAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yWCxcbiAgICAgICAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgICAgICAgIGNvbG9yUmFuZ2VzOiB0aGlzLmNvbG9yUmFuZ2VzLFxuICAgICAgICAgICAgaW5jbHVkZUNhcmV0UG9zaXRpb25zOiB0cnVlLCAvL1RPRE8gcGFyYW1ldGVyaXplXG4gICAgICAgICAgICBzZGZHbHlwaFNpemU6IHRoaXMuc2RmR2x5cGhTaXplLFxuICAgICAgICAgICAgZ3B1QWNjZWxlcmF0ZVNERjogdGhpcy5ncHVBY2NlbGVyYXRlU0RGLFxuICAgICAgICAgICAgdW5pY29kZUZvbnRzVVJMOiB0aGlzLnVuaWNvZGVGb250c1VSTCxcbiAgICAgICAgICB9LCB0ZXh0UmVuZGVySW5mbyA9PiB7XG4gICAgICAgICAgICB0aGlzLl9pc1N5bmNpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gU2F2ZSByZXN1bHQgZm9yIGxhdGVyIHVzZSBpbiBvbkJlZm9yZVJlbmRlclxuICAgICAgICAgICAgdGhpcy5fdGV4dFJlbmRlckluZm8gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICB0aGlzLmdlb21ldHJ5LnVwZGF0ZUdseXBocyhcbiAgICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhCb3VuZHMsXG4gICAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5ibG9ja0JvdW5kcyxcbiAgICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uY2h1bmtlZEJvdW5kcyxcbiAgICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhDb2xvcnNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGhhZCBleHRyYSBzeW5jIHJlcXVlc3RzIHF1ZXVlZCB1cCwga2ljayBpdCBvZmZcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlZCA9IHRoaXMuX3F1ZXVlZFN5bmNzO1xuICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICAgICAgICB0aGlzLl9xdWV1ZWRTeW5jcyA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuc3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgcXVldWVkLmZvckVhY2goZm4gPT4gZm4gJiYgZm4oKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY0NvbXBsZXRlRXZlbnQpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBhIHN5bmMgaWYgbmVlZGVkIC0gbm90ZSBpdCB3b24ndCBjb21wbGV0ZSB1bnRpbCBuZXh0IGZyYW1lIGF0IHRoZVxuICAgICAqIGVhcmxpZXN0IHNvIGlmIHBvc3NpYmxlIGl0J3MgYSBnb29kIGlkZWEgdG8gY2FsbCBzeW5jKCkgbWFudWFsbHkgYXMgc29vbiBhc1xuICAgICAqIGFsbCB0aGUgcHJvcGVydGllcyBoYXZlIGJlZW4gc2V0LlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIG9uQmVmb3JlUmVuZGVyKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKSB7XG4gICAgICB0aGlzLnN5bmMoKTtcblxuICAgICAgLy8gVGhpcyBtYXkgbm90IGFsd2F5cyBiZSBhIHRleHQgbWF0ZXJpYWwsIGUuZy4gaWYgdGhlcmUncyBhIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgcHJlc2VudFxuICAgICAgaWYgKG1hdGVyaWFsLmlzVHJvaWthVGV4dE1hdGVyaWFsKSB7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVGb3JSZW5kZXIobWF0ZXJpYWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBuZWVkIHRvIGZvcmNlIHRoZSBtYXRlcmlhbCB0byBGcm9udFNpZGUgdG8gYXZvaWQgdGhlIGRvdWJsZS1kcmF3LWNhbGwgcGVyZm9ybWFuY2UgaGl0XG4gICAgICAvLyBpbnRyb2R1Y2VkIGluIFRocmVlLmpzIHIxMzA6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMTk2NyAtIFRoZSBzaWRlZG5lc3NcbiAgICAgIC8vIGlzIGluc3RlYWQgYXBwbGllZCB2aWEgZHJhd1JhbmdlIGluIHRoZSBHbHlwaHNHZW9tZXRyeS5cbiAgICAgIG1hdGVyaWFsLl9oYWRPd25TaWRlID0gbWF0ZXJpYWwuaGFzT3duUHJvcGVydHkoJ3NpZGUnKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0U2lkZShtYXRlcmlhbC5fYWN0dWFsU2lkZSA9IG1hdGVyaWFsLnNpZGUpO1xuICAgICAgbWF0ZXJpYWwuc2lkZSA9IHRocmVlLkZyb250U2lkZTtcbiAgICB9XG5cbiAgICBvbkFmdGVyUmVuZGVyKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKSB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIG1hdGVyaWFsIHNpZGVcbiAgICAgIGlmIChtYXRlcmlhbC5faGFkT3duU2lkZSkge1xuICAgICAgICBtYXRlcmlhbC5zaWRlID0gbWF0ZXJpYWwuX2FjdHVhbFNpZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgbWF0ZXJpYWwuc2lkZTsgLy8gYmFjayB0byBpbmhlcml0aW5nIGZyb20gYmFzZSBtYXRlcmlhbFxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3J0Y3V0IHRvIGRpc3Bvc2UgdGhlIGdlb21ldHJ5IHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICogTm90ZTogd2UgZG9uJ3QgYWxzbyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGhlcmUgYmVjYXVzZSBpZiBhbnl0aGluZyBlbHNlIGlzXG4gICAgICogc2hhcmluZyB0aGUgc2FtZSBiYXNlIG1hdGVyaWFsIGl0IHdpbGwgcmVzdWx0IGluIGEgcGF1c2UgbmV4dCBmcmFtZSBhcyB0aGUgcHJvZ3JhbVxuICAgICAqIGlzIHJlY29tcGlsZWQuIEluc3RlYWQgdXNlcnMgY2FuIGRpc3Bvc2UgdGhlIGJhc2UgbWF0ZXJpYWwgbWFudWFsbHksIGxpa2Ugbm9ybWFsLFxuICAgICAqIGFuZCB3ZSdsbCBhbHNvIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgYXQgdGhhdCB0aW1lLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1Ryb2lrYVRleHRSZW5kZXJJbmZvfG51bGx9IHRleHRSZW5kZXJJbmZvXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogVGhlIGN1cnJlbnQgcHJvY2Vzc2VkIHJlbmRlcmluZyBkYXRhIGZvciB0aGlzIFRleHRNZXNoLCByZXR1cm5lZCBieSB0aGUgVGV4dEJ1aWxkZXIgYWZ0ZXJcbiAgICAgKiBhIGBzeW5jKClgIGNhbGwuIFRoaXMgd2lsbCBiZSBgbnVsbGAgaW5pdGlhbGx5LCBhbmQgbWF5IGJlIHN0YWxlIGZvciBhIHNob3J0IHBlcmlvZCB1bnRpbFxuICAgICAqIHRoZSBhc3luY2hyb3VzIGBzeW5jKClgIHByb2Nlc3MgY29tcGxldGVzLlxuICAgICAqL1xuICAgIGdldCB0ZXh0UmVuZGVySW5mbygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0UmVuZGVySW5mbyB8fCBudWxsXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlciBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyB0aGUgYmFzZSBtYXRlcmlhbCB3aXRoIG91ciB1cGdyYWRlcy4gV2UgZG8gdGhlIHdyYXBwaW5nXG4gICAgLy8gbGF6aWx5IG9uIF9yZWFkXyByYXRoZXIgdGhhbiB3cml0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3cmFwcGluZyBvbiB0cmFuc2llbnQgdmFsdWVzLlxuICAgIGdldCBtYXRlcmlhbCgpIHtcbiAgICAgIGxldCBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWw7XG4gICAgICBjb25zdCBiYXNlTWF0ZXJpYWwgPSB0aGlzLl9iYXNlTWF0ZXJpYWwgfHwgdGhpcy5fZGVmYXVsdE1hdGVyaWFsIHx8ICh0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgPSBkZWZhdWx0TWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgICBpZiAoIWRlcml2ZWRNYXRlcmlhbCB8fCBkZXJpdmVkTWF0ZXJpYWwuYmFzZU1hdGVyaWFsICE9PSBiYXNlTWF0ZXJpYWwpIHtcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsID0gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICAgICAgICAvLyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHdoZW4gaXRzIGJhc2UgbWF0ZXJpYWwgaXMgZGlzcG9zZWQ6XG4gICAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICAgIGJhc2VNYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25EaXNwb3NlKTtcbiAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRleHQgb3V0bGluZSBpcyBjb25maWd1cmVkLCByZW5kZXIgaXQgYXMgYSBwcmVsaW1pbmFyeSBkcmF3IHVzaW5nIFRocmVlJ3MgbXVsdGktbWF0ZXJpYWxcbiAgICAgIC8vIGZlYXR1cmUgKHNlZSBHbHlwaHNHZW9tZXRyeSB3aGljaCBzZXRzIHVwIGBncm91cHNgIGZvciB0aGlzIHB1cnBvc2UpIERvaW5nIGl0IHdpdGggbXVsdGlcbiAgICAgIC8vIG1hdGVyaWFscyBlbnN1cmVzIHRoZSBsYXllcnMgYXJlIGFsd2F5cyByZW5kZXJlZCBjb25zZWN1dGl2ZWx5IGluIGEgY29uc2lzdGVudCBvcmRlci5cbiAgICAgIC8vIEVhY2ggbGF5ZXIgd2lsbCB0cmlnZ2VyIG9uQmVmb3JlUmVuZGVyIHdpdGggdGhlIGFwcHJvcHJpYXRlIG1hdGVyaWFsLlxuICAgICAgaWYgKHRoaXMub3V0bGluZVdpZHRoIHx8IHRoaXMub3V0bGluZUJsdXIgfHwgdGhpcy5vdXRsaW5lT2Zmc2V0WCB8fCB0aGlzLm91dGxpbmVPZmZzZXRZKSB7XG4gICAgICAgIGxldCBvdXRsaW5lTWF0ZXJpYWwgPSBkZXJpdmVkTWF0ZXJpYWwuX291dGxpbmVNdGw7XG4gICAgICAgIGlmICghb3V0bGluZU1hdGVyaWFsKSB7XG4gICAgICAgICAgb3V0bGluZU1hdGVyaWFsID0gZGVyaXZlZE1hdGVyaWFsLl9vdXRsaW5lTXRsID0gT2JqZWN0LmNyZWF0ZShkZXJpdmVkTWF0ZXJpYWwsIHtcbiAgICAgICAgICAgIGlkOiB7dmFsdWU6IGRlcml2ZWRNYXRlcmlhbC5pZCArIDAuMX1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvdXRsaW5lTWF0ZXJpYWwuaXNUZXh0T3V0bGluZU1hdGVyaWFsID0gdHJ1ZTtcbiAgICAgICAgICBvdXRsaW5lTWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgICAgICAgIG91dGxpbmVNYXRlcmlhbC5tYXAgPSBudWxsOyAvLz8/P1xuICAgICAgICAgIGRlcml2ZWRNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICAgICAgZGVyaXZlZE1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICAgICAgb3V0bGluZU1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIG91dGxpbmVNYXRlcmlhbCxcbiAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWxcbiAgICAgICAgXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICAgICAgfVxuICAgIH1cbiAgICBzZXQgbWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgICBpZiAoYmFzZU1hdGVyaWFsICYmIGJhc2VNYXRlcmlhbC5pc1Ryb2lrYVRleHRNYXRlcmlhbCkgeyAvL3ByZXZlbnQgZG91YmxlLWRlcml2YXRpb25cbiAgICAgICAgdGhpcy5fZGVyaXZlZE1hdGVyaWFsID0gYmFzZU1hdGVyaWFsO1xuICAgICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWwuYmFzZU1hdGVyaWFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYmFzZU1hdGVyaWFsID0gYmFzZU1hdGVyaWFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBnbHlwaEdlb21ldHJ5RGV0YWlsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuZGV0YWlsXG4gICAgfVxuICAgIHNldCBnbHlwaEdlb21ldHJ5RGV0YWlsKGRldGFpbCkge1xuICAgICAgdGhpcy5nZW9tZXRyeS5kZXRhaWwgPSBkZXRhaWw7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnZlUmFkaXVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuY3VydmVSYWRpdXNcbiAgICB9XG4gICAgc2V0IGN1cnZlUmFkaXVzKHIpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuY3VydmVSYWRpdXMgPSByO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbmQgdXBkYXRlIG1hdGVyaWFsIGZvciBzaGFkb3dzIHVwb24gcmVxdWVzdDpcbiAgICBnZXQgY3VzdG9tRGVwdGhNYXRlcmlhbCgpIHtcbiAgICAgIHJldHVybiBmaXJzdCh0aGlzLm1hdGVyaWFsKS5nZXREZXB0aE1hdGVyaWFsKClcbiAgICB9XG4gICAgZ2V0IGN1c3RvbURpc3RhbmNlTWF0ZXJpYWwoKSB7XG4gICAgICByZXR1cm4gZmlyc3QodGhpcy5tYXRlcmlhbCkuZ2V0RGlzdGFuY2VNYXRlcmlhbCgpXG4gICAgfVxuXG4gICAgX3ByZXBhcmVGb3JSZW5kZXIobWF0ZXJpYWwpIHtcbiAgICAgIGNvbnN0IGlzT3V0bGluZSA9IG1hdGVyaWFsLmlzVGV4dE91dGxpbmVNYXRlcmlhbDtcbiAgICAgIGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgICBjb25zdCB0ZXh0SW5mbyA9IHRoaXMudGV4dFJlbmRlckluZm87XG4gICAgICBpZiAodGV4dEluZm8pIHtcbiAgICAgICAgY29uc3Qge3NkZlRleHR1cmUsIGJsb2NrQm91bmRzfSA9IHRleHRJbmZvO1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthU0RGVGV4dHVyZS52YWx1ZSA9IHNkZlRleHR1cmU7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZUZXh0dXJlU2l6ZS52YWx1ZS5zZXQoc2RmVGV4dHVyZS5pbWFnZS53aWR0aCwgc2RmVGV4dHVyZS5pbWFnZS5oZWlnaHQpO1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthU0RGR2x5cGhTaXplLnZhbHVlID0gdGV4dEluZm8uc2RmR2x5cGhTaXplO1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthU0RGRXhwb25lbnQudmFsdWUgPSB0ZXh0SW5mby5zZGZFeHBvbmVudDtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVRvdGFsQm91bmRzLnZhbHVlLmZyb21BcnJheShibG9ja0JvdW5kcyk7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FVc2VHbHlwaENvbG9ycy52YWx1ZSA9ICFpc091dGxpbmUgJiYgISF0ZXh0SW5mby5nbHlwaENvbG9ycztcblxuICAgICAgICBsZXQgZGlzdGFuY2VPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgYmx1clJhZGl1cyA9IDA7XG4gICAgICAgIGxldCBzdHJva2VXaWR0aCA9IDA7XG4gICAgICAgIGxldCBmaWxsT3BhY2l0eTtcbiAgICAgICAgbGV0IHN0cm9rZU9wYWNpdHk7XG4gICAgICAgIGxldCBzdHJva2VDb2xvcjtcbiAgICAgICAgbGV0IG9mZnNldFggPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0WSA9IDA7XG5cbiAgICAgICAgaWYgKGlzT3V0bGluZSkge1xuICAgICAgICAgIGxldCB7b3V0bGluZVdpZHRoLCBvdXRsaW5lT2Zmc2V0WCwgb3V0bGluZU9mZnNldFksIG91dGxpbmVCbHVyLCBvdXRsaW5lT3BhY2l0eX0gPSB0aGlzO1xuICAgICAgICAgIGRpc3RhbmNlT2Zmc2V0ID0gdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVXaWR0aCkgfHwgMDtcbiAgICAgICAgICBibHVyUmFkaXVzID0gTWF0aC5tYXgoMCwgdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVCbHVyKSB8fCAwKTtcbiAgICAgICAgICBmaWxsT3BhY2l0eSA9IG91dGxpbmVPcGFjaXR5O1xuICAgICAgICAgIG9mZnNldFggPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZU9mZnNldFgpIHx8IDA7XG4gICAgICAgICAgb2Zmc2V0WSA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lT2Zmc2V0WSkgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IE1hdGgubWF4KDAsIHRoaXMuX3BhcnNlUGVyY2VudCh0aGlzLnN0cm9rZVdpZHRoKSB8fCAwKTtcbiAgICAgICAgICBpZiAoc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yID0gdGhpcy5zdHJva2VDb2xvcjtcbiAgICAgICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VDb2xvci52YWx1ZS5zZXQoc3Ryb2tlQ29sb3IgPT0gbnVsbCA/IGRlZmF1bHRTdHJva2VDb2xvciA6IHN0cm9rZUNvbG9yKTtcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHkgPSB0aGlzLnN0cm9rZU9wYWNpdHk7XG4gICAgICAgICAgICBpZiAoc3Ryb2tlT3BhY2l0eSA9PSBudWxsKSBzdHJva2VPcGFjaXR5ID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlsbE9wYWNpdHkgPSB0aGlzLmZpbGxPcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYURpc3RhbmNlT2Zmc2V0LnZhbHVlID0gZGlzdGFuY2VPZmZzZXQ7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FQb3NpdGlvbk9mZnNldC52YWx1ZS5zZXQob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FCbHVyUmFkaXVzLnZhbHVlID0gYmx1clJhZGl1cztcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZVdpZHRoLnZhbHVlID0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VPcGFjaXR5LnZhbHVlID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUZpbGxPcGFjaXR5LnZhbHVlID0gZmlsbE9wYWNpdHkgPT0gbnVsbCA/IDEgOiBmaWxsT3BhY2l0eTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUN1cnZlUmFkaXVzLnZhbHVlID0gdGhpcy5jdXJ2ZVJhZGl1cyB8fCAwO1xuXG4gICAgICAgIGxldCBjbGlwUmVjdCA9IHRoaXMuY2xpcFJlY3Q7XG4gICAgICAgIGlmIChjbGlwUmVjdCAmJiBBcnJheS5pc0FycmF5KGNsaXBSZWN0KSAmJiBjbGlwUmVjdC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICB1bmlmb3Jtcy51VHJvaWthQ2xpcFJlY3QudmFsdWUuZnJvbUFycmF5KGNsaXBSZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBjbGlwcGluZyAtIGNob29zZSBhIGZpbml0ZSByZWN0IHRoYXQgc2hvdWxkbid0IGV2ZXIgYmUgcmVhY2hlZCBieSBvdmVyZmxvd2luZyBnbHlwaHMgb3Igb3V0bGluZXNcbiAgICAgICAgICBjb25zdCBwYWQgPSAodGhpcy5mb250U2l6ZSB8fCAwLjEpICogMTAwO1xuICAgICAgICAgIHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZS5zZXQoXG4gICAgICAgICAgICBibG9ja0JvdW5kc1swXSAtIHBhZCxcbiAgICAgICAgICAgIGJsb2NrQm91bmRzWzFdIC0gcGFkLFxuICAgICAgICAgICAgYmxvY2tCb3VuZHNbMl0gKyBwYWQsXG4gICAgICAgICAgICBibG9ja0JvdW5kc1szXSArIHBhZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW9tZXRyeS5hcHBseUNsaXBSZWN0KHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGRGVidWcudmFsdWUgPSAhIXRoaXMuZGVidWdTREY7XG4gICAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gISF0aGlzLmRlcHRoT2Zmc2V0O1xuICAgICAgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciA9IG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMuZGVwdGhPZmZzZXQgfHwgMDtcblxuICAgICAgLy8gU2hvcnRjdXQgZm9yIHNldHRpbmcgbWF0ZXJpYWwgY29sb3IgdmlhIGBjb2xvcmAgcHJvcCBvbiB0aGUgbWVzaDsgdGhpcyBpc1xuICAgICAgLy8gYXBwbGllZCBvbmx5IHRvIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIGF2b2lkIG11dGF0aW5nIGEgc2hhcmVkIGJhc2UgbWF0ZXJpYWwuXG4gICAgICBjb25zdCBjb2xvciA9IGlzT3V0bGluZSA/ICh0aGlzLm91dGxpbmVDb2xvciB8fCAwKSA6IHRoaXMuY29sb3I7XG5cbiAgICAgIGlmIChjb2xvciA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBtYXRlcmlhbC5jb2xvcjsgLy9pbmhlcml0IGZyb20gYmFzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sb3JPYmogPSBtYXRlcmlhbC5oYXNPd25Qcm9wZXJ0eSgnY29sb3InKSA/IG1hdGVyaWFsLmNvbG9yIDogKG1hdGVyaWFsLmNvbG9yID0gbmV3IHRocmVlLkNvbG9yKCkpO1xuICAgICAgICBpZiAoY29sb3IgIT09IGNvbG9yT2JqLl9pbnB1dCB8fCB0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY29sb3JPYmouc2V0KGNvbG9yT2JqLl9pbnB1dCA9IGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBiYXNlIG9yaWVudGF0aW9uXG4gICAgICBsZXQgb3JpZW50ID0gdGhpcy5vcmllbnRhdGlvbiB8fCBkZWZhdWx0T3JpZW50O1xuICAgICAgaWYgKG9yaWVudCAhPT0gbWF0ZXJpYWwuX29yaWVudGF0aW9uKSB7XG4gICAgICAgIGxldCByb3RNYXQgPSB1bmlmb3Jtcy51VHJvaWthT3JpZW50LnZhbHVlO1xuICAgICAgICBvcmllbnQgPSBvcmllbnQucmVwbGFjZSgvW14tK3h5el0vZywgJycpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBvcmllbnQgIT09IGRlZmF1bHRPcmllbnQgJiYgb3JpZW50Lm1hdGNoKC9eKFstK10pKFt4eXpdKShbLStdKShbeHl6XSkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGxldCBbLCBoU2lnbiwgaEF4aXMsIHZTaWduLCB2QXhpc10gPSBtYXRjaDtcbiAgICAgICAgICB0ZW1wVmVjM2Euc2V0KDAsIDAsIDApW2hBeGlzXSA9IGhTaWduID09PSAnLScgPyAxIDogLTE7XG4gICAgICAgICAgdGVtcFZlYzNiLnNldCgwLCAwLCAwKVt2QXhpc10gPSB2U2lnbiA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgIHRlbXBNYXQ0Lmxvb2tBdChvcmlnaW4sIHRlbXBWZWMzYS5jcm9zcyh0ZW1wVmVjM2IpLCB0ZW1wVmVjM2IpO1xuICAgICAgICAgIHJvdE1hdC5zZXRGcm9tTWF0cml4NCh0ZW1wTWF0NCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm90TWF0LmlkZW50aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0ZXJpYWwuX29yaWVudGF0aW9uID0gb3JpZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIF9wYXJzZVBlcmNlbnQodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKC0/W1xcZC5dKyklJC8pO1xuICAgICAgICBsZXQgcGN0ID0gbWF0Y2ggPyBwYXJzZUZsb2F0KG1hdGNoWzFdKSA6IE5hTjtcbiAgICAgICAgdmFsdWUgPSAoaXNOYU4ocGN0KSA/IDAgOiBwY3QgLyAxMDApICogdGhpcy5mb250U2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZSBhIHBvaW50IGluIGxvY2FsIHNwYWNlIHRvIGFuIHgveSBpbiB0aGUgdGV4dCBwbGFuZS5cbiAgICAgKi9cbiAgICBsb2NhbFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgdGhyZWUuVmVjdG9yMigpKSB7XG4gICAgICB0YXJnZXQuY29weShwb3NpdGlvbik7IC8vc2ltcGxlIG5vbi1jdXJ2ZWQgY2FzZSBpcyAxOjFcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmN1cnZlUmFkaXVzO1xuICAgICAgaWYgKHIpIHsgLy9mbGF0dGVuIHRoZSBjdXJ2ZVxuICAgICAgICB0YXJnZXQueCA9IE1hdGguYXRhbjIocG9zaXRpb24ueCwgTWF0aC5hYnMocikgLSBNYXRoLmFicyhwb3NpdGlvbi56KSkgKiBNYXRoLmFicyhyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiB3b3JsZCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAgICovXG4gICAgd29ybGRQb3NpdGlvblRvVGV4dENvb3Jkcyhwb3NpdGlvbiwgdGFyZ2V0ID0gbmV3IHRocmVlLlZlY3RvcjIoKSkge1xuICAgICAgdGVtcFZlYzNhLmNvcHkocG9zaXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWxQb3NpdGlvblRvVGV4dENvb3Jkcyh0aGlzLndvcmxkVG9Mb2NhbCh0ZW1wVmVjM2EpLCB0YXJnZXQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlIEN1c3RvbSByYXljYXN0aW5nIHRvIHRlc3QgYWdhaW5zdCB0aGUgd2hvbGUgdGV4dCBibG9jaydzIG1heCByZWN0YW5ndWxhciBib3VuZHNcbiAgICAgKiBUT0RPIGlzIHRoZXJlIGFueSByZWFzb24gdG8gbWFrZSB0aGlzIG1vcmUgZ3JhbnVsYXIsIGxpa2Ugd2l0aGluIGluZGl2aWR1YWwgbGluZSBvciBnbHlwaCByZWN0cz9cbiAgICAgKi9cbiAgICByYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICAgICAgY29uc3Qge3RleHRSZW5kZXJJbmZvLCBjdXJ2ZVJhZGl1c30gPSB0aGlzO1xuICAgICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRleHRSZW5kZXJJbmZvLmJsb2NrQm91bmRzO1xuICAgICAgICBjb25zdCByYXljYXN0TWVzaCA9IGN1cnZlUmFkaXVzID8gZ2V0Q3VydmVkUmF5Y2FzdE1lc2goKSA6IGdldEZsYXRSYXljYXN0TWVzaCgpO1xuICAgICAgICBjb25zdCBnZW9tID0gcmF5Y2FzdE1lc2guZ2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IHtwb3NpdGlvbiwgdXZ9ID0gZ2VvbS5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV2LmNvdW50OyBpKyspIHtcbiAgICAgICAgICBsZXQgeCA9IGJvdW5kc1swXSArICh1di5nZXRYKGkpICogKGJvdW5kc1syXSAtIGJvdW5kc1swXSkpO1xuICAgICAgICAgIGNvbnN0IHkgPSBib3VuZHNbMV0gKyAodXYuZ2V0WShpKSAqIChib3VuZHNbM10gLSBib3VuZHNbMV0pKTtcbiAgICAgICAgICBsZXQgeiA9IDA7XG4gICAgICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgICAgICB6ID0gY3VydmVSYWRpdXMgLSBNYXRoLmNvcyh4IC8gY3VydmVSYWRpdXMpICogY3VydmVSYWRpdXM7XG4gICAgICAgICAgICB4ID0gTWF0aC5zaW4oeCAvIGN1cnZlUmFkaXVzKSAqIGN1cnZlUmFkaXVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooaSwgeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbS5ib3VuZGluZ1NwaGVyZSA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmU7XG4gICAgICAgIGdlb20uYm91bmRpbmdCb3ggPSB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nQm94O1xuICAgICAgICByYXljYXN0TWVzaC5tYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG4gICAgICAgIHJheWNhc3RNZXNoLm1hdGVyaWFsLnNpZGUgPSB0aGlzLm1hdGVyaWFsLnNpZGU7XG4gICAgICAgIHRlbXBBcnJheS5sZW5ndGggPSAwO1xuICAgICAgICByYXljYXN0TWVzaC5yYXljYXN0KHJheWNhc3RlciwgdGVtcEFycmF5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0ZW1wQXJyYXlbaV0ub2JqZWN0ID0gdGhpcztcbiAgICAgICAgICBpbnRlcnNlY3RzLnB1c2godGVtcEFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvcHkoc291cmNlKSB7XG4gICAgICAvLyBQcmV2ZW50IGNvcHlpbmcgdGhlIGdlb21ldHJ5IHJlZmVyZW5jZSBzbyB3ZSBkb24ndCBlbmQgdXAgc2hhcmluZyBhdHRyaWJ1dGVzIGJldHdlZW4gaW5zdGFuY2VzXG4gICAgICBjb25zdCBnZW9tID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgIHN1cGVyLmNvcHkoc291cmNlKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tO1xuXG4gICAgICBDT1BZQUJMRV9QUk9QUy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICB0aGlzW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQ3JlYXRlIHNldHRlcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGV4dCBsYXlvdXQ6XG4gIFNZTkNBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9ICdfcHJpdmF0ZV8nICsgcHJvcDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIHByb3AsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbcHJpdmF0ZUtleV1cbiAgICAgIH0sXG4gICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzW3ByaXZhdGVLZXldKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy89PT0gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBjYXJldHMgYW5kIHNlbGVjdGlvbiByYW5nZXMgPT09Ly9cblxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gVGV4dENhcmV0XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0geCBwb3NpdGlvbiBvZiB0aGUgY2FyZXRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSB5IHBvc2l0aW9uIG9mIHRoZSBjYXJldCdzIGJvdHRvbVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBjYXJldFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gY2hhckluZGV4IC0gdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmcgb2YgdGhpcyBjYXJldCdzIHRhcmdldFxuICAgKiAgIGNoYXJhY3RlcjsgdGhlIGNhcmV0IHdpbGwgYmUgZm9yIHRoZSBwb3NpdGlvbiBfYmVmb3JlXyB0aGF0IGNoYXJhY3Rlci5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgbG9jYWwgeC95IGNvb3JkaW5hdGUgaW4gdGhlIHRleHQgYmxvY2sgcGxhbmUsIGZpbmQgdGhlIG5lYXJlc3QgY2FyZXQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvIC0gYSByZXN1bHQgb2JqZWN0IGZyb20gVGV4dEJ1aWxkZXIjZ2V0VGV4dFJlbmRlckluZm9cbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7VGV4dENhcmV0IHwgbnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldENhcmV0QXRQb2ludCh0ZXh0UmVuZGVySW5mbywgeCwgeSkge1xuICAgIGxldCBjbG9zZXN0Q2FyZXQgPSBudWxsO1xuICAgIGNvbnN0IHJvd3MgPSBncm91cENhcmV0c0J5Um93KHRleHRSZW5kZXJJbmZvKTtcblxuICAgIC8vIEZpbmQgbmVhcmVzdCByb3cgYnkgeSBmaXJzdFxuICAgIGxldCBjbG9zZXN0Um93ID0gbnVsbDtcbiAgICByb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgIGlmICghY2xvc2VzdFJvdyB8fCBNYXRoLmFicyh5IC0gKHJvdy50b3AgKyByb3cuYm90dG9tKSAvIDIpIDwgTWF0aC5hYnMoeSAtIChjbG9zZXN0Um93LnRvcCArIGNsb3Nlc3RSb3cuYm90dG9tKSAvIDIpKSB7XG4gICAgICAgIGNsb3Nlc3RSb3cgPSByb3c7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGVuIGZpbmQgY2xvc2VzdCBjYXJldCBieSB4IHdpdGhpbiB0aGF0IHJvd1xuICAgIGNsb3Nlc3RSb3cuY2FyZXRzLmZvckVhY2goY2FyZXQgPT4ge1xuICAgICAgaWYgKCFjbG9zZXN0Q2FyZXQgfHwgTWF0aC5hYnMoeCAtIGNhcmV0LngpIDwgTWF0aC5hYnMoeCAtIGNsb3Nlc3RDYXJldC54KSkge1xuICAgICAgICBjbG9zZXN0Q2FyZXQgPSBjYXJldDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xvc2VzdENhcmV0XG4gIH1cblxuXG4gIGNvbnN0IF9yZWN0c0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuICAvKipcbiAgICogR2l2ZW4gc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXIgaW5kZXhlcywgcmV0dXJuIGEgbGlzdCBvZiByZWN0YW5nbGVzIGNvdmVyaW5nIGFsbCB0aGVcbiAgICogY2hhcmFjdGVycyB3aXRoaW4gdGhhdCBzZWxlY3Rpb24uXG4gICAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGluIHRoZSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzZWxlY3Rpb25cbiAgICogQHJldHVybiB7QXJyYXk8e2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0+IHwgbnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldFNlbGVjdGlvblJlY3RzKHRleHRSZW5kZXJJbmZvLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IHJlY3RzO1xuICAgIGlmICh0ZXh0UmVuZGVySW5mbykge1xuICAgICAgLy8gQ2hlY2sgY2FjaGUgLSB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gICAgICBsZXQgcHJldlJlc3VsdCA9IF9yZWN0c0NhY2hlLmdldCh0ZXh0UmVuZGVySW5mbyk7XG4gICAgICBpZiAocHJldlJlc3VsdCAmJiBwcmV2UmVzdWx0LnN0YXJ0ID09PSBzdGFydCAmJiBwcmV2UmVzdWx0LmVuZCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiBwcmV2UmVzdWx0LnJlY3RzXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtjYXJldFBvc2l0aW9uc30gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgICAgLy8gTm9ybWFsaXplXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgY29uc3QgcyA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgZW5kID0gcztcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBjYXJldFBvc2l0aW9ucy5sZW5ndGggKyAxKTtcblxuICAgICAgLy8gQnVpbGQgbGlzdCBvZiByZWN0cywgZXhwYW5kaW5nIHRoZSBjdXJyZW50IHJlY3QgZm9yIGFsbCBjaGFyYWN0ZXJzIGluIGEgcnVuIGFuZCBzdGFydGluZ1xuICAgICAgLy8gYSBuZXcgcmVjdCB3aGVuZXZlciByZWFjaGluZyBhIG5ldyBsaW5lIG9yIGEgbmV3IGJpZGkgZGlyZWN0aW9uXG4gICAgICByZWN0cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSZWN0ID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHgxID0gY2FyZXRQb3NpdGlvbnNbaSAqIDRdO1xuICAgICAgICBjb25zdCB4MiA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbih4MSwgeDIpO1xuICAgICAgICBjb25zdCByaWdodCA9IE1hdGgubWF4KHgxLCB4Mik7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IHRvcCA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgM107XG4gICAgICAgIGlmICghY3VycmVudFJlY3QgfHwgYm90dG9tICE9PSBjdXJyZW50UmVjdC5ib3R0b20gfHwgdG9wICE9PSBjdXJyZW50UmVjdC50b3AgfHwgbGVmdCA+IGN1cnJlbnRSZWN0LnJpZ2h0IHx8IHJpZ2h0IDwgY3VycmVudFJlY3QubGVmdCkge1xuICAgICAgICAgIGN1cnJlbnRSZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogSW5maW5pdHksXG4gICAgICAgICAgICByaWdodDogLUluZmluaXR5LFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVjdHMucHVzaChjdXJyZW50UmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFJlY3QubGVmdCA9IE1hdGgubWluKGxlZnQsIGN1cnJlbnRSZWN0LmxlZnQpO1xuICAgICAgICBjdXJyZW50UmVjdC5yaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBjdXJyZW50UmVjdC5yaWdodCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1lcmdlIGFueSBvdmVybGFwcGluZyByZWN0cywgZS5nLiB0aG9zZSBmb3JtZWQgYnkgYWRqYWNlbnQgYmlkaSBydW5zXG4gICAgICByZWN0cy5zb3J0KChhLCBiKSA9PiBiLmJvdHRvbSAtIGEuYm90dG9tIHx8IGEubGVmdCAtIGIubGVmdCk7XG4gICAgICBmb3IgKGxldCBpID0gcmVjdHMubGVuZ3RoIC0gMTsgaS0tID4gMDspIHtcbiAgICAgICAgY29uc3QgcmVjdEEgPSByZWN0c1tpXTtcbiAgICAgICAgY29uc3QgcmVjdEIgPSByZWN0c1tpICsgMV07XG4gICAgICAgIGlmIChyZWN0QS5ib3R0b20gPT09IHJlY3RCLmJvdHRvbSAmJiByZWN0QS50b3AgPT09IHJlY3RCLnRvcCAmJiByZWN0QS5sZWZ0IDw9IHJlY3RCLnJpZ2h0ICYmIHJlY3RBLnJpZ2h0ID49IHJlY3RCLmxlZnQpIHtcbiAgICAgICAgICByZWN0Qi5sZWZ0ID0gTWF0aC5taW4ocmVjdEIubGVmdCwgcmVjdEEubGVmdCk7XG4gICAgICAgICAgcmVjdEIucmlnaHQgPSBNYXRoLm1heChyZWN0Qi5yaWdodCwgcmVjdEEucmlnaHQpO1xuICAgICAgICAgIHJlY3RzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfcmVjdHNDYWNoZS5zZXQodGV4dFJlbmRlckluZm8sIHtzdGFydCwgZW5kLCByZWN0c30pO1xuICAgIH1cbiAgICByZXR1cm4gcmVjdHNcbiAgfVxuXG4gIGNvbnN0IF9jYXJldHNCeVJvd0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuICAvKipcbiAgICogR3JvdXAgYSBzZXQgb2YgY2FyZXRzIGJ5IHJvdyBvZiB0ZXh0LCBjYWNoaW5nIHRoZSByZXN1bHQuIEEgc2luZ2xlIHJvdyBvZiB0ZXh0IG1heSBjb250YWluIGNhcmV0cyBvZlxuICAgKiBkaWZmZXJpbmcgcG9zaXRpb25zL2hlaWdodHMgaWYgaXQgaGFzIG11bHRpcGxlIGZvbnRzLCBhbmQgdGhleSBtYXkgb3ZlcmxhcCBzbGlnaHRseSBhY3Jvc3Mgcm93cywgc28gdGhpc1xuICAgKiB1c2VzIGFuIGFzc3VtcHRpb24gb2YgXCJhdCBsZWFzdCBvdmVybGFwcGluZyBieSBoYWxmXCIgdG8gcHV0IHRoZW0gaW4gdGhlIHNhbWUgcm93LlxuICAgKiBAcmV0dXJuIEFycmF5PHtib3R0b206IG51bWJlciwgdG9wOiBudW1iZXIsIGNhcmV0czogVGV4dENhcmV0W119PlxuICAgKi9cbiAgZnVuY3Rpb24gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbykge1xuICAgIC8vIHRleHRSZW5kZXJJbmZvIGlzIGZyb3plbiBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgYmFzZWQgb24gaXRcbiAgICBsZXQgcm93cyA9IF9jYXJldHNCeVJvd0NhY2hlLmdldCh0ZXh0UmVuZGVySW5mbyk7XG4gICAgaWYgKCFyb3dzKSB7XG4gICAgICByb3dzID0gW107XG4gICAgICBjb25zdCB7Y2FyZXRQb3NpdGlvbnN9ID0gdGV4dFJlbmRlckluZm87XG4gICAgICBsZXQgY3VyUm93O1xuXG4gICAgICBjb25zdCB2aXNpdENhcmV0ID0gKHgsIGJvdHRvbSwgdG9wLCBjaGFySW5kZXgpID0+IHtcbiAgICAgICAgLy8gbmV3IHJvdyBpZiBub3Qgb3ZlcmxhcHBpbmcgYnkgYXQgbGVhc3QgaGFsZlxuICAgICAgICBpZiAoIWN1clJvdyB8fCAodG9wIDwgKGN1clJvdy50b3AgKyBjdXJSb3cuYm90dG9tKSAvIDIpKSB7XG4gICAgICAgICAgcm93cy5wdXNoKGN1clJvdyA9IHtib3R0b20sIHRvcCwgY2FyZXRzOiBbXX0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGFuZCB2ZXJ0aWNhbCBsaW1pdHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmICh0b3AgPiBjdXJSb3cudG9wKSBjdXJSb3cudG9wID0gdG9wO1xuICAgICAgICBpZiAoYm90dG9tIDwgY3VyUm93LmJvdHRvbSkgY3VyUm93LmJvdHRvbSA9IGJvdHRvbTtcbiAgICAgICAgY3VyUm93LmNhcmV0cy5wdXNoKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHk6IGJvdHRvbSxcbiAgICAgICAgICBoZWlnaHQ6IHRvcCAtIGJvdHRvbSxcbiAgICAgICAgICBjaGFySW5kZXgsXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yICg7IGkgPCBjYXJldFBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICB2aXNpdENhcmV0KGNhcmV0UG9zaXRpb25zW2ldLCBjYXJldFBvc2l0aW9uc1tpICsgMl0sIGNhcmV0UG9zaXRpb25zW2kgKyAzXSwgaSAvIDQpO1xuICAgICAgfVxuICAgICAgLy8gQWRkIG9uZSBtb3JlIGNhcmV0IGFmdGVyIHRoZSBmaW5hbCBjaGFyXG4gICAgICB2aXNpdENhcmV0KGNhcmV0UG9zaXRpb25zW2kgLSAzXSwgY2FyZXRQb3NpdGlvbnNbaSAtIDJdLCBjYXJldFBvc2l0aW9uc1tpIC0gMV0sIGkgLyA0KTtcbiAgICB9XG4gICAgX2NhcmV0c0J5Um93Q2FjaGUuc2V0KHRleHRSZW5kZXJJbmZvLCByb3dzKTtcbiAgICByZXR1cm4gcm93c1xuICB9XG5cbiAgZXhwb3J0cy5HbHlwaHNHZW9tZXRyeSA9IEdseXBoc0dlb21ldHJ5O1xuICBleHBvcnRzLlRleHQgPSBUZXh0O1xuICBleHBvcnRzLmNvbmZpZ3VyZVRleHRCdWlsZGVyID0gY29uZmlndXJlVGV4dEJ1aWxkZXI7XG4gIGV4cG9ydHMuY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWw7XG4gIGV4cG9ydHMuZHVtcFNERlRleHR1cmVzID0gZHVtcFNERlRleHR1cmVzO1xuICBleHBvcnRzLmZvbnRSZXNvbHZlcldvcmtlck1vZHVsZSA9IGZvbnRSZXNvbHZlcldvcmtlck1vZHVsZTtcbiAgZXhwb3J0cy5nZXRDYXJldEF0UG9pbnQgPSBnZXRDYXJldEF0UG9pbnQ7XG4gIGV4cG9ydHMuZ2V0U2VsZWN0aW9uUmVjdHMgPSBnZXRTZWxlY3Rpb25SZWN0cztcbiAgZXhwb3J0cy5nZXRUZXh0UmVuZGVySW5mbyA9IGdldFRleHRSZW5kZXJJbmZvO1xuICBleHBvcnRzLnByZWxvYWRGb250ID0gcHJlbG9hZEZvbnQ7XG4gIGV4cG9ydHMudHlwZXNldHRlcldvcmtlck1vZHVsZSA9IHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js\n");

/***/ })

};
;